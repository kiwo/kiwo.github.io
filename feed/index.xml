<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Mikhail Shilkov</title>
    <link href="http://mikhail.io/feed/" rel="self"/>
    <link href="http://mikhail.io"/>
    <updated>2016-03-21T08:37:34.983Z</updated>
    <id>http://mikhail.io/</id>
    <author>
        <name>Mikhail Shilkov</name>
        <email></email>
    </author>

    
    <entry>
        <title>Functional Actor Patterns with Akka.NET and F#</title>
        <link href="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp"/>
        <updated>2016-03-21T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-03-21,/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp</id>
        <content type="html"><![CDATA[<p>My exploration of Actor model started with <a href="http://getakka.net">Akka.NET</a> framework - a .NET port of
JVM-based <a href="http://akka.io">Akka</a>. Actor programming model made a lot of sense to me, but once
I started playing with it, some questions arose. Most of those questions were related to the
following <a href="http://doc.akka.io/docs/akka/2.4.2/general/actors.html">definition</a>:</p>
<blockquote>
<p>An actor is a container for <code>State</code>, <code>Behavior</code>, a <code>Mailbox</code>, <code>Children</code> and a <code>Supervisor Strategy</code>.</p>
</blockquote>
<p>So, based on the <a href="https://github.com/petabridge/akka-bootcamp">Akka.NET Bootcamp</a> course I understood that
an Actor</p>
<ul>
<li>knows what kind of messages it can accept</li>
<li>does some processing of each message</li>
<li>holds some state which is changed during message processing</li>
<li>potentially changes its behavior based on the current state</li>
<li>creates and stores references to child actors</li>
<li>obtains references to other actors</li>
<li>sends messages to children and other actors</li>
</ul>
<p>While it&#39;s nice that the framework enables us to develop for different aspects of actor 
behavior, it might also be dangerous in case you do all the things in one place. Ball of spaghetti mud
was where I ended up during my first attempt. My actors were doing all the things from 
the above list and the code got messy very quick. So, the following questions popped up
in my head:</p>
<p><em>How do I avoid mixing several concerns in one piece of code?</em></p>
<p><em>How do I make the code easily testable?</em></p>
<p><em>How do I minimize the usage of mutable state?</em></p>
<p><em>How do I avoid boilerplate code when it&#39;s not needed?</em></p>
<h2 id="functional-actors">Functional Actors</h2>
<p>I am now developing the actor-based application in F#, the functional first
language. Functions are easy to reason about, reusable and testable. But the
actors are usually defined in terms of objects and classes. F# supports classes
but that&#39;s not the path that I&#39;m willing to go.</p>
<p>How do we make actors out of functions? Well, most of the time actors don&#39;t 
need all the features of the framework. In this case we can define the required actor
behavior in terms of a minimal function and then use creational patterns to
spawn actor instances out of it.</p>
<p>Let&#39;s look at some common patterns that I identified. For each pattern, I will
define </p>
<ul>
<li>an example of a core function which implements the business logic</li>
<li>a generic function to create actors with behavior of a core function</li>
<li>an example of actor instantiation using the two functions above</li>
</ul>
<hr>
<h2 id="message-sink">Message Sink</h2>
<p>Stateless Message Sink is the simplest type of actor.</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/messagesink.png" alt="Message Sink actor"></p>
<p>It receives a message and executes some action on it. The action is not related
to any other actors, and there is no state, so the processing of each message
is always the same. Obviously, it&#39;s related to some kind of side effects:
logging the message, saving the data to the external storage and so on.</p>
<p>So, we don&#39;t need the majority of actor features in this case. The whole actor
processing could be represented by a function of type <code>&#39;a -&gt; unit</code>. Here 
is an example of a core function:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> print msg =
  printn <span class="hljs-string">"Message received: %A"</span> msg
</code></pre>
<p>So how do we make an actor out of this function? The <code>actorOf2</code> helper function
from Akka.NET F# extensions comes into play:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> actorOfSink (f : <span class="hljs-attribute">'a</span> -&gt; unit) =
  actorOf2 (<span class="hljs-keyword">fun</span> _ msg -&gt; f msg)
</code></pre>
<p>And here is how we spawn an actor instance:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> printActorRef = 
  actorOfSink print 
  |&gt; spawn system <span class="hljs-string">"print-actor"</span>

printActorRef &lt;! <span class="hljs-number">3</span>
<span class="hljs-comment">// "Message received: 3" is printed</span>
</code></pre>
<p>That&#39;s the simplicity that I&#39;m searching for. Let&#39;s look at a slightly more
complex example.</p>
<hr>
<h2 id="converter">Converter</h2>
<p>Stateless Converter maps the incoming message into another message and sends
it to another predefined actor.</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/converter.png" alt="Converter actor"></p>
<p>The core of this actor is a classic function with one input and one output
parameter (type <code>&#39;a - &#39;b</code>):</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> square msg =
  msg * msg
</code></pre>
<p>The actor function is similar to the one of Message Sink, but it also accepts
a reference to the output actor and knows how to send messages to it:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> actorOfConvert f outputRef =
  actorOf2 (<span class="hljs-keyword">fun</span> _ msg -&gt; outputRef &lt;! f msg)
</code></pre>
<p>Here is how we spawn an instance of a Converter using our <code>print-actor</code> as the
output:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> squareActorRef = 
  actorOfConvert square printActorRef 
  |&gt; spawn system <span class="hljs-string">"square-actor"</span>

squareActorRef &lt;! <span class="hljs-number">3</span>
<span class="hljs-comment">// "Message received: 9" is printed</span>
</code></pre>
<p>Both actor patterns had no notion of state so far. Let&#39;s see how we can 
treat the statefulness in a functional way.</p>
<hr>
<h2 id="stateful-sink">Stateful Sink</h2>
<p>Let&#39;s get back to our Message Sink actor with side-effects, and make it
dependent on its internal state. The state is affected by the incoming 
messages and is preserved until the next message comes in.</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/statefulsink.png" alt="Stateful Sink actor"></p>
<p>Does not look very functional, right? But this impression is wrong in fact.
We can represent the state before a message came in - as an extra input parameter, 
and  the state after the message got processed - as an output parameter. 
We start with an initial state and the output of the
first message becomes the input state of the second message:</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/statefulsinkfunctional.png" alt="Stateful Sink functional actor"></p>
<p>Here is an example of a function which prints out the index of a message together
with the message contents:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> printIndex index msg =
  printn <span class="hljs-string">"Message [%i] received: %A"</span> index msg
  index + <span class="hljs-number">1</span>
</code></pre>
<p>For the actor implementation we need a recursive function so we can&#39;t use 
<code>actorOf2</code> anymore. Actor workflow is a bit more lines but still very simple:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> actorOfStatefulSink f initialState (mailbox : Actor&lt;<span class="hljs-attribute">'a</span>&gt;) =

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> imp lastState =
    actor {
      <span class="hljs-keyword">let</span>! msg = mailbox.Receive()
      <span class="hljs-keyword">let</span> newState = f msg lastState
      <span class="hljs-keyword">return</span>! imp newState
    }

  imp initialState
</code></pre>
<p>And here is a usage example:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> printIndexActorRef = 
  actorOfSink printIndex <span class="hljs-number">1</span>
  |&gt; spawn system <span class="hljs-string">"print-ix-actor"</span>

printActorRef &lt;! <span class="hljs-number">3</span>
<span class="hljs-comment">// "Message [1] received: 3" is printed</span>

printActorRef &lt;! <span class="hljs-number">4</span>
<span class="hljs-comment">// "Message [2] received: 4" is printed</span>
</code></pre>
<hr>
<h2 id="stateful-converter">Stateful Converter</h2>
<p>By now, the core function of the Stateful Converter actor should be a no-brainer for you. The actor
would have two input parameters and two outputs (in a tuple). One of the outputs
is a message and goes to another actor, the other output becomes an input for the
next actor:</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/statefulconverter.png" alt="Stateful Converter actor"></p>
<p>Here is a function which squares the messaged number, then calculates the running total
and sends it forward:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> squareAndSum sum msg =
  <span class="hljs-keyword">let</span> result = sum + msg*msg
  (result, result)
</code></pre>
<p>In this particular case the output message and state are equal, but they don&#39;t
have to be. Here is the actor implementation:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> actorOfStatefulConvert f initialState outputRef (mailbox : Actor&lt;<span class="hljs-attribute">'a</span>&gt;) =

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> imp lastState =
    actor {
      <span class="hljs-keyword">let</span>! msg = mailbox.Receive()
      <span class="hljs-keyword">let</span> (result, newState) = f msg lastState
      outputRef &lt;! result
      <span class="hljs-keyword">return</span>! imp newState
    }

  imp initialState
</code></pre>
<p>And a usage example:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> squareAndSumActorRef = 
  actorOfConvert square <span class="hljs-number">0</span> printIndexActorRef 
  |&gt; spawn system <span class="hljs-string">"square-sum-actor"</span>

squareAndSumActorRef &lt;! <span class="hljs-number">3</span>
<span class="hljs-comment">// "Message [1] received: 9" is printed</span>

squareAndSumActorRef &lt;! <span class="hljs-number">4</span>
<span class="hljs-comment">// "Message [2] received: 25" is printed</span>
</code></pre>
<hr>
<h2 id="converter-supervisor">Converter-Supervisor</h2>
<p>In the previous patterns the Converter actors were sending messages 
to predefined actor references which were not managed (or supervised in Akka terms)
by those actors. Now, let&#39;s say that the actor needs to create a child
to send converted messages to it afterwards: </p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/supervisedchild.png" alt="Supervised Child actor"></p>
<p>We can treat such child reference as the state and instantiate it when the first message
comes in. (We can&#39;t spawn it before the first message because the
<code>mailbox</code> object is required.) The message goes to the actor
reference that we store in the state, something like this:</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/childasstate.png" alt="Supervised Child as State"></p>
<p>Here is the generic actor implementation:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> actorOfConvertToChild f spawnChild (mailbox : Actor&lt;<span class="hljs-attribute">'a</span>&gt;) =

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> imp state =
    actor {
      <span class="hljs-keyword">let</span> newstate =
        <span class="hljs-keyword">match</span> state <span class="hljs-keyword">with</span>
        | Some s -&gt; s
        | None -&gt; spawnChild mailbox

      <span class="hljs-keyword">let</span>! msg = mailbox.Receive()
      newstate &lt;! f msg
      <span class="hljs-keyword">return</span>! imp (Some newstate)
    }

  imp None
</code></pre>
<p>The only difference is that we accept a <code>spawnChild</code> function instead of
pre-baked actor reference. Here is the first calculator example refactored
to Print actor being a child of Square actor.</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> squareWithChildRef = 
  actorOfConvertToChild print (spawnChild square <span class="hljs-string">"print-actor"</span>)
  |&gt; spawn system <span class="hljs-string">"square-with-child-actor"</span>
</code></pre>
<p>Notice that the <code>square</code> and <code>print</code> functions have exactly the same signatures
and implementations as we used before, and the concern of actor hierarchy is 
completely separated from the business logic of the actors.</p>
<p>This hierarchy is handy whenever you need multiple instances of one actor type
(<code>f</code>-actor from the picture) and corresponding instances of another actor type
(<code>g</code>-actor):</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/multiparents.png" alt="Multiple Parents and Children actor"></p>
<hr>
<h2 id="router-supervisor">Router-Supervisor</h2>
<p>Routers are the kind of actors which forward each incoming message to one
or more downstream actors. In this example the downstream actors are supervised
by the Router itself.
So, the Router-Supervisor can have multiple children and send the result of 
message processing to one or more of them:</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/router.png" alt="Router actor"></p>
<p>To keep the spirit of functional actors, we represent the router logic with a function
of type <code>&#39;a -&gt; seq&lt;string * &#39;b&gt;</code>, where <code>&#39;a</code> is the type of incoming messages,
<code>&#39;b</code> is the type of outgoing messages, and <code>string</code> represents the identifier of the 
actor to get the message. Here is a sample implementation:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> routeSensorData msg = 
  msg |&gt; Seq.map (<span class="hljs-keyword">fun</span> x -&gt; (<span class="hljs-string">"sensor-actor-"</span> + x.SensorId, x.Temperature))
</code></pre>
<p>Based on the incoming metadata (sensor identifier) the actor forwards its
temperature to corresponding sensor-specific actor. </p>
<p>Here is the implementation of the generic actor function:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> actorOfRouteToChildren f spawnChild (mailbox : Actor&lt;<span class="hljs-attribute">'a</span>&gt;) =

  <span class="hljs-keyword">let</span> getActor id = 
    <span class="hljs-keyword">let</span> actorRef = mailbox.Context.Child(id)
    <span class="hljs-keyword">if</span> actorRef.IsNobody() <span class="hljs-keyword">then</span>
      spawnChild id mailbox
    <span class="hljs-keyword">else</span> 
      actorRef

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> imp () =
    actor {
      <span class="hljs-keyword">let</span>! msg = mailbox.Receive()
      f msg |&gt; Seq.iter (<span class="hljs-keyword">fun</span> (id, x) -&gt; (getActor id) &lt;! x) 
      <span class="hljs-keyword">return</span>! imp ()
    }

  imp ()
</code></pre><p>And a usage example:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> sensorRouterRef = 
  actorOfRouteToChildren routeSensorData (spawnChild square)
  |&gt; spawn system <span class="hljs-string">"route-sensor-actor"</span>
</code></pre>
<p>Note that <code>spawnChild</code> does not accept the child ID anymore because it&#39;s being
controlled by the router itself.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>With the patterns that we have so far we should be able to build quite powerful
hierarchies like the one shown below:</p>
<p><img src="http://mikhail.io/2016/03/functional-actor-patterns-with-akkadotnet-and-fsharp/usecase.png" alt="Actor use case"></p>
<p>There might be many other scenarios and types of actors that would make sense
in your use case. I&#39;m just showing the basic patterns, but more importantly the way of 
reasoning about the code. Don&#39;t 
let the multitude of actor aspects push you into the world of poorly structured 
code.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Aurelia Map Component with Leaflet</title>
        <link href="http://mikhail.io/2016/03/aurelia-map-component-with-leaflet"/>
        <updated>2016-03-11T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-03-11,/2016/03/aurelia-map-component-with-leaflet</id>
        <content type="html"><![CDATA[<p>This is a short tutorial on how to create a map control in <a href="http://aurelia.io">Aurelia.js</a> 
application. I am using the <a href="http://leafletjs.com">Leaflet</a> library with custom tile
source and I also show the way to implement your own overlay layer. Here is what
my map looks like:</p>
<p><img src="http://mikhail.io/2016/03/aurelia-map-component-with-leaflet/map.png" alt="Map"></p>
<p>So, I assume you already have an existing Aurelia application, and let&#39;s start.</p>
<h2 id="install-leaflet">Install Leaflet</h2>
<p>The following command will install Leaflet module to the application:</p>
<pre class="highlight"><code class="hljs cmake">jspm <span class="hljs-keyword">install</span> leaflet
</code></pre><p>If you are using TypeScript, don&#39;t forget to add type definitions</p>
<pre class="highlight"><code class="hljs cmake">tsd <span class="hljs-keyword">install</span> leaflet
</code></pre><h2 id="define-a-map-component">Define a Map Component</h2>
<p>Create a new <code>map.html</code> file and put the following contents there:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">require</span> <span class="hljs-attribute">from</span>=<span class="hljs-value">"leaflet/dist/leaflet.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">require</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"mapid"</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">"height: 100%"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<p>We import the CSS required by leaflet and define the <code>div</code> element to host
the map in. Then, create a new <code>map.js</code> file (or <code>map.ts</code> for typescript),
here is the minimum code:</p>
<pre class="highlight"><code class="hljs javascript">export <span class="hljs-keyword">class</span> Map {
}
</code></pre>
<h2 id="load-the-map-with-tiles">Load the Map with Tiles</h2>
<p>First, import the leaflet module in your codebehind:</p>
<pre class="highlight"><code class="hljs javascript">import * as L from <span class="hljs-string">'leaflet'</span>;
</code></pre>
<p>Now, define the <code>attached</code> function, which would be called by Aurelia when
control&#39;s HTML is loaded, and make a map there:</p>
<pre class="highlight"><code class="hljs javascript">export <span class="hljs-keyword">class</span> Map {
  attached() {
    <span class="hljs-keyword">let</span> map = L.map(<span class="hljs-string">'mapid'</span>).setView([<span class="hljs-number">51.505</span>, -<span class="hljs-number">0.09</span>], <span class="hljs-number">13</span>);

    <span class="hljs-keyword">let</span> urlTemplate = <span class="hljs-string">'http://{s}.tile.osm.org/{z}/{x}/{y}.png'</span>;
    map.addLayer(L.tileLayer(urlTemplate, { minZoom: <span class="hljs-number">4</span> }));
  }
}
</code></pre>
<p>The example above uses the URL template of Open Street Maps as per the Leaflet&#39;s
tutorial, but I needed to use our privately hosted maps, so I changed it to
something like:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">let</span> urlTemplate = <span class="hljs-string">'http://www.mysite.com/tiles?layer=background&amp;level={z}&amp;x={x}&amp;y={y}'</span>;
map.addLayer(L.tileLayer(urlTemplate, { minZoom: <span class="hljs-number">4</span>, zoomOffset: <span class="hljs-number">8</span> }));
</code></pre>
<p>The <code>zoomOffset</code> parameter was required to fix impedance mismatch of zoom levels.</p>
<h2 id="custom-overlay-layer">Custom Overlay Layer</h2>
<p>For our custom maps we needed to show two layers on top of each other:</p>
<ul>
<li>The usual tile layer for the map background</li>
<li>The overlay layer for the map labels and additional information</li>
</ul>
<p>The overlay layer can&#39;t be broken down into tiles (not supported by our map provider),
so we need to show the whole layer as a single picture and then refresh it every
time user pans or zooms the map.</p>
<p>The overlay layer can be implemented with <code>onAdd</code> and <code>onRemove</code> functions
and then feeding an image element to the Leaflet as a layer. Here is the code:</p>
<pre class="highlight"><code class="hljs javascript">import * as L from <span class="hljs-string">'leaflet'</span>;

export <span class="hljs-keyword">class</span> LabelOverlayLayer {
  map;
  image;

  onAdd(map) {
    <span class="hljs-keyword">this</span>.map = map;

    <span class="hljs-keyword">this</span>.image = L.DomUtil.create(<span class="hljs-string">'img'</span>, <span class="hljs-string">'leaflet-tile-loaded'</span>);
    map.getPanes().overlayPane.appendChild(<span class="hljs-keyword">this</span>.image);

    map.on(<span class="hljs-string">'moveend'</span>, <span class="hljs-keyword">this</span>.render, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.render();
  }

  onRemove (map) {
    map.getPanes().overlayPane.removeChild(<span class="hljs-keyword">this</span>.image);
    map.off(<span class="hljs-string">'moveend'</span>, <span class="hljs-keyword">this</span>.render, <span class="hljs-keyword">this</span>);
  }

  render() {
    <span class="hljs-keyword">let</span> bounds = <span class="hljs-keyword">this</span>.map.getBounds(), mapSize = <span class="hljs-keyword">this</span>.map.getSize();
    <span class="hljs-keyword">let</span> se = bounds.getSouthEast(), nw = bounds.getNorthWest();

    <span class="hljs-keyword">let</span> tileUrl = `http:<span class="hljs-comment">//www.mysite.com/tiles?layer=labels&amp;lonmin=${nw.lng}&amp;latmin=${se.lat}&amp;lonmax=${se.lng}&amp;latmax=${nw.lat}&amp;width=${Math.floor(mapSize.x)}&amp;height=${Math.floor(mapSize.y)}`;</span>
    <span class="hljs-keyword">this</span>.image.src = tileUrl;

    <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.map.latLngToLayerPoint(nw);
    L.DomUtil.setPosition(<span class="hljs-keyword">this</span>.image, pos, <span class="hljs-literal">false</span>);
  }
};
</code></pre>
<p>The usage of this layer in the map component is trivial:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">this</span>.map.addLayer(<span class="hljs-keyword">new</span> LabelOverlayLayer());
</code></pre>
<h2 id="use-the-map-component">Use the Map Component</h2>
<p>The map component is ready to be used in the application:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">require</span> <span class="hljs-attribute">from</span>=<span class="hljs-value">"./components/map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">require</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span>  <span class="hljs-attribute">style</span>=<span class="hljs-value">"height: 700px"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">map</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">map</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>The container around the map should have a non-zero height, so I made it fixed
in the example above.</p>
<p>Don&#39;t forget to bundle the leaflet assets by including the following lines
into your <code>bundles.json</code>:</p>
<pre class="highlight"><code class="hljs undefined">"includes": [
  "aurelia-framework",
  // ...
  "leaflet",
  "leaflet/dist/leaflet.css!text"
],
</code></pre>
]]></content>
    </entry>
    
    <entry>
        <title>Building a Poker Bot: Mouse Movements</title>
        <link href="http://mikhail.io/2016/03/building-a-poker-bot-mouse-movements"/>
        <updated>2016-03-01T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-03-01,/2016/03/building-a-poker-bot-mouse-movements</id>
        <content type="html"><![CDATA[<p><em>This is the third part of <strong>Building a Poker Bot</strong> series where I describe my experience developing bot software 
to play in online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable. Here are the previous parts:</em></p>
<ul>
<li><a href="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/"><em>Building a Poker Bot: Card Recognition</em></a></li>
<li><a href="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition/"><em>Building a Poker Bot: String and Number Recognition</em></a></li>
</ul>
<p>In this short post I write about the last step of the poker bot flow: clicking
the buttons. So, the screen is already recognized, the hand is understood,
the decisions are made and now the bot needs to execute the actions. Except for
the bet sizing, this simply means clicking the right button at the poker table.</p>
<p>The stealthiness of such clicks is a valid concern here. Ideally, we want all
the mouse movements to look as similar as possible to the movements produced
by a human being. For this post, I will simplify the task to the following steps:</p>
<ul>
<li>Identify where the mouse cursor is right now</li>
<li>Decide where the mouse should be moved to</li>
<li>Gradually move the mouse cursor</li>
<li>Click the button</li>
</ul>
<h2 id="cursor-position">Cursor Position</h2>
<p>It&#39;s really easy to understand where the mouse cursor currently is: just
use <code>Control.MousePosition</code> property from the standard library:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> currentPosition () = 
  <span class="hljs-keyword">let</span> mp = System.Windows.Forms.Control.MousePosition
  (mp.X, mp.Y)
</code></pre>
<p>Note that your application doesn&#39;t have to be based on WinForms, just reference
the required assembly.</p>
<h2 id="move-the-cursor">Move the Cursor</h2>
<p>I use the third party <a href="https://inputsimulator.codeplex.com/">WindowsInput</a> 
library to control the mouse and the keyboard programmatically. It uses some
weird coordinate system, so the function to move the mouse cursor looks like this:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> simulator = <span class="hljs-keyword">new</span> InputSimulator()

<span class="hljs-keyword">let</span> moveTo x y =
  <span class="hljs-keyword">let</span> toX = <span class="hljs-number">65535.</span> * x / (Screen.PrimaryScreen.Bounds.Width |&gt; float)
  <span class="hljs-keyword">let</span> toY = <span class="hljs-number">65535.</span> * y / (Screen.PrimaryScreen.Bounds.Height |&gt; float)
  simulator.Mouse.MoveMouseTo(toX, toY)
</code></pre>
<p>The input parameters <code>x</code> and <code>y</code> are the pixel location starting at 
the top-left corner of the screen.</p>
<h2 id="move-it-smoothly">Move It Smoothly</h2>
<p>Now we want to simulate the human-like movements. It won&#39;t be perfect, but
at least it should look decent. For this gradual movement function I used
a nice F# feature called asynchronous workflows. Effectively, it looks like
a loop with async sleep statements inside.</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> moveToWorkflow step (toX, toY) = async {
  <span class="hljs-keyword">let</span> (fromX, fromY) = currentPosition()
  <span class="hljs-keyword">let</span> count = Math.Max(<span class="hljs-number">10</span>, (Math.Abs (toX - fromX) + Math.Abs (toY - fromY)) / <span class="hljs-number">20</span>)
  <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> count <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> x = step fromX toX count i |&gt; float
    <span class="hljs-keyword">let</span> y = step fromY toY count i |&gt; float
    moveTo x y
    <span class="hljs-keyword">do</span>! Async.Sleep <span class="hljs-number">3</span>
  }
</code></pre>
<p>The key parameter here is the <code>step</code> function of obscure type <code>int -&gt; int -&gt; int -&gt; int -&gt; int</code>.
Basically, it calculates a coordinate for n-th step of the movement. We can
plug different implementations of this function to find the right balance of
the movement style. Here is the simplest linear implementation:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> linearStep from until max i =
  from + (until - from) * i / max
</code></pre>
<p>The sinus-based implementation is a bit more verbose because of float-int 
conversions:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> sinStep (from:int) (until:int) (max:int) (index:int) =
  <span class="hljs-keyword">let</span> fromf = from |&gt; float
  <span class="hljs-keyword">let</span> untilf = until |&gt; float
  <span class="hljs-keyword">let</span> maxf = max |&gt; float
  <span class="hljs-keyword">let</span> indexf = index |&gt; float
  fromf + (untilf - fromf) * Math.Sin(Math.PI / <span class="hljs-number">2.</span> * indexf / maxf) |&gt; int
</code></pre>
<p>The following animation illustrates the concept: </p>
<svg width="778" height="190" viewbox="0 0 500 190">
  <image id="mouse1" x="0" y="20" width="16" height="16" xlink:href="/2016/03/building-a-poker-bot-mouse-movements/mouse_cursor-16.png"></image>
  <image id="mouse2" x="0" y="90" width="16" height="16" xlink:href="/2016/03/building-a-poker-bot-mouse-movements/mouse_cursor-16.png"></image>
  <image id="mouse3" x="0" y="160" width="16" height="16" xlink:href="/2016/03/building-a-poker-bot-mouse-movements/mouse_cursor-16.png"></image>

  <animate xlink:href="#mouse1" attributename="x" from="0" to="0" values="0;450;0" keytimes="0;0.5;1" repeatcount="indefinite" dur="2s" begin="0s" fill="none" calcmode="discrete" id="img-anim1"></animate>
  <animate xlink:href="#mouse2" attributename="x" from="0" to="0" values="0;450;0" keytimes="0;0.5;1" repeatcount="indefinite" dur="2s" begin="0s" fill="none" id="img-anim2"></animate>
  <animate xlink:href="#mouse3" attributename="x" from="0" to="0" values="0;70;139;204;264;318;364;401;428;444;450;380;311;246;186;132;86;49;22;6;0" keytimes="0;0.05;0.1;0.15;0.2;0.25;0.3;0.35;0.4;0.45;0.5;0.55;0.6;0.65;0.7;0.75;0.8;0.85;0.9;0.95;1" repeatcount="indefinite" dur="2s" begin="0s" fill="none" id="img-anim3"></animate><br></svg>

<p>The top mouse cursor just
jumps from left to right and back (no animation). The middle cursor moves with
linear speed (<code>linearStep</code> function above). The bottom cursor moves based on
the <code>sinStep</code> function derived from sinus of time.</p>
<h2 id="click-the-button">Click the Button</h2>
<p>A button is a rectangle and we want to click a random point inside it. So, all
we need is to pick random coordinates, move the mouse there and send a 
click event via the simulator:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> clickButton (minX, minY, maxX, maxY) =
  <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> Random()
  <span class="hljs-keyword">let</span> p = (r.Next(minX, maxX), r.Next(minY, maxY))
  moveToWorkflow sinStep p |&gt; Async.RunSynchronously
  simulator.Mouse.LeftButtonClick()
</code></pre>
<h2 id="demo-time">Demo Time</h2>
<p>Here is the demo of the mouse movements:</p>
<p><img src="http://mikhail.io/2016/03/building-a-poker-bot-mouse-movements/mouseclicking.gif" alt="Mouse clicking the button"></p>
<p>It looks fun, doesn&#39;t it? The full code for the mouse movements can be found in 
<a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/Clicker.fs">my github repo</a>.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Unit testing Dapper repositories</title>
        <link href="http://mikhail.io/2016/02/unit-testing-dapper-repositories"/>
        <updated>2016-02-23T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-02-23,/2016/02/unit-testing-dapper-repositories</id>
        <content type="html"><![CDATA[<p><a href="https://github.com/StackExchange/dapper-dot-net">Dapper</a> is a micro-ORM library which is 
very simple and super fast. In our projects we use Dapper for the tasks where something like
EntityFramework or NHibernate would be an overkill.</p>
<p>Quite often the data access code is difficult to be unit tested. Objects like
database connections, commands, transactions and contexts are hard to mock, and
thus the data access code is not easily isolated. Dapper relies heavily on SQL
statements inside C# code, which gives an extra complication. Some people would
argue that unit tests are not warranted for data access layer, and integration
tests should be used instead. Let&#39;s have a look at another possibility.</p>
<h2 id="an-example-of-a-repository">An Example of a Repository</h2>
<p>Let&#39;s say we have a simple class and we want to populate instances of this class
from the database:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Description { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>To be able to use Dapper for data access, we need an instance of <code>IDbConnection</code>.
As we want to be able to mock the connection for unit tests, we need to create
a factory interface to abstract it away:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDatabaseConnectionFactory</span>
{
    <span class="hljs-function">IDbConnection <span class="hljs-title">GetConnection</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p>Now the repository would get a connection from this factory and execute 
Dapper queries on it:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductRepository</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IDatabaseConnectionFactory connectionFactory;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProductRepository</span><span class="hljs-params">(IDatabaseConnectionFactory connectionFactory)</span>
    </span>{
        <span class="hljs-keyword">this</span>.connectionFactory = connectionFactory;
    }

    <span class="hljs-keyword">public</span> Task&lt;IEnumerable&lt;Product&gt;&gt; GetAll()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.connectionFactory.GetConnection().QueryAsync&lt;Product&gt;(
            <span class="hljs-string">"select * from Product"</span>);
    }
}
</code></pre>
<h2 id="testing-without-a-real-database">Testing Without a real Database</h2>
<p>Here is my approach to testing the repository:</p>
<ol>
<li>Use an in-memory <a href="https://www.sqlite.org/">SQLite3</a> database.</li>
<li>Create a table there and put some data in.</li>
<li>Run the repository against this database.</li>
<li>Compare the result to the expected values.</li>
</ol>
<p>Here is a helper class which uses another micro-ORM library <a href="http://ormlite.com/">OrmLite</a> to talk
to SQLite database:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryDatabase</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> OrmLiteConnectionFactory dbFactory = 
        <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteOrmLiteDialectProvider.Instance);

    <span class="hljs-function"><span class="hljs-keyword">public</span> IDbConnection <span class="hljs-title">OpenConnection</span><span class="hljs-params">()</span> </span>=&gt; <span class="hljs-keyword">this</span>.dbFactory.OpenDbConnection();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Insert&lt;T&gt;(IEnumerable&lt;T&gt; items)
    {
        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = <span class="hljs-keyword">this</span>.OpenConnection())
        {
            db.CreateTableIfNotExists&lt;T&gt;();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> items)
            {
                db.Insert(item);
            }
        }
    }
}
</code></pre>
<p>And here is the test for our <code>ProductRepository</code> class:</p>
<pre class="highlight"><code class="hljs cs">[Test]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">QueryTest</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Arrange</span>
    <span class="hljs-keyword">var</span> products = <span class="hljs-keyword">new</span> List&lt;Product&gt;
    {
        <span class="hljs-keyword">new</span> Product { ... },
        <span class="hljs-keyword">new</span> Product { ... }
    };
    <span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> InMemoryDatabase();
    db.Insert(products);
    connectionFactoryMock.Setup(c =&gt; c.GetConnection()).Returns(db.OpenConnection());

    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">var</span> result = <span class="hljs-function"><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ProductRepository</span><span class="hljs-params">(connectionFactoryMock.Object)</span>.<span class="hljs-title">GetAll</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// Assert</span>
    result.ShouldBeEquivalentTo(products);
}
</code></pre>
<h2 id="is-it-a-unit-test-">Is It a Unit Test?</h2>
<p>Well, not completely. This approach does not mock the database, but instead puts
an in-memory database in place of the normal one. The problem is that we don&#39;t 
control all the details how it works, so it might not be as flexible as we need.
For instance, SQLite type system is quite simplistic, so while <code>INT</code> and <code>BIGINT</code>
are different column types in SQL Server, they are the same <code>INTEGER</code> type in
SQLite. This can lead to false positive or false negative tests in edge cases.</p>
<p>Nevertheless, the concept is simple and requires very little amount of code,
so it&#39;s useful to have it in the toolbox anyway. The resulting tests are fast,
have no external dependencies and are always consistent between multiple runs.
That makes them better than real integration tests for the simple scenarios 
during TDD development.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Building a Poker Bot: String and Number Recognition</title>
        <link href="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition"/>
        <updated>2016-02-10T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-02-10,/2016/02/building-a-poker-bot-string-recognition</id>
        <content type="html"><![CDATA[<p><em>This is the second part of <strong>Building a Poker Bot</strong> series where I describe my experience developing bot software 
to play in online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable. Here is the first part:
<a href="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">Building a Poker Bot: Card Recognition</a>
</em></p>
<h2 id="why-string-recognition">Why string recognition</h2>
<p>Reading cards and other fixed images was the first step. The bot should also
be able to read different text-based information from the screen, e.g.</p>
<ul>
<li>Current blind levels</li>
<li>Current pot size</li>
<li>The size of bets made by each player</li>
<li>Player names</li>
<li>Stack sizes</li>
<li>Chat messages (for advanced scenarios)</li>
</ul>
<p>We need this vital information to make proper decisions, so let&#39;s look at
how to parse the textual data.</p>
<h2 id="new-challenges">New challenges</h2>
<p>String recognition has some specific difficulties when compared to fixed
images like cards:</p>
<ul>
<li>The size of a string is not predefined. Obviously, the longer the string, the
more space it takes on the screen</li>
<li>The position of a string is not fixed either. Some strings are aligned to
the center, others may diverge based on other variable parts like stakes or blinds</li>
<li>Different strings might be rendered in different font size</li>
</ul>
<p>Here is what needs to be done to overcome these complications:</p>
<ul>
<li>Pick the layout which makes your life easier </li>
<li>Adjust fonts and positions if possible </li>
<li>Make sure that all important strings are always visible and not overlapping to other information</li>
<li>For each string define a region where it belongs to in 100% cases. The background
of this region should be more or less evenly filled with a color in contrast to the font color.</li>
</ul>
<h2 id="string-recognition-steps">String recognition steps</h2>
<p>We start with a screenshot of a poker table again:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition/table.png" alt="Poker table screenshot"></p>
<p>We know our fixed regions where our labels are located, so we take those
regions for processing:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition/regions.png" alt="Regions of string recognition"></p>
<p>For each region we trim away the blank margins around the text (i.e. left,
top, right and bottom padding):</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition/nomargin.png" alt="Margins being removed"></p>
<p>We find dark lines between bright symbols and we consider them as gaps
between characters:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-string-recognition/splitchars.png" alt="Split to characters"></p>
<p>The final step is to compare each symbol to the known patterns and find the best
match (in case of my layout the match for symbols is always 100% perfect). Let&#39;s 
look how these steps are implemented.</p>
<h2 id="removing-padding-around-the-text">Removing padding around the text</h2>
<p>Because the padding is removed from all 4 sides of the region, I decided to use
<code>Array2D</code> data type to be able to iterate in different order. The whole algorithm operates
with black or white points defined as a helper type:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">BW</span> </span>= B | W
</code></pre>
<p>So the <code>removePadding</code> function has type of <code>BW[,] -&gt; BW[,]</code> and looks
like this:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> removePadding pixels =
  <span class="hljs-keyword">let</span> allBlack s = Seq.exists ((=) W) s
  <span class="hljs-keyword">let</span> maxWidth = Array2D.length1 pixels - <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> maxHeight = Array2D.length2 pixels - <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> firstX = [<span class="hljs-number">0.</span>.maxWidth] 
    |&gt; Seq.tryFindIndex (<span class="hljs-keyword">fun</span> y -&gt; allBlack pixels.[y, <span class="hljs-number">0.</span>.maxHeight])
  <span class="hljs-keyword">let</span> lastX = [<span class="hljs-number">0.</span>.maxWidth] 
    |&gt; Seq.tryFindIndexBack (<span class="hljs-keyword">fun</span> y -&gt; allBlack pixels.[y, <span class="hljs-number">0.</span>.maxHeight])
  <span class="hljs-keyword">let</span> firstY = [<span class="hljs-number">0.</span>.maxHeight] 
    |&gt; Seq.tryFindIndex (<span class="hljs-keyword">fun</span> x -&gt; allBlack pixels.[<span class="hljs-number">0.</span>.maxWidth, x])
  <span class="hljs-keyword">let</span> lastY = [<span class="hljs-number">0.</span>.maxHeight] 
    |&gt; Seq.tryFindIndexBack (<span class="hljs-keyword">fun</span> x -&gt; allBlack pixels.[<span class="hljs-number">0.</span>.maxWidth, x])

  <span class="hljs-keyword">match</span> (firstX, lastX, firstY, lastY) <span class="hljs-keyword">with</span>
  | (Some fx, Some lx, Some fy, Some ly) -&gt; pixels.[fx..lx, fy..ly]
  | _ -&gt; Array2D.init <span class="hljs-number">0</span> <span class="hljs-number">0</span> (<span class="hljs-keyword">fun</span> _ _ -&gt; B)
</code></pre>
<p>The first part finds the amount of fully-black columns and rows in the array.
Then, if white points are found, the second part returns a sub array based on
the indices, otherwise empty array is returned.</p>
<h2 id="split-the-text-into-characters">Split the text into characters</h2>
<p>First, we convert our 2D array into the list of lists, where each item in the
top-level list represents a single column of pixels:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> pixelColumns =
  [<span class="hljs-number">0.</span>.Array2D.length1 pixels - <span class="hljs-number">1</span>] 
  |&gt; Seq.map (<span class="hljs-keyword">fun</span> x -&gt; pixels.[x, <span class="hljs-number">0.</span>.Array2D.length2 pixels - <span class="hljs-number">1</span>] |&gt; List.ofArray)
</code></pre>
<p>Then we can fold this list of columns into the symbols, where each symbol itself
is the list of columns:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> splitIntoSymbols (e : BW list) (state: BW list list list) = 
  <span class="hljs-keyword">match</span> state <span class="hljs-keyword">with</span>
  | cur::rest -&gt;
      <span class="hljs-keyword">if</span> isSeparator e <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">match</span> cur <span class="hljs-keyword">with</span>
        | _::_ -&gt; []::state <span class="hljs-comment">// add new list</span>
        | _ -&gt; state        <span class="hljs-comment">// skip if we already have empty item</span>
      <span class="hljs-keyword">else</span> (e::cur)::rest   <span class="hljs-comment">// add e to current list</span>
  | _ -&gt; [[e]]

Seq.foldBack splitIntoSymbols pixelColumns []
</code></pre>
<p>The type of <code>state</code> is a bit of brain teaser, I guess it could be improved
by introducing some intermediate type with descriptive name, but I decided
to leave that part for now. Read it as list of symbols, which are lists of
columns, which are lists of pixels.</p>
<h2 id="match-the-symbols-vs-the-known-patterns">Match the symbols vs the known patterns</h2>
<p>This part was already described in <a href="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">my first article</a>.
Basically we compare the list of black or white points to the patterns of
the known symbols:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> getChar patterns bws =
  <span class="hljs-keyword">let</span> samePatterns h p =
    Seq.zip h p
    |&gt; Seq.forall (<span class="hljs-keyword">fun</span> (v1, v2) -&gt; v1 = v2)
  <span class="hljs-keyword">let</span> matchingPattern = 
    patterns 
      |&gt; Array.filter (<span class="hljs-keyword">fun</span> p -&gt; List.length p.Pattern = List.length bws)
      |&gt; Array.filter (<span class="hljs-keyword">fun</span> p -&gt; samePatterns bws p.Pattern)
      |&gt; Array.tryHead
  defaultArg (Option.map (<span class="hljs-keyword">fun</span> p -&gt; p.Char) matchingPattern) '?'
</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The <code>recognizeString</code> function accepts lower-order functions to match 
symbols and get pixels together with width and height of the region:</p>
<pre class="highlight"><code class="hljs fs">recognizeString: (BW list list -&gt; char) -&gt; (int -&gt; int -&gt; color) -&gt; int -&gt; int -&gt; string
</code></pre>
<p>It builds an array of pixels, removes padding and folds with recognition.</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> recognizeString matchSymbol getPixel width height =

  <span class="hljs-keyword">let</span> pixels = 
    Array2D.init width height (<span class="hljs-keyword">fun</span> x y -&gt; isWhite (getPixel x y))
    |&gt; removePadding

  <span class="hljs-keyword">let</span> pixelColumns =
    [<span class="hljs-number">0.</span>.Array2D.length1 pixels - <span class="hljs-number">1</span>] 
    |&gt; Seq.map (<span class="hljs-keyword">fun</span> x -&gt; pixels.[x, <span class="hljs-number">0.</span>.Array2D.length2 pixels - <span class="hljs-number">1</span>] |&gt; List.ofArray)      

  Seq.foldBack splitIntoSymbols pixelColumns []
  |&gt; List.map matchSymbol
  |&gt; Array.ofSeq
  |&gt; String.Concat
</code></pre>
<p>Then we use it with a specific recognition patterns, e.g. known digits in case
of numbers recognition:</p>
<pre class="highlight"><code class="hljs fs"><span class="hljs-keyword">let</span> recognizeNumber x =
  recognizeString (getChar numberPatterns) x
</code></pre>
<p>A way to produce these patterns is discussed in <a href="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">the previous part</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>String recognition takes a bit more steps to execute comparing to the recognition
of fixed objects. Nevertheless it&#39;s pretty straightforward to implement once
we split it into small and well-understood conversion steps. The full code 
for card recognition can be found in <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/StringRecognition.fs">my github repo</a>.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Akka.NET-style actors in Service Fabric</title>
        <link href="http://mikhail.io/2016/02/akka-net-style-actors-in-service-fabric"/>
        <updated>2016-02-08T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-02-08,/2016/02/akka-net-style-actors-in-service-fabric</id>
        <content type="html"><![CDATA[<p>Akka.NET and Service Fabric are the two actor frameworks that emerged in .NET world in the last year.
The two implementations of actor models are quite different. These differences are multi-faceted but
today I want to focus on API to define an actor and to communicate to it.</p>
<h2 id="service-fabric-actors">Service Fabric Actors</h2>
<p>Every actor in Service Fabric has a public interface which describes its behaviour. For this article
I&#39;m going to use a toy example based on weather reports. Our actor will be able to get whether reports
and then return the maximum temperature for a given period. An instance of actor will be created
for each city (geo partitioning). Here is our interface in Service Fabric:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWeatherActor</span> : <span class="hljs-title">IActor</span>
{
    <span class="hljs-function">Task <span class="hljs-title">AddWeatherReport</span><span class="hljs-params">(WeatherReport report)</span></span>;

    Task&lt;<span class="hljs-keyword">int</span>?&gt; GetMaxTemperature(Period period);
}
</code></pre>
<p>We have two operations: a command and a query. They are both async (return <code>Task</code>). The data classes
are required to be mutable DTOs based on <code>DataContract</code>:</p>
<pre class="highlight"><code class="hljs cs">[DataContract]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherReport</span>
{
    [DataMember]
    <span class="hljs-keyword">public</span> DateTime Moment { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [DataMember]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Temperature { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [DataMember]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Humidity { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[DataContract]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span>
{
    [DataMember]
    <span class="hljs-keyword">public</span> DateTime From { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [DataMember]
    <span class="hljs-keyword">public</span> DateTime Until { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>And here is the implementation of the weather actor:</p>
<pre class="highlight"><code class="hljs undefined">internal class WeatherActor : StatefulActor&lt;List&lt;WeatherReport&gt;&gt;, IWeatherActor
{
    public Task AddWeatherReport(WeatherReport report)
    {
        this.State = this.State ?? new List&lt;WeatherReport&gt;();
        this.State.Add(report);
        return Task.FromResult(0);
    }

    public Task&lt;int?&gt; GetMaxTemperature(Period period)
    {
        return Task.FromResult(
            (this.State ?? Enumerable.Empty&lt;WeatherReport&gt;())
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (int?)r.Temperature));
    }
}
</code></pre>
<p>Service Fabric provides reliable storage out of the box, so we are using it to
store our reports. There&#39;s no code required to instantiate an actor. Here is the
code to use it:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-comment">// Submit a new report</span>
IWeatherActor actor = ActorProxy.Create&lt;IWeatherActor&gt;(<span class="hljs-keyword">new</span> ActorId(<span class="hljs-string">"Amsterdam"</span>));
actor.AddWeatherReport(
    <span class="hljs-keyword">new</span> WeatherReport { Moment = DateTime.Now, Temperature = <span class="hljs-number">22</span>, Humidity = <span class="hljs-number">55</span> });

<span class="hljs-comment">// Make a query somewhere else</span>
IWeatherActor actor = ActorProxy.Create&lt;IWeatherActor&gt;(<span class="hljs-keyword">new</span> ActorId(<span class="hljs-string">"Amsterdam"</span>));
<span class="hljs-keyword">var</span> result = actor.GetMaxTemperature(<span class="hljs-keyword">new</span> Period { From = monthAgo, Until = now });
</code></pre>
<h2 id="akka-net-actors">Akka.NET Actors</h2>
<p>Actors in Akka.NET are message-based. The messages are immutable POCOs, which 
is a great design decision. Here are the messages for our scenario:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherReport</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherReport</span><span class="hljs-params">(DateTime moment, <span class="hljs-keyword">int</span> temperature, <span class="hljs-keyword">int</span> humidity)</span>
    </span>{
        <span class="hljs-keyword">this</span>.Moment = moment;
        <span class="hljs-keyword">this</span>.Temperature = temperature;
        <span class="hljs-keyword">this</span>.Humidity = humidity;
    }

    <span class="hljs-keyword">public</span> DateTime Moment { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Temperature { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Humidity { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Period</span><span class="hljs-params">(DateTime <span class="hljs-keyword">from</span>, DateTime until)</span>
    </span>{
        <span class="hljs-keyword">this</span>.From = <span class="hljs-keyword">from</span>;
        <span class="hljs-keyword">this</span>.Until = until;
    }

    <span class="hljs-keyword">public</span> DateTime From { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> DateTime Until { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<p>There&#39;s no need to define any interfaces. The basic actor implementation derives from
<code>ReceiveActor</code> and calls <code>Receive</code> generic method to setup a callback which is called
when a message of specified type is received:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherActor</span> : <span class="hljs-title">ReceiveActor</span>
{
    <span class="hljs-keyword">private</span> List&lt;WeatherReport&gt; state = <span class="hljs-keyword">new</span> List&lt;WeatherReport&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherActor</span><span class="hljs-params">()</span>
    </span>{
        Receive&lt;WeatherReport&gt;(<span class="hljs-keyword">this</span>.AddWeatherReport);
        Receive&lt;Period&gt;(<span class="hljs-keyword">this</span>.GetMaxTemperature);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddWeatherReport</span><span class="hljs-params">(WeatherReport report)</span>
    </span>{
        <span class="hljs-keyword">this</span>.state.Add(report);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetMaxTemperature</span><span class="hljs-params">(Period period)</span>
    </span>{
        <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>.state
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (<span class="hljs-keyword">int</span>?)r.Temperature);
        Sender.Tell(response, Self);
    }
}
</code></pre>
<p>Note a couple more differences in this implementation comparing to Fabric style:</p>
<ul>
<li><p>State is stored in a normal class field and is not persistent or replicated
by default. This can be solved by Akka.NET Persistence, which would save all
messages (and potentially snapshots) to the external database. Still, it won&#39;t
be the same level of convenience as in-built Service Fabric statefullness.</p>
</li>
<li><p><code>GetMaxTemperature</code> method does not return anything, because nobody would look
at the returned value. Instead, it sends yet another message to the sender actor.
So, <code>Request-Response</code> workflow is supported but is a bit less convenient and
explicit.</p>
</li>
</ul>
<p>Let&#39;s have a look at the client code. <code>ActorSelection</code> is the closest notion to
Fabric&#39;s <code>ActorProxy</code>: it does not create an actor, but just gets an endpoint
based on the name. Note that Akka.NET actor needs to be explicitly created by
another actor, but lifetime management is a separate discussion, so we&#39;ll skip 
it for now. Here is the report sender:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-comment">// Submit a new report</span>
<span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> WeatherReport { Moment = DateTime.Now, Temperature = <span class="hljs-number">22</span>, Humidity = <span class="hljs-number">55</span> };
Context.ActorSelection(<span class="hljs-string">"/user/weather/Amsterdam"</span>).Tell(msg);
</code></pre>
<p>Asking <code>ActorSelection</code> is not directly possible, we would need to setup an
inbox and receive callback messages. We&#39;ll pretend that we have an <code>ActorRef</code>
for the sake of simplicity:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-comment">// Make a query somewhere else</span>
ActoRef actor = ... ; <span class="hljs-comment">// we have it</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> actor.Ask(<span class="hljs-keyword">new</span> Period { From = monthAgo, Until = now });
</code></pre>
<h2 id="the-best-of-two-worlds">The Best of Two Worlds</h2>
<p>Now my goals is to come up with an implementation of Service Fabric actors with
the properties that combine the good parts of both frameworks (without explicitly
using Akka.NET), i.e.</p>
<ul>
<li>Use the full power of Service Fabric actors, including lifetime management,
cluster management and reliable state</li>
<li>Use the simplicity of Request-Response pattern implementation of Service Fabric</li>
<li>Support immutable POCO messages instead of <code>DataContract</code> DTOs</li>
<li>Use <code>ReceiveActor</code>-like API for message processing</li>
</ul>
<p>Here is the third implementation of our Weather Actor (the definitions of messages
from Akka.NET example are intact):</p>
<pre class="highlight"><code class="hljs undefined">[ActorService(Name = "WeatherActor")]
public class WeatherActor : StetefulReceiveActor&lt;List&lt;WeatherReport&gt;&gt;
{
    public WeatherActor()
    {
        Receive&lt;WeatherReport&gt;(this.AddWeatherReport);
        Receive&lt;Period, int&gt;(this.GetMaxTemperature);
    }

    public Task&lt;List&lt;WeatherReport&gt;&gt; AddWeatherReport(
        List&lt;WeatherReport&gt; state, WeatherReport report)
    {
        state = state ?? new List&lt;WeatherReport&gt;();
        state.Add(report);
        return Task.FromResult(state);
    }

    public Task&lt;int?&gt; GetMaxTemperature(List&lt;WeatherReport&gt; state, Period period)
    {
        return Task.FromResult(
            (state ?? Enumerable.Empty&lt;WeatherReport&gt;())
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (int?)r.Temperature));
    }
}
</code></pre>
<p>The base <code>ReceiveActor</code> class is not defined yet, we&#39;ll do it in the next section. Here is
how it&#39;s being used:</p>
<ul>
<li>The base class is generic and it accepts the type of the state (similar to normal Fabric actors)</li>
<li>Constructor registers two <code>Receive</code> handlers: message handler and request handler. Note
that the later one accepts two type parameters: request type and response type</li>
<li>Both handlers get the current state as the first argument instead of pulling it from the property of
the base class</li>
<li>The both return <code>Task</code>&#39;ed data. Message handler is allowed to change the state, while
request handler does  not change the state but just returns the response back</li>
<li><code>ServiceName</code> attribute is required because there are (may be) multiple classes implementing
the same interface</li>
</ul>
<p>The client code uses our own <code>MessageActorProxy</code> class to create non-generic proxies which
are capable to <code>Tell</code> (send a message one way) and <code>Ask</code> (do request and wait for response):</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-comment">// Submit a new report</span>
<span class="hljs-keyword">var</span> actor = MessageActorProxy.Create(<span class="hljs-keyword">new</span> ActorId(<span class="hljs-string">"Amsterdam"</span>), <span class="hljs-string">"WeatherActor"</span>);
actor.Tell(<span class="hljs-keyword">new</span> WeatherReport { Moment = DateTime.Now, Temperature = <span class="hljs-number">22</span>, Humidity = <span class="hljs-number">55</span> });

<span class="hljs-comment">// Make a query somewhere else</span>
<span class="hljs-keyword">var</span> actor = MessageActorProxy.Create(<span class="hljs-keyword">new</span> ActorId(<span class="hljs-string">"Amsterdam"</span>), <span class="hljs-string">"WeatherActor"</span>);
<span class="hljs-keyword">var</span> result = actor.Ask(<span class="hljs-keyword">new</span> Period { From = monthAgo, Until = now });
</code></pre>
<h2 id="implementation-of-receiveactor">Implementation of ReceiveActor</h2>
<p>Let&#39;s start with the interface definition:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IReceiveActor</span> : <span class="hljs-title">IActor</span>
{
    <span class="hljs-function">Task <span class="hljs-title">Tell</span><span class="hljs-params">(<span class="hljs-keyword">string</span> typeName, <span class="hljs-keyword">byte</span>[] message)</span></span>;

    [Readonly]
    Task&lt;<span class="hljs-keyword">byte</span>[]&gt; Ask(<span class="hljs-keyword">string</span> typeName, <span class="hljs-keyword">byte</span>[] message);
}
</code></pre>
<p>The two methods for <code>Tell</code> and <code>Ask</code> accept serializes data together with fully qualified
type name. This will allow passing any kind of objects which can be handled by a serializer
of choice (I used Newtonsoft JSON serializer).</p>
<p>Actor implementation derives from <code>StatefulActor</code> and uses another type/bytes pair to store
the serialized state:</p>
<pre class="highlight"><code class="hljs undefined">    public abstract class StatefulReceiveActor : StatefulActor&lt;StateContainer&gt;, 
                                                 IReceiveActor
    {
        // ...
    }

    [DataContract]
    public class StateContainer
    {
        [DataMember]
        public string TypeName { get; set; }

        [DataMember]
        public byte[] Data { get; set; }
    }
</code></pre>
<p>The simplistic implementation of <code>Receive</code> generic methods uses two dictionaries
to store the handlers:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">private</span> Dictionary&lt;Type, Func&lt;<span class="hljs-keyword">object</span>, <span class="hljs-keyword">object</span>, Task&lt;<span class="hljs-keyword">object</span>&gt;&gt;&gt; handlers;
<span class="hljs-keyword">private</span> Dictionary&lt;Type, Func&lt;<span class="hljs-keyword">object</span>, <span class="hljs-keyword">object</span>, Task&lt;<span class="hljs-keyword">object</span>&gt;&gt;&gt; askers;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReceiveActor</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">this</span>.handlers = <span class="hljs-keyword">new</span> Dictionary&lt;Type, Func&lt;<span class="hljs-keyword">object</span>, <span class="hljs-keyword">object</span>, Task&lt;<span class="hljs-keyword">object</span>&gt;&gt;&gt;();
    <span class="hljs-keyword">this</span>.askers = <span class="hljs-keyword">new</span> Dictionary&lt;Type, Func&lt;<span class="hljs-keyword">object</span>, <span class="hljs-keyword">object</span>, Task&lt;<span class="hljs-keyword">object</span>&gt;&gt;&gt;();
}

<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> Receive&lt;T&gt;(Func&lt;<span class="hljs-keyword">object</span>, T, Task&lt;<span class="hljs-keyword">object</span>&gt;&gt; handler)
    =&gt; <span class="hljs-keyword">this</span>.handlers.Add(<span class="hljs-keyword">typeof</span>(T), <span class="hljs-keyword">async</span> (s, m) =&gt; <span class="hljs-function"><span class="hljs-keyword">await</span> <span class="hljs-title">handler</span><span class="hljs-params">(s, (T)</span>m))</span>;

<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> Receive&lt;TI, TO&gt;(Func&lt;<span class="hljs-keyword">object</span>, TI, Task&lt;TO&gt;&gt; asker)
    =&gt; <span class="hljs-keyword">this</span>.askers.Add(<span class="hljs-keyword">typeof</span>(TI), <span class="hljs-keyword">async</span> (s, m) =&gt; <span class="hljs-function"><span class="hljs-keyword">await</span> <span class="hljs-title">asker</span><span class="hljs-params">(s, (TI)</span>m))</span>;
</code></pre>
<p>The <code>Tell</code> method deserializes the message and state, then picks a handler based on
the message type, executes it and serializes the produced state back:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Tell</span><span class="hljs-params">(<span class="hljs-keyword">string</span> typeName, <span class="hljs-keyword">byte</span>[] message)</span>
</span>{
    <span class="hljs-keyword">var</span> type = Type.GetType(typeName);
    <span class="hljs-keyword">var</span> typedMessage = <span class="hljs-keyword">this</span>.serializer.Deserialize(message, type);

    <span class="hljs-keyword">var</span> typedState = <span class="hljs-keyword">this</span>.State != <span class="hljs-keyword">null</span>
        ? <span class="hljs-keyword">this</span>.serializer.Deserialize(<span class="hljs-keyword">this</span>.State.Data, Type.GetType(<span class="hljs-keyword">this</span>.State.TypeName))
        : <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">this</span>.handlers.FirstOrDefault(t =&gt; t.Key.IsAssignableFrom(type)).Value;
    <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>)
    {
        <span class="hljs-keyword">var</span> newState = <span class="hljs-function"><span class="hljs-keyword">await</span> <span class="hljs-title">handler</span><span class="hljs-params">(typedState, typedMessage)</span></span>;
        <span class="hljs-keyword">this</span>.State =
            newState != <span class="hljs-keyword">null</span>
            ? <span class="hljs-keyword">new</span> StateContainer 
              { 
                  Data = <span class="hljs-keyword">this</span>.serializer.Serialize(newState), 
                  TypeName = newState.GetType().AssemblyQualifiedName 
              }
            : <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
<p>The implementation of <code>Ask</code> is almost identical, so I&#39;ll skip it. <code>MessageActorProxy</code> 
encapsulates the serialization around passing data to normal <code>ActorProxy</code> class:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageActorProxy</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IStatefulMessageActor proxy;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ISerializer serializer = <span class="hljs-keyword">new</span> JsonByteSerializer();

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MessageActorProxy</span><span class="hljs-params">(ActorId actorId, <span class="hljs-keyword">string</span> serviceName)</span>
    </span>{
        <span class="hljs-keyword">this</span>.proxy = ActorProxy.Create&lt;IReceiveActor&gt;(actorId, serviceName: serviceName);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Tell</span><span class="hljs-params">(<span class="hljs-keyword">object</span> message)</span>
    </span>{
        <span class="hljs-keyword">var</span> serialized = <span class="hljs-keyword">this</span>.serializer.Serialize(message);
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.proxy.Send(message.GetType().AssemblyQualifiedName, serialized);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;T&gt; Ask&lt;T&gt;(<span class="hljs-keyword">object</span> message)
    {
        <span class="hljs-keyword">var</span> serialized = <span class="hljs-keyword">this</span>.serializer.Serialize(message);
        <span class="hljs-keyword">var</span> fullName = message.GetType().AssemblyQualifiedName;
        <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.proxy.Ask(fullName, serialized);
        <span class="hljs-keyword">return</span> (T)<span class="hljs-keyword">this</span>.serializer.Deserialize(response, <span class="hljs-keyword">typeof</span>(T));
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MessageActorProxy <span class="hljs-title">Create</span><span class="hljs-params">(ActorId actorId, <span class="hljs-keyword">string</span> serviceType)</span>
    </span>{
        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MessageActorProxy</span><span class="hljs-params">(actorId, serviceType)</span></span>;
    }
}
</code></pre>
<p>Let&#39;s briefly wrap it up.</p>
<h2 id="conclusion">Conclusion</h2>
<p>At this stage Azure Service Fabric lacks support of some actor model best practices
like message-based API and immutable POCO classes. At the same time, it provides
super powerful setup regarding cluster resource management, state replication, fault
tolerance and reliable communication. We can borrow some approaches that are used in Akka.NET
framework to improve the developer experience who wants to leverage the power
of Service Fabric.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Building a Poker Bot: Card Recognition</title>
        <link href="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition"/>
        <updated>2016-02-01T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-02-01,/2016/02/building-a-poker-bot-card-recognition</id>
        <content type="html"><![CDATA[<p><em>This is the first part of <strong>Building a Poker Bot</strong> series where I describe my experience developing bot software 
for online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable.</em></p>
<h2 id="screen-recognition">Screen recognition</h2>
<p>For a human, the very first step to the ability to play poker is to understand the cards, what a hand is and 
what the value of your hand is. E.g. in Texas Holdem each player gets 2 hole cards which form a hand. At 
the showdown the player with the best hand wins.</p>
<p>Poker bots are no different, they also need to be taught the notion of cards and hands. A bot should &quot;watch&quot; 
the table and see which cards he is dealt with. There are several ways to achieve that but I go for a technique
called screen recognition, i.e. the bot makes a screenshot of a table and then reads the pixels to understand
what&#39;s going on. Very similar to what people do.</p>
<p>Image recognition in general is a tough task. Human beings are very good at interpreting vague images and
recognizing familiar objects. It&#39;s much more difficult for computers. General image recognition (think showing
a photo to your computer and asking whether there is an animal there) is very tough; corporations like Google
and Microsoft are spending numerous man-years and employ techniques like machine learning and neural networks.</p>
<p>Fortunately, poker table recognition is much easier. The images to be recognized are machine-generated, so
the same things are rendered more or less the same way all the time. It makes sense to keep the poker table
size fixed to some predefined value which makes recognition task fairly easy.</p>
<h2 id="card-recognition-steps">Card recognition steps</h2>
<p>There are 13 card faces (from Deuce to Ace) and 4 suits. All of them are just fixed-size images which we need to be able to
match with. So we start with a screenshot of a poker table:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/table.png" alt="Poker table screenshot"></p>
<p>The table size is fixed, so are the left and the top pixel positions of hole cards. So, our first step is to extract
the small images of cards out of the big screenshot:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/cards.png" alt="Extracted card images"></p>
<p>Now, we can take the recognition of card faces and suits separately. In our sample layout, suits are color coded.
This is very friendly to humans and super simple for the bot. We pick the suit based on the color (ignoring 
the white pixels):</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/suits.png" alt="Recognized suits"></p>
<p>This leaves us with the task of choosing between 13 card faces. The color information is not important
here, we can make the image grey-scale. Moreover, we can reduce the color information to the single bit per 
pixel - call it white or black:</p>
<p><img src="http://mikhail.io/2016/02/building-a-poker-bot-card-recognition/blackandwhite.png" alt="Black and white pixels"></p>
<p>Now this mask is very simple, and we can compare it with 13 predefined masks for 13 cards pixel by pixel.
The one with the biggest amount of matches wins.</p>
<h2 id="suit-recognition">Suit recognition</h2>
<p>Let&#39;s put some code at the table. We start with suit recognition. <code>getSuit</code> function has type 
<code>Color -&gt; string option</code> and converts the color of a pixel into the suit name, if possible. Hearts (&quot;h&quot;)
are red, Diamonds (&quot;d&quot;) are blue, Clubs (&quot;c&quot;) are green and Spades (&quot;s&quot;) are black:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> getSuit (c : Color) =
  <span class="hljs-keyword">match</span> c <span class="hljs-keyword">with</span>
  | _ <span class="hljs-keyword">when</span> c.B &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.G &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.R &gt; <span class="hljs-number">127</span>uy -&gt; Some <span class="hljs-string">"h"</span>
  | _ <span class="hljs-keyword">when</span> c.B &gt; <span class="hljs-number">127</span>uy &amp;&amp; c.G &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.R &lt; <span class="hljs-number">127</span>uy -&gt; Some <span class="hljs-string">"d"</span>
  | _ <span class="hljs-keyword">when</span> c.B &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.G &gt; <span class="hljs-number">127</span>uy &amp;&amp; c.R &lt; <span class="hljs-number">127</span>uy -&gt; Some <span class="hljs-string">"c"</span>
  | _ <span class="hljs-keyword">when</span> c.B &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.G &lt; <span class="hljs-number">127</span>uy &amp;&amp; c.R &lt; <span class="hljs-number">127</span>uy -&gt; Some <span class="hljs-string">"s"</span>
  | _ -&gt; None
</code></pre>
<p>This function is used by <code>getCardSuit</code> function of type <code>(int -&gt; int -&gt; Color) -&gt; int -&gt; int -&gt; string</code>.
Its first argument is a function which returns the color of a pixel based on <code>(x, y)</code>
relative coordinates (starting with 0). The next two arguments are width and height of the cards. Result is
the same suit name that we described above. The function loops through all the pixels, gets a suit per
pixel and then returns the suit which is the most popular among them. Alternatively, we could just return
the first suit found, but my implementation looks more resilient:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> getCardSuit getPixel width height =    
  seq { <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. width - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. height - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
            <span class="hljs-keyword">yield</span> getSuit (getPixel x y) }
  |&gt; Seq.choose id
  |&gt; Seq.countBy id
  |&gt; Seq.maxBy (<span class="hljs-keyword">fun</span> (v, c) -&gt; c)
  |&gt; fst
</code></pre>
<h2 id="producing-the-black-white-pattern">Producing the black &amp; white pattern</h2>
<p><code>getCardPattern</code> accepts the same parameters as <code>getSuits</code> but returns <code>seq&lt;BW&gt;</code> instead. This is
a sequence of black or white pixels with a helper union type:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">BW</span> </span>= B | W
</code></pre>
<p>The function body enumerates the pixels and return black or white result as a flat sequence:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> getCardPattern getPixel width height =
  <span class="hljs-keyword">let</span> isWhite (c : Color) =
    <span class="hljs-keyword">if</span> c.B &gt; <span class="hljs-number">127</span>uy &amp;&amp; c.G &gt; <span class="hljs-number">127</span>uy &amp;&amp; c.R &gt; <span class="hljs-number">127</span>uy <span class="hljs-keyword">then</span> W
    <span class="hljs-keyword">else</span> B

  seq { <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. width - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. height - <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
            <span class="hljs-keyword">yield</span> isWhite (getPixel x y) }
</code></pre>
<h2 id="card-face-recognition">Card face recognition</h2>
<p>Having a black and white pattern, we can compare it with the predefined patterns and pick the
most similar one. A pattern is defined with a helper type</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">CardPattern</span> </span>= {
  Card: string
  Pattern: BW array
}
</code></pre>
<p><code>Pattern</code> is a sequence which is equivalent to the sequence we got on the previous step. 
<code>Card</code> is a string of hand face value 2, 3, 4 .. A. <code>getCardFace</code> has the type 
<code>CardPattern[] -&gt; seq&lt;BW&gt; -&gt; string</code>, it accepts an array of known patterns and a pattern
of the card to be recognized. It compares patterns pixel by pixel and returns the card
which has the biggest amount of matches:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> getCardFace patterns bws =
  <span class="hljs-keyword">let</span> matchCount h p =
    Seq.zip h p
    |&gt; Seq.map (<span class="hljs-keyword">fun</span> (v1, v2) -&gt; <span class="hljs-keyword">if</span> v1 = v2 <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)
    |&gt; Seq.sum
    |&gt; decimal
  <span class="hljs-keyword">let</span> maxPattern = patterns |&gt; Array.maxBy (<span class="hljs-keyword">fun</span> p -&gt; matchCount bws p.Pattern)
  maxPattern.Card
</code></pre>
<h2 id="getting-the-known-patterns">Getting the known patterns</h2>
<p>So how do we create an array of known patterns? It&#39;s tedious to do manually, so
we use a bit of code generation.
Basically we just take several screenshots of poker tables and feed them to the following 
helper function:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> parsePattern getPixel width height =
  getCardPattern getPixel width height
  |&gt; Seq.map (<span class="hljs-keyword">fun</span> x -&gt; <span class="hljs-keyword">if</span> x = B <span class="hljs-keyword">then</span> <span class="hljs-string">"B"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"W"</span>) 
  |&gt; String.concat <span class="hljs-string">";"</span>
</code></pre>
<p>The function creates a string which can be copy-pasted into F# array of <code>BW</code>.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Here is the facade function that will be called from the outside:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> recognizeCard getPixel width height = 
  <span class="hljs-keyword">let</span> value = 
    getCardPattern getPixel width height 
    |&gt; getCardValue patterns
  <span class="hljs-keyword">let</span> suit = getCardSuit getPixel width height
  value + suit
</code></pre>
<p>The calling code looks like this:</p>
<pre class="highlight"><code class="hljs fsharp"><span class="hljs-keyword">let</span> image = <span class="hljs-keyword">new</span> Bitmap(<span class="hljs-string">"..."</span>);

<span class="hljs-keyword">let</span> getPixel offsetX offsetY x y = 
  image.GetPixel(offsetX + x, offsetY + y)

<span class="hljs-keyword">let</span> hand = (recognizeCard (getPixel leftX top) width height) + (recognizeCard (getPixel rightX top) width height)
</code></pre>
<p><code>leftX</code>, <code>rightX</code>, <code>top</code>, <code>width</code> and <code>height</code> are well-known parameters of cards locations within a screenshot, 
which are hard coded for a given table size.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The full code for card recognition can be found in my <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/HandRecognition.fs">github repo</a>. It&#39;s just 75 lines of code which is
much less that one could imagine for a task of image recognition. Similar code could be used to recognize other
fixed objects at poker table: dealer button location, action buttons, checkboxes etc. In the next part of this
series I will show how to recognize non-fixed parts: text and numbers.</p>
<p><em>Proceed to <a href="http://mikhail.io/2016/02/building-a-poker-bot-string-number-recognition/">Part 2 of Building a Poker Bot: String and Number Recognition</a>.</em></p>
]]></content>
    </entry>
    
    <entry>
        <title>Monads explained in C#</title>
        <link href="http://mikhail.io/2016/01/monads-explained-in-csharp"/>
        <updated>2016-01-25T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-01-25,/2016/01/monads-explained-in-csharp</id>
        <content type="html"><![CDATA[<p>It looks like there is a mandatory post that every blogger who learns functional programming should write:
what a Monad is. Monads have the reputation of being something very abstract and very confusing for every
developer who is not a hipster Haskell programmer. They say that once you understand what a monad is, you 
loose the ability to explain it in simple language. Doug Crockford was the first one to lay this rule down, but
it becomes kind of obvious once you read 3 or 5 &quot;explanations&quot; on the web. Here is my attempt.</p>
<h2 id="monads-are-container-types">Monads are container types</h2>
<p>Monads are containers which encapsulate some kind of functionality. It&#39;s that simple. The goals of monads
are similar to generic goals of any encapsulation in software development practices: hide the implementation
details from the client, but provide a proper way to use the hidden functionality. It&#39;s not because we 
want to be able to change the implementation, it&#39;s because we want to make the client as simple as possible
and to enforce the best way of code structure. Quite often monads provide the way to avoid imperative code
in favor of functional style.</p>
<p>Monads are flexible, so in C# they should be represented as generic types:</p>
<pre class="highlight"><code class="hljs undefined">public class Monad&lt;T&gt;
{
}
</code></pre>
<h2 id="monad-instances-can-be-created">Monad instances can be created</h2>
<p>Quite an obvious statement, isn&#39;t it. Having a class <code>Monad&lt;T&gt;</code>, there should be a way to create an object
of this class out of an instance of type <code>T</code>. In functional world this operation is known as <code>Return</code> 
function. In C# it can be as simple as a constructor:</p>
<pre class="highlight"><code class="hljs undefined">public class Monad&lt;T&gt;
{
    public Monad(T instance)
    {
    }
}
</code></pre>
<p>But usually it makes sense to define an extension method to enable fluent syntax of monad creation:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MonadExtensions</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Monad&lt;T&gt; Return&lt;T&gt;(<span class="hljs-keyword">this</span> T instance) =&gt; <span class="hljs-keyword">new</span> Monad&lt;T&gt;(instance);
}
</code></pre>
<h2 id="monads-can-be-chained-to-create-new-monads">Monads can be chained to create new monads</h2>
<p>This is the property which makes monads so useful, but also a bit confusing. In functional world this
operation is known as functional composition and is expressed with the <code>Bind</code> function (or <code>&gt;&gt;=</code> operator).
Here is the signature of <code>Bind</code> method in C#:</p>
<pre class="highlight"><code class="hljs undefined">public class Monad&lt;T&gt;
{
    public Monad&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Monad&lt;TO&gt;&gt; func)
    {
    }
}
</code></pre>
<p>As you can see, the <code>func</code> argument is a complicated thing. It accepts an argument of type <code>T</code> (not
a monad) and returns an instance of <code>Monad&lt;TO&gt;</code> where <code>TO</code> is another type. Now, our first instance
of <code>Monad&lt;T&gt;</code> knows how to bind itself to this function to produce another instance of monad of the
new type. The full power of monads comes when we compose several of them in one chain:</p>
<pre class="highlight"><code class="hljs cs">initialValue
    .Return()
    .Bind(v1 =&gt; produceV2OutOfV1(v1))
    .Bind(v2 =&gt; produceV3OutOfV2(v2))
    .Bind(v3 =&gt; produceV4OutOfV3(v3))
    <span class="hljs-comment">//...</span>
</code></pre>
<p>And that&#39;s about it. Let&#39;s have a look at some examples.</p>
<h2 id="example-maybe-option-type">Example: Maybe (Option) type</h2>
<p><code>Maybe</code> is the 101 monad which is used everywhere. <code>Maybe</code> is another approach to dealing
with &#39;no value&#39; value which is alternative to the concept <code>null</code>. Basically your object should
never be null, but it can either have <code>Some</code> value or be <code>None</code>. F# has a maybe implementation
built into the language: it&#39;s called <code>option</code> type. Here is a sample implementation in C#:</p>
<pre class="highlight"><code class="hljs undefined">public class Maybe&lt;T&gt; where T : class
{
    private T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new AgrumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Maybe&lt;TO&gt;&gt; func)
    {
        return value != null ? new Maybe&lt;TO&gt;(func(value)) : Maybe&lt;TO&gt;.None();
    }

    public static Maybe&lt;T&gt; None() =&gt; new Maybe&lt;T&gt;(null);
}
</code></pre>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MaybeExtensions</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Maybe&lt;T&gt; NullToMaybe&lt;T&gt;(T <span class="hljs-keyword">value</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> Maybe&lt;T&gt;(<span class="hljs-keyword">value</span>) : Maybe&lt;T&gt;.None();
    }
}
</code></pre>
<p>Return function is implemented with a combination of a public constructor which accepts <code>Some</code> value
(notice that <code>null</code> is not allowed) and a static <code>None</code> method returning an object of &#39;no value&#39;.
<code>NullToMaybe</code> combines both of them in one call. </p>
<p><code>Bind</code> function is implemented explicitly. </p>
<p>Let&#39;s have a look at a use case. Imagine we have repositories which load the data from an external
storage (I&#39;ll put them to a single class for the sake of brevity):</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Maybe&lt;Customer&gt; <span class="hljs-title">GetCustomer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span>
    </span>{
        <span class="hljs-keyword">var</span> row = ReadRowFromDb(id); <span class="hljs-comment">// returns null if not found</span>
        <span class="hljs-keyword">return</span> row.NullToMaybe().Bind(r =&gt; ConvertRowToCustomer(r));
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Maybe&lt;Address&gt; <span class="hljs-title">GetAddress</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>=&gt; ... <span class="hljs-comment">// similar implementation</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> Maybe&lt;Order&gt; <span class="hljs-title">GetOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>=&gt; ... <span class="hljs-comment">// similar implementation</span>
}
</code></pre>
<p>The repository reads a row from the database and then converts its value or null to a <code>Maybe&lt;DataRow&gt;</code>.
Then it&#39;s immediately bound to a function which converts the row to a domain object (I&#39;ll omit this
function&#39;s implementation but remember that it can also return a <code>Maybe&lt;Customer&gt;</code> if that&#39;s warranted
by requirements).</p>
<p>Now here is a more sophisticated example of <code>Bind</code> method composition:</p>
<pre class="highlight"><code class="hljs cs">Maybe&lt;Shipper&gt; shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c =&gt; repo.GetAddress(c.Address.Id))
        .Bind(a =&gt; repo.GetOrder(a.LastOrder.Id))
        .Bind(o =&gt; o.Shipper);
</code></pre>
<p>If you think that the syntax looks very much like a LINQ query with a bunch of <code>Select</code> statements, you are
not the only one ;) One of the common implementations of <code>Maybe</code> implements <code>IEnumerable</code> interface
which allows a more C#-idiomatic binding composition. Actually:</p>
<h2 id="ienumerable-selectmany-is-a-monad-">IEnumerable + SelectMany is a monad </h2>
<p><code>IEnumerable</code> is an interface for enumerable containers.</p>
<p>Enumerable containers can be created - thus the <code>Return</code> monadic operation.</p>
<p>The <code>Bind</code> operation is defined by the standard LINQ extension method, here is
its signature:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;B&gt; SelectMany&lt;A, B&gt;(
    <span class="hljs-keyword">this</span> IEnumerable&lt;A&gt; first, 
    Func&lt;A, IEnumerable&lt;B&gt;&gt; selector)
</code></pre>
<p>And here is an example of composition:</p>
<pre class="highlight"><code class="hljs cs">IEnumerable&lt;Shipper&gt; someWeirdListOfShippers =
    customers
        .SelectMany(c =&gt; c.Addresses)
        .SelectMany(a =&gt; a.Orders)
        .SelectMany(o =&gt; o.Shippers);
</code></pre>
<p>The query has no idea about how the collections are stored (encapsulated in
containers). We use functions <code>A -&gt; IEnumerable&lt;B&gt;</code> to produce new enumerables
(<code>Bind</code> operation).</p>
<h2 id="conclusion">Conclusion</h2>
<p>You should not be afraid of the &quot;M-word&quot; just because you are the C# programmer. C# does not have
a notion of monads as predefined language constructs, but it doesn&#39;t mean we can&#39;t borrow some
ideas from the functional world. Having said that, it&#39;s also true that C# is lacking some powerful
ways to combine and generalize monads which are possible in Haskell and other functional languages.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Fire-and-forget in Service Fabric actors</title>
        <link href="http://mikhail.io/2016/01/fire-and-forget-in-service-fabric-actors"/>
        <updated>2016-01-13T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-01-13,/2016/01/fire-and-forget-in-service-fabric-actors</id>
        <content type="html"><![CDATA[<p>At the <a href="http://www.meetup.com/Webscale-Architecture-NL/events/225979118/">recent Webscale Architecture meetup</a> 
we discussed two implementations of the Actor model in the .NET ecosystem: 
<a href="http://akka.net">Akka.NET</a> and <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-introduction/">Azure Service Fabric Actors</a>. 
One important discussion was
around <strong>Ask</strong> vs <strong>Tell</strong> call model. With <strong>Tell</strong> model, the Sender just sends the
message to the Recepient without waiting for a result to come back. <strong>Ask</strong> model
means the Sender will at some point get a response back from the Receiver, potencially
blocking its own execution.</p>
<p>The default model of Akka.NET is <strong>Tell</strong>:</p>
<blockquote>
<p><strong>Tell: Fire-forget</strong></p>
<p>This is the preferred way of sending messages. No blocking waiting for 
a message. This gives the best concurrency and scalability characteristics.</p>
</blockquote>
<p>On the contrary, the default model for Service Fabric Actors is RPC-like
<strong>Ask</strong> model. Let&#39;s have a close look at this model, and then see how we can
implement <strong>Tell</strong> (or <strong>Fire-and-Forget</strong>) model.</p>
<p>Actor definition starts with an interface:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IHardWorkingActor</span> : <span class="hljs-title">IActor</span>
{
    <span class="hljs-function">Task <span class="hljs-title">DoWork</span><span class="hljs-params">(<span class="hljs-keyword">string</span> payload)</span></span>;
}
</code></pre><p>As you can see, the method does not return any useful data, which means
the client code isn&#39;t really interested in waiting for the operation to
complete. Here&#39;s how we implement this interface in the Actor class:</p>
<pre class="highlight"><code class="hljs vala"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HardWorkingActor</span> : <span class="hljs-title">Actor</span>, <span class="hljs-title">IHardWorkingActor</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task DoWork(<span class="hljs-keyword">string</span> payload)
    {
        ActorEventSource.Current.ActorMessage(<span class="hljs-keyword">this</span>, <span class="hljs-string">"Doing Work"</span>);
        await Task.Delay(<span class="hljs-number">500</span>);
    }
}
</code></pre><p>This test implementation simulates the hard work by means of an artificial 500 ms delay.</p>
<p>Now, let&#39;s look at the client code. Let&#39;s say, the client receives the payloads
from a queue or a web front-end and needs to go as fast as possible. It gets a payload,
creates an actor proxy to dispatch the payload to, then it just wants 
to continue with the next payload. Here is the &quot;Ask&quot; implementation based on 
the Service Fabric samples:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> timer = <span class="hljs-keyword">new</span> Stopwatch();
timer.Start();
<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)
{
    <span class="hljs-keyword">var</span> proxy = ActorProxy.Create&lt;IHardWorkingActor&gt;(ActorId.NewId(), <span class="hljs-string">"fabric:/Application1"</span>);
    <span class="hljs-keyword">await</span> proxy.DoWork($<span class="hljs-string">"Work ${i++}"</span>);
    Console.WriteLine($<span class="hljs-string">@"Sent work to Actor {proxy.GetActorId()}, 
                         rate is {i / timer.Elapsed.TotalSeconds}/sec"</span>);
}
</code></pre><p>Note an <code>await</code> operator related to every call. That means that the client will
block until the actor work is complete. When we run the client, no surprise that
we get the rate of about 2 messages per second:</p>
<pre class="highlight"><code class="hljs applescript">Sent work <span class="hljs-keyword">to</span> Actor <span class="hljs-number">1647857287613311317</span>, rate <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>,<span class="hljs-number">98643230380293</span>/sec
</code></pre><p>That&#39;s not very exciting. What we want instead is to tell the actor to do the
work and immediately proceed to the next one. Here&#39;s how the client call should
look like:</p>
<pre class="highlight"><code class="hljs bash">proxy.DoWork($<span class="hljs-string">"Work <span class="hljs-variable">${i++}</span>"</span>).FireAndForget();
</code></pre><p>Instead of <code>await</code>-ing, we make a <code>Task</code>, pass it to some (not yet existing)
extension method and proceed immediately. It appears that the implementation 
of such extension method is trivial:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TaskHelper</span>
{       
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FireAndForget</span><span class="hljs-params">(<span class="hljs-keyword">this</span> Task task)</span>
    </span>{
        Task.Run(<span class="hljs-keyword">async</span>() =&gt; <span class="hljs-keyword">await</span> task).ConfigureAwait(<span class="hljs-keyword">false</span>);
    }
} 
</code></pre><p>The result looks quite different from what we had before:</p>
<pre class="highlight"><code class="hljs applescript">Sent work <span class="hljs-keyword">to</span> Actor -<span class="hljs-number">8450334792912439527</span>, rate <span class="hljs-keyword">is</span> <span class="hljs-number">408</span>,<span class="hljs-number">484162592517</span>/sec
</code></pre><p>400 messages per second, which is some 200x difference... </p>
<p>The conclusions are simple:</p>
<ul>
<li><p>Service Fabric is a powerful platform and programming paradigm which doesn&#39;t
limit your choice of communication patterns</p>
</li>
<li><p>Design the communication models carefully based on your use case, don&#39;t
take the defaults for granted</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
        <title>Validation with Either data type in C#</title>
        <link href="http://mikhail.io/2016/01/validation-with-either-data-type-in-csharp"/>
        <updated>2016-01-06T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2016-01-06,/2016/01/validation-with-either-data-type-in-csharp</id>
        <content type="html"><![CDATA[<p>In this article we will employ a functional monadic concept <strong>Either</strong> to make validation
code more expressive and easier to maintain.</p>
<h2 id="problem">Problem</h2>
<p>Let&#39;s say we get a request from some client code and we need to check if this
request is actually valid. If it&#39;s not valid, we want to make a detailed description
of the problems that we identified. If it is valid, we want to produce a response
about the successful acceptance of the request. Let&#39;s define the classes:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> { ... }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Response</span> { ... }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> { ... }
</code></pre>
<p>Now, we need a function which would accept a <code>Request</code> and would return <code>Response</code>
or <code>ValidationError</code>. Let&#39;s look at some possible solutions.</p>
<h2 id="throw-an-exception">Throw an exception</h2>
<p>Validation <em>error</em> sounds like it could be an exception:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">Validate</span><span class="hljs-params">(Request r)</span>
</span>{
   <span class="hljs-keyword">if</span> (!Valid(r))
       <span class="hljs-function"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ValidationException</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ValidationError(...)</span>)</span>;

   <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Response</span><span class="hljs-params">(r)</span></span>;
}
</code></pre>
<p>This approach is really bad though. You have to declare a special exception
class to hold the validation error. But even worse, exception handling is not
explicit - you don&#39;t see the exception type when you look at method signature.
Client processing code is going to be messed up because of exception handling.
Never use exceptions for your business logic flow.</p>
<h2 id="output-parameter">Output parameter</h2>
<p>We could make an output parameter of <code>ValidationError</code> type:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">Validate</span><span class="hljs-params">(Request r, <span class="hljs-keyword">out</span> ValidationError error)</span>
</span>{
    <span class="hljs-keyword">if</span> (Valid(r))
    { 
        error = <span class="hljs-keyword">new</span> ValidationError(...);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    error = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Response</span><span class="hljs-params">(r)</span></span>;
}
</code></pre>
<p>Now the interface is more explicit: client won&#39;t be able to completely ignore
the fact that an error is possible. But output parameters are not really
easy to use in C#, especially in fluent-style client code. Moreover, we are
using nulls as a way to represent missing object, which is a smell by itself,
because nulls are not explicit. Never use nulls in your business logic.</p>
<h2 id="return-the-combined-result">Return the combined result</h2>
<p>We could declare a container class which would keep both <code>Response</code> and 
<code>ValidationError</code>, and then return it from the method.</p>
<pre class="highlight"><code class="hljs undefined">public class Both&lt;TData, TError&gt;
{
    public TData Data { get; set; }
    public TErrro Error { get; set; }
}
...
public Both&lt;Response, ValidationError&gt; Validate(Request r)
{
    return Valid(r) 
        ? new Both&lt;Response, ValidationError&gt; { Data = new Response(r) }
        : new Both&lt;Response, ValidationError&gt; { Data = new ValidationError(...) };
}
</code></pre>
<p>Looks much nicer, we are getting there. Now it&#39;s a pure function with input
and output parameters, but we still use null for result state representation.
Let&#39;s see how we can solve it with <strong>Either</strong> data structure.</p>
<h2 id="introducing-either">Introducing Either</h2>
<p>Instead of returning <code>Both</code> with nullable properties, let&#39;s return <code>Either</code> 
with just one of them. When constructing an object, you can specify either
a &#39;left&#39; or a &#39;right&#39; argument, but not both.</p>
<pre class="highlight"><code class="hljs undefined">public class Either&lt;TL, TR&gt;
{
    private readonly TL left;
    private readonly TR right;
    private readonly bool isLeft;

    public Either(TL left)
    {
        this.left = left;
        this.isLeft = true;
    }

    public Either(TR right)
    {
        this.right = right;
        this.isLeft = false;
    }
}
</code></pre>
<p>Now, the main difference is in how the client uses it. There are no properties
to accept <code>Left</code> and <code>Right</code> parts. Instead we define the following method:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> T Match&lt;T&gt;(Func&lt;TL, T&gt; leftFunc, Func&lt;TR, T&gt; rightFunc)
    =&gt; <span class="hljs-keyword">this</span>.isLeft ? leftFunc(<span class="hljs-keyword">this</span>.left) : rightFunc(<span class="hljs-keyword">this</span>.right);
</code></pre>
<p>That&#39;s the concept of pattern matching implemented in C# world. If a left value 
is specified, <code>Match</code> will return the result of the left function, otherwise the result
of the right function.</p>
<p>Another improvement would be to create explicit operators for easy conversions
from left and right types:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> Either&lt;TL, TR&gt;(TL left) =&gt; <span class="hljs-keyword">new</span> Either&lt;TL, TR&gt;(left);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> Either&lt;TL, TR&gt;(TR right) =&gt; <span class="hljs-keyword">new</span> Either&lt;TL, TR&gt;(right);
</code></pre>
<p>Let&#39;s have a look at a complete example.</p>
<h2 id="why-it-s-great">Why it&#39;s great</h2>
<p>Here is the service code written with <code>Either</code>:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">public</span> Either&lt;Response, ValidationError&gt; Validate(Request r)
{
    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Valid</span><span class="hljs-params">(r)</span> 
        ? Data </span>= <span class="hljs-keyword">new</span> Response(r)
        : <span class="hljs-keyword">new</span> ValidationError(...);
}
</code></pre>
<p>Clean and nice! Now a simplistic client:</p>
<pre class="highlight"><code class="hljs cs"><span class="hljs-keyword">var</span> validated = service.Validate(request);
Console.WriteLine(
    validated.Match(
        result =&gt; $<span class="hljs-string">"Success: {result}"</span>,
        error =&gt; $<span class="hljs-string">"Error: {error}"</span>)
    );
</code></pre>
<p>Simple, readable , no conditionals, no null checks, no way to silently ignore the fact that
validation may fail.</p>
<h2 id="show-me-the-code">Show me the code</h2>
<p>You can find the definition of <code>Either</code> class in my <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/Either%7BTL%2CTR%7D.cs">github repo</a>.</p>
<p><strong>Update.</strong> Here is a link to an awesome talk on this topic: 
<a href="https://vimeo.com/113707214">Railway oriented programming: Error handling in functional languages by Scott Wlaschin</a></p>
]]></content>
    </entry>
    
</feed>