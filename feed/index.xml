<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Mikhail Shilkov</title>
    <link href="https://mikhail.io/feed/" rel="self"/>
    <link href="https://mikhail.io"/>
    <updated>2018-08-02T17:50:44.641Z</updated>
    <id>https://mikhail.io/</id>
    <author>
        <name>Mikhail Shilkov</name>
        <email></email>
    </author>

    
    <entry>
        <title>AWS Lambda Warmer as Pulumi Component</title>
        <link href="https://mikhail.io/2018/08/aws-lambda-warmer-as-pulumi-component/"/>
        <updated>2018-08-02T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-08-02,/2018/08/aws-lambda-warmer-as-pulumi-component/</id>
        <content type="html"><![CDATA[<p>Out of curiosity, I&#39;m currently investigating cold starts of Function-as-a-Service platforms of major cloud providers. Basically,
if a function is not called for several minutes, the cloud instance behind it might be recycled, and then the next request will
take longer because a new instance will need to be provisioned.</p>
<p>Recently, Jeremy Daly <a href="https://www.jeremydaly.com/lambda-warmer-optimize-aws-lambda-function-cold-starts/">posted</a> a nice
article about the proper way to keep AWS Lambda instances &quot;warm&quot; to (mostly) prevent cold starts with minimal overhead.
Chris Munns <a href="https://twitter.com/chrismunns/status/1017777028274294784">endorsed</a> the article, so we know it&#39;s the right way.</p>
<p>The amount of actions to be taken is quite significant:</p>
<ul>
<li>Define a CloudWatch event which would fire every 5 minutes</li>
<li>Bind this event as another trigger for your Lambda</li>
<li>Inside the Lambda, detect whether current invocation is triggered by our CloudWatch event</li>
<li>If so, short-circuit the execution and return immediately; otherwise, run the normal workload</li>
<li>(Bonus point) If you want to keep multiple instances alive, do some extra dancing with calling itself N times in parallel,
provided by an extra permission to do so.</li>
</ul>
<h2 id="pursuing-reusability">Pursuing Reusability</h2>
<p>To simplify this for his readers, Jeremy was so kind to</p>
<ul>
<li>Create an NPM package which you can install and then call from a function-to-be-warmed</li>
<li>Provide SAM and Serverless Framework templates to automate Cloud Watch integration</li>
</ul>
<p>Those are still two distinct steps: writing the code (JS + NPM) and provisioning the cloud resources (YAML + CLI). There are some
drawbacks to that:</p>
<ul>
<li>You need to change two parts, which don&#39;t look like each other</li>
<li>They have to work in sync, e.g. Cloud Watch event must provide the right payload for the handler</li>
<li>There&#39;s still some boilerplate for every new Lambda</li>
</ul>
<h2 id="pulumi-components">Pulumi Components</h2>
<p>Pulumi takes a different approach. You can blend the application code and infrastructure management code
into one cohesive cloud application.</p>
<p>Related resources can be combined together into reusable components, which hide repetitive stuff behind code abstractions.</p>
<p>One way to define an AWS Lambda with Typescript in Pulumi is the following:</p>
<pre><code class="language-typescript">const handler = (event: any, context: any, callback: (error: any, result: any) =&gt; void) =&gt; {
    const response = {
        statusCode: 200,
        body: &quot;Cheers, how are things?&quot;
      };

    callback(null, response);
};

const lambda = new aws.serverless.Function(&quot;my-function&quot;, { /* options */ }, handler);</code></pre>
<p>The processing code <code>handler</code> is just passed to infrastructure code as a parameter.</p>
<p>So, if I wanted to make reusable API for an &quot;always warm&quot; function, how would it look like?</p>
<p>From the client code perspective, I just want to be able to do the same thing:</p>
<pre><code class="language-typescript">const lambda = new mylibrary.WarmLambda(&quot;my-warm-function&quot;, { /* options */ }, handler);</code></pre>
<p>CloudWatch? Event subscription? Short-circuiting? They are implementation details!</p>
<h2 id="warm-lambda">Warm Lambda</h2>
<p>Here is how to implement such component. The declaration starts with a Typescript class:</p>
<pre><code class="language-typescript">export class WarmLambda extends pulumi.ComponentResource {
    public lambda: aws.lambda.Function;

    // Implementation goes here...
}</code></pre>
<p>We expose the raw Lambda Function object, so that it could be used for further bindings and retrieving outputs.</p>
<p>The constructor accepts the same parameters as <code>aws.serverless.Function</code> provided by Pulumi:</p>
<pre><code class="language-typescript">constructor(name: string,
        options: aws.serverless.FunctionOptions,
        handler: aws.serverless.Handler,
        opts?: pulumi.ResourceOptions) {

    // Subresources are created here...
}</code></pre>
<p>We start resource provisioning by creating the CloudWatch rule to be triggered every 5 minutes:</p>
<pre><code class="language-typescript">const eventRule = new aws.cloudwatch.EventRule(`${name}-warming-rule`, 
    { scheduleExpression: &quot;rate(5 minutes)&quot; },
    { parent: this, ...opts }
);</code></pre>
<p>Then goes the cool trick. We substitute the user-provided handler with our own &quot;outer&quot; handler. This handler closes
over <code>eventRule</code>, so it can use the rule to identify the warm-up event coming from CloudWatch. If such is identified,
the handler short-circuits to the callback. Otherwise, it passes the event over to the original handler:</p>
<pre><code class="language-typescript">const outerHandler = (event: any, context: aws.serverless.Context, callback: (error: any, result: any) =&gt; void) =&gt;
{
    if (event.resources &amp;&amp; event.resources[0] &amp;&amp; event.resources[0].includes(eventRule.name.get())) {
        console.log(&#39;Warming...&#39;);
        callback(null, &quot;warmed!&quot;);
    } else {
        console.log(&#39;Running the real handler...&#39;);
        handler(event, context, callback);
    }
};</code></pre>
<p>That&#39;s a great example of synergy enabled by doing both application code and application infrastructure in a
single program. I&#39;m free to mix and match objects from both worlds.</p>
<p>It&#39;s time to bind both <code>eventRule</code> and <code>outerHandler</code> to a new serverless function:</p>
<pre><code class="language-typescript">const func = new aws.serverless.Function(
    `${name}-warmed`, 
    options, 
    outerHandler, 
    { parent: this, ...opts });
this.lambda = func.lambda;            </code></pre>
<p>Finally, I create an event subscription from CloudWatch schedule to Lambda:</p>
<pre><code class="language-typescript">this.subscription = new serverless.cloudwatch.CloudwatchEventSubscription(
    `${name}-warming-subscription`, 
    eventRule,
    this.lambda,
    { },
    { parent: this, ...opts });</code></pre>
<p>And that&#39;s all we need for now! See the full code 
<a href="https://github.com/mikhailshilkov/pulumi-serverless-examples/blob/master/WarmedLambda-TypeScript/warmLambda.ts">here</a>.</p>
<p>Here is the output of <code>pulumi update</code> command for my sample &quot;warm&quot; lambda application:</p>
<pre><code>     Type                                                      Name                            Plan
 +   pulumi:pulumi:Stack                                       WarmLambda-WarmLambda-dev       create
 +    samples:WarmLambda                                       i-am-warm                       create
 +      aws-serverless:cloudwatch:CloudwatchEventSubscription  i-am-warm-warming-subscription  create
 +        aws:lambda:Permission                                i-am-warm-warming-subscription  create
 +        aws:cloudwatch:EventTarget                           i-am-warm-warming-subscription  create
 +      aws:cloudwatch:EventRule                               i-am-warm-warming-rule          create
 +      aws:serverless:Function                                i-am-warm-warmed                create
 +         aws:lambda:Function                                 i-am-warm-warmed                create</code></pre><p>7 Pulumi components and 4 AWS cloud resources are provisioned by one <code>new WarmLambda()</code> line.</p>
<h2 id="multi-instance-warming">Multi-Instance Warming</h2>
<p>Jeremy&#39;s library supports warming several instances of Lambda by issuing parallel self-calls.</p>
<p>Reproducing the same with Pulumi component should be fairly straightforward:</p>
<ul>
<li>Add an extra constructor option to accept the number of instances to keep warm</li>
<li>Add a permission to call Lambda from itself</li>
<li>Fire N calls when warming event is triggered</li>
<li>Short-circuit those calls in each instance</li>
</ul>
<p>Note that only the first item would be visible to the client code. That&#39;s the power of componentization
and code reuse.</p>
<p>I didn&#39;t need multi-instance warming, so I&#39;ll leave the implementation as exercise for the reader.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Obligatory note: most probably, you don&#39;t need to add warming to your AWS Lambdas.</p>
<p>But whatever advanced scenario you might have, it&#39;s likely that it is easier to express the scenario
in terms of general-purpose reusable component, rather than a set of guidelines or templates.</p>
<p>Happy hacking!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Getting Started with AWS Lambda in Pulumi</title>
        <link href="https://mikhail.io/2018/07/getting-started-with-aws-lambda-in-pulumi/"/>
        <updated>2018-07-12T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-07-12,/2018/07/getting-started-with-aws-lambda-in-pulumi/</id>
        <content type="html"><![CDATA[<p>For a small research project of mine, I needed to create HTTP triggered
AWS Lambda&#39;s in all supported programming languages.</p>
<p>I&#39;m not a power AWS user, so I get easily confused about the configuration
of things like IAM roles or API Gateway. Moreover, I wanted my environment to
be reproducible, so manual AWS Console wasn&#39;t a good option.</p>
<p>I decided it was a good job for Pulumi. They pay a lot of attention to
serverless and especially AWS Lambda, and I love the power of 
configuration as code.</p>
<p>I created a Pulumi program which provisions Lambda&#39;s running on Javascript,
.NET, Python, Java and Go. Pulumi program itself is written in Javascript.</p>
<p>I&#39;m describing the resulting code below in case folks need to do the same thing.
The code itself is on <a href="https://github.com/mikhailshilkov/pulumi-aws-serverless-examples">my github</a>.</p>
<h2 id="javascript">Javascript</h2>
<p>Probably, the vast majority of Pulumi + AWS Lambda users will be using
Javascript as programming language for their serverless functions.</p>
<p>No wonder that this scenario is the easiest to start with. There is a
high-level package <code>@pulumi/cloud-aws</code> which hides all the AWS machinery from
a developer. </p>
<p>The simplest function will consist of just several lines:</p>
<pre><code class="language-js">const cloud = require(&quot;@pulumi/cloud-aws&quot;);

const api = new cloud.API(&quot;aws-hellolambda-js&quot;);
api.get(&quot;/js&quot;, (req, res) =&gt; {
    res.status(200).json(&quot;Hi from Javascript lambda&quot;);
});

exports.endpointJs = api.publish().url;</code></pre>
<p>Configure your Pulumi stack, run <code>pulumi update</code> and a Lambda 
is up, running and accessible via HTTP.</p>
<h2 id="-net-core">.NET Core</h2>
<p>.NET is my default development environment and AWS Lambda supports .NET Core
as execution runtime.</p>
<p>Pulumi program is still Javascript, so it can&#39;t mix C# code in. Thus, the setup
looks like this:</p>
<ul>
<li>There is a .NET Core 2.0 application written in C# and utilizing
<code>Amazon.Lambda.*</code> NuGet packages</li>
<li>I build and publish this application with <code>dotnet</code> CLI</li>
<li>Pulumi then utilizes the published binaries to create deployment artifacts</li>
</ul>
<p>C# function looks like this:</p>
<pre><code class="language-csharp">public class Functions
{
    public async Task&lt;APIGatewayProxyResponse&gt; GetAsync(APIGatewayProxyRequest request, ILambdaContext context)
    {
        return new APIGatewayProxyResponse
        {
            StatusCode = (int)HttpStatusCode.OK,
            Body = &quot;\&quot;Hi from C# Lambda\&quot;&quot;,
            Headers = new Dictionary&lt;string, string&gt; { { &quot;Content-Type&quot;, &quot;application/json&quot; } }
        };
    }
}</code></pre>
<p>For non-Javascript lambdas I utilize <code>@pulumi/aws</code> package. It&#39;s of lower level
than <code>@pulumi/cloud-aws</code>, so I had to setup IAM first:</p>
<pre><code class="language-js">const aws = require(&quot;@pulumi/aws&quot;);

const policy = {
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Action&quot;: &quot;sts:AssumeRole&quot;,
            &quot;Principal&quot;: {
                &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;,
            },
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Sid&quot;: &quot;&quot;,
        },
    ],
};
const role = new aws.iam.Role(&quot;precompiled-lambda-role&quot;, {
    assumeRolePolicy: JSON.stringify(policy),
});</code></pre>
<p>And then I did a raw definition of AWS Lambda:</p>
<pre><code class="language-js">const pulumi = require(&quot;@pulumi/pulumi&quot;);

const csharpLambda = new aws.lambda.Function(&quot;aws-hellolambda-csharp&quot;, {
    runtime: aws.lambda.DotnetCore2d0Runtime,
    code: new pulumi.asset.AssetArchive({
        &quot;.&quot;: new pulumi.asset.FileArchive(&quot;./csharp/bin/Debug/netcoreapp2.0/publish&quot;),
    }),
    timeout: 5,
    handler: &quot;app::app.Functions::GetAsync&quot;,
    role: role.arn
});</code></pre>
<p>Note the path to <code>publish</code> folder, which should match the path created by
<code>dotnet publish</code>, and the handler name matching C# class/method.</p>
<p>Finally, I used <code>@pulumi/aws-serverless</code> to define API Gateway endpoint for
the lambda:</p>
<pre><code class="language-js">const serverless = require(&quot;@pulumi/aws-serverless&quot;);

const precompiledApi = new serverless.apigateway.API(&quot;aws-hellolambda-precompiledapi&quot;, {
    routes: [
        { method: &quot;GET&quot;, path: &quot;/csharp&quot;, handler: csharpLambda },
    ],
});</code></pre>
<p>That&#39;s definitely more ceremony compared to Javascript version. But hey, it&#39;s
code, so if you find yourself repeating the same code, go ahead and make a
higher order component out of it, incapsulating the repetitive logic.</p>
<h2 id="python">Python</h2>
<p>Pulumi supports Python as scripting language, but I&#39;m sticking to Javascript
for uniform experience.</p>
<p>In this case, the flow is similar to .NET but simpler: no compilation step
is required. Just define a <code>handler.py</code>:</p>
<pre><code class="language-python">def handler(event, context): 
    return {
        &#39;statusCode&#39;: 200,
        &#39;headers&#39;: {&#39;Content-Type&#39;: &#39;application/json&#39;},
        &#39;body&#39;: &#39;&quot;Hi from Python lambda&quot;&#39;
    }</code></pre>
<p>and package it into zip in AWS lambda definition:</p>
<pre><code class="language-js">const pythonLambda = new aws.lambda.Function(&quot;aws-hellolambda-python&quot;, {
    runtime: aws.lambda.Python3d6Runtime,
    code: new pulumi.asset.AssetArchive({
        &quot;.&quot;: new pulumi.asset.FileArchive(&quot;./python&quot;),
    }),
    timeout: 5,
    handler: &quot;handler.handler&quot;,
    role: role.arn
});</code></pre>
<p>I&#39;m reusing the <code>role</code> definition from above. The API definition will also
be the same as for .NET.</p>
<h2 id="go">Go</h2>
<p>Golang is a compiled language, so the approach is similar to .NET: write code,
build, reference the built artifact from Pulumi.</p>
<p>My Go function looks like this:</p>
<pre><code class="language-go">func Handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {

 return events.APIGatewayProxyResponse{
  Body:       &quot;\&quot;Hi from Golang lambda\&quot;&quot;,
  StatusCode: 200,
 }, nil

}</code></pre>
<p>Because I&#39;m on Windows but AWS Lambda runs on Linux, I had to use 
<a href="https://github.com/aws/aws-lambda-go"><code>build-lambda-zip</code></a> 
tool to make the package compatible. Here is the PowerShell build script:</p>
<pre><code class="language-powershell">$env:GOOS = &quot;linux&quot;
$env:GOARCH = &quot;amd64&quot;
go build -o main main.go
~\Go\bin\build-lambda-zip.exe -o main.zip main</code></pre>
<p>and Pulumi function definition:</p>
<pre><code class="language-js">const golangLambda = new aws.lambda.Function(&quot;aws-hellolambda-golang&quot;, {
    runtime: aws.lambda.Go1dxRuntime,
    code: new pulumi.asset.FileArchive(&quot;./go/main.zip&quot;),
    timeout: 5,
    handler: &quot;main&quot;,
    role: role.arn
});</code></pre>
<h2 id="java">Java</h2>
<p>Java class implements an interface from AWS SDK:</p>
<pre><code class="language-java">public class Hello implements RequestStreamHandler {

    public void handleRequest(InputStream inputStream, OutputStream outputStream, Context context) throws IOException {

        JSONObject responseJson = new JSONObject();

        responseJson.put(&quot;isBase64Encoded&quot;, false);
        responseJson.put(&quot;statusCode&quot;, &quot;200&quot;);
        responseJson.put(&quot;body&quot;, &quot;\&quot;Hi from Java lambda\&quot;&quot;);  

        OutputStreamWriter writer = new OutputStreamWriter(outputStream, &quot;UTF-8&quot;);
        writer.write(responseJson.toJSONString());  
        writer.close();
    }
}</code></pre>
<p>I compiled this code with Maven (<code>mvn package</code>), which produced a <code>jar</code> file. AWS Lambda accepts
<code>jar</code> directly, but Pulumi&#39;s <code>FileArchive</code> is unfortunately crashing on trying
to read it.</p>
<p>As a workaround, I had to define a <code>zip</code> file with <code>jar</code> placed inside <code>lib</code>
folder:</p>
<pre><code class="language-js">const javaLambda = new aws.lambda.Function(&quot;aws-coldstart-java&quot;, {
    code: new pulumi.asset.AssetArchive({
        &quot;lib/lambda-java-example-1.0-SNAPSHOT.jar&quot;: new pulumi.asset.FileAsset(&quot;./java/target/lambda-java-example-1.0-SNAPSHOT.jar&quot;),
    }),
    runtime: aws.lambda.Java8Runtime,
    timeout: 5,
    handler: &quot;example.Hello&quot;,
    role: role.arn
});</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>The complete code for 5 lambda functions in 5 different programming languages
can be found in <a href="https://github.com/mikhailshilkov/pulumi-aws-serverless-examples">my github repository</a>.</p>
<p>Running <code>pulumi update</code> provisions 25 AWS resources in a matter of 1 minute,
so I can start playing with my test lambdas in no time.</p>
<p>And the best part: when I don&#39;t need them anymore, I run <code>pulumi destroy</code> and
my AWS Console is clean again!</p>
<p>Happy serverless moments!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Monads explained in C# (again)</title>
        <link href="https://mikhail.io/2018/07/monads-explained-in-csharp-again/"/>
        <updated>2018-07-05T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-07-05,/2018/07/monads-explained-in-csharp-again/</id>
        <content type="html"><![CDATA[<p>I love functional programming for the simplicity that it brings.</p>
<p>But at the same time, I realize that learning functional programming is a challenging 
process. FP comes with a baggage of unfamiliar vocabulary that can be daunting for 
somebody coming from an object-oriented language like C#.</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//functional-programming-word-cloud.png" alt="Functional Programming Word Cloud"></p>
<p><em>Some of functional lingo</em></p>
<p>&quot;Monad&quot; is probably the most infamous term from the list above. Monads have reputation of being 
something very abstract and very confusing. </p>
<h2 id="the-fallacy-of-monad-tutorials">The Fallacy of Monad Tutorials</h2>
<p>Numerous attempts were made to explain monads in simple definitions; and monad tutorials have become a
genre of its own. And yet, times and times again, they fail to enlighten the readers.</p>
<p>The shortest explanation of monads looks like this:</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//monoid-endofunctors.png" alt="A Monad is just a monoid in the category of endofunctors"></p>
<p>It&#39;s both mathematically correct and totally useless to anybody learning functional programming. To
understand this statement, one has to know the terms &quot;monoid&quot;, &quot;category&quot; and &quot;endofunctors&quot; and be able
to mentally compose them into something meaningful.</p>
<p>The same problem is apparent in most monad tutorials. They assume some pre-existing knowledge in
heads of their readers, and if that assumption fails, the tutorial doesn&#39;t click.</p>
<p>Focusing too much on mechanics of monads instead of explaining why they are important is another
common problem.</p>
<p>Douglas Crockford grasped this fallacy very well:</p>
<blockquote>
<p>The monadic curse is that once someone learns what monads are and how to use them, they lose the ability to explain them to other people</p>
</blockquote>
<p>The problem here is likely the following. Every person who understands monads had their own path to
this knowledge. It hasn&#39;t come all at once, instead there was a series of steps, each giving an insight,
until the last final step made the puzzle complete.</p>
<p>But they don&#39;t remember the whole path anymore. They go online and blog about that very last step as
the key to understanding, joining the club of flawed explanations.</p>
<p>There is an actual <a href="http://tomasp.net/academic/papers/monads/monads-programming.pdf">academic paper from Tomas Petricek</a> 
that studies monad tutorials.</p>
<p>I&#39;ve read that paper and a dozen of monad tutorials online. And of course, now I came up with my own.</p>
<p>I&#39;m probably doomed to fail too, at least for some readers. Yet, I know that many people found the
<a href="https://mikhail.io/2016/01/monads-explained-in-csharp/">previous version</a> of this article useful.</p>
<p>I based my explanation on examples from C# - the object-oriented language familiar to .NET developers.</p>
<h2 id="story-of-composition">Story of Composition</h2>
<p>The base element of each functional program is Function. In typed languages each function 
is just a mapping between the type of its input parameter and output parameter.
Such type can be annotated as <code>func: TypeA -&gt; TypeB</code>.</p>
<p>C# is object-oriented language, so we use methods to declare functions. There are two ways 
to define a method comparable to <code>func</code> function above. I can use static method:</p>
<pre><code class="language-csharp">static class Mapper 
{
    static ClassB func(ClassA a) { ... }
}</code></pre>
<p>... or instance method:</p>
<pre><code class="language-csharp">class ClassA 
{
    // Instance method
    ClassB func() { ... }
}</code></pre>
<p>Static form looks closer to the function annotation, but both ways are actually equivalent
for the purpose of our discussion. I will use instance methods in my examples, however all of
them could be written as static extension methods too.</p>
<p>How do we compose more complex workflows, programs and applications out of such simple
building blocks? A lot of patterns both in OOP and FP worlds revolve around this question.
And monads are one of the answers.</p>
<p>My sample code is going to be about conferences and speakers. The method implementations 
aren&#39;t really important, just watch the types carefully. There are 4 classes (types) and 
3 methods (functions):</p>
<pre><code class="language-csharp">class Speaker 
{
    Talk NextTalk() { ... }
}

class Talk 
{
    Conference GetConference() { ... }
}

class Conference 
{
    City GetCity() { ... }
}

class City { ... }</code></pre>
<p>These methods are currently very easy to compose into a workflow:</p>
<pre><code class="language-csharp">static City NextTalkCity(Speaker speaker) 
{
    Talk talk = speaker.NextTalk();
    Conference conf = talk.GetConference();
    City city = conf.GetCity();
    return city;
}</code></pre>
<p>Because the return type of the previous step always matches the input type of the next step, we can
write it even shorter:</p>
<pre><code class="language-csharp">static City NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()
        .GetConference()
        .GetCity();
}</code></pre>
<p>This code looks quite readable. It&#39;s concise and it flows from top to bottom, from left to right, 
similar to how we are used to read any text. There is not much noise too.</p>
<p>That&#39;s not what real codebases look like though, because there are multiple complications
along the happy composition path. Let&#39;s look at some of them.</p>
<h2 id="nulls">NULLs</h2>
<p>Any class instance in C# can be <code>null</code>. In the example above I might get runtime errors if
one of the methods ever returns <code>null</code> back.</p>
<p>Typed functional programming always tries to be explicit about types, so I&#39;ll re-write the signatures
of my methods to annotate the return types as nullables:</p>
<pre><code class="language-csharp">class Speaker 
{
    Nullable&lt;Talk&gt; NextTalk() { ... }
}

class Talk 
{
    Nullable&lt;Conference&gt; GetConference() { ... }
}

class Conference 
{
    Nullable&lt;City&gt; GetCity() { ... }
}

class City { ... }</code></pre>
<p>This is actually invalid syntax in current C# version, because <code>Nullable&lt;T&gt;</code> and its short form
<code>T?</code> are not applicable to reference types. This <a href="https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/">might change in C# 8</a>
though, so bear with me.</p>
<p>Now, when composing our workflow, we need to take care of <code>null</code> results:</p>
<pre><code class="language-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    Nullable&lt;Talk&gt; talk = speaker.NextTalk();
    if (talk == null) return null;

    Nullable&lt;Conference&gt; conf = talk.GetConference();
    if (conf == null) return null;

    Nullable&lt;City&gt; city = conf.GetCity();
    return city;
}</code></pre>
<p>It&#39;s still the same method, but it got more noise now. Even though I used short-circuit returns
and one-liners, it still got harder to read.</p>
<p>To fight that problem, smart language designers came up with the Null Propagation Operator:</p>
<pre><code class="language-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        ?.NextTalk()
        ?.GetConference()
        ?.GetCity();
}</code></pre>
<p>Now we are almost back to our original workflow code: it&#39;s clean and concise, we just got
3 extra <code>?</code> symbols around.</p>
<p>Let&#39;s take another leap.</p>
<h2 id="collections">Collections</h2>
<p>Quite often a function returns a collection of items, not just a single item. To some extent,
that&#39;s a generalization of <code>null</code> case: with <code>Nullable&lt;T&gt;</code> we might get 0 or 1 results back,
while with a collection we can get <code>0</code> to any <code>n</code> results.</p>
<p>Our sample API could look like this:</p>
<pre><code class="language-csharp">class Speaker 
{
    List&lt;Talk&gt; GetTalks() { ... }
}

class Talk 
{
    List&lt;Conference&gt; GetConferences() { ... }
}

class Conference 
{
    List&lt;City&gt; GetCities() { ... }
}</code></pre>
<p>I used <code>List&lt;T&gt;</code> but it could be any class or plain <code>IEnumerable&lt;T&gt;</code> interface.</p>
<p>How would we combine the methods into one workflow? Traditional version would look like this:</p>
<pre><code class="language-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    var result = new List&lt;City&gt;();

    foreach (Talk talk in speaker.GetTalks())
        foreach (Conference conf in talk.GetConferences())
            foreach (City city in conf.GetCities())
                result.Add(city);

    return result;
}</code></pre>
<p>It reads ok-ish still. But the combination of nested loops and mutation with some conditionals sprinkled 
on them can get unreadable pretty soon. The exact workflow might be lost in the mechanics.</p>
<p>As an alternative, C# language designers invented LINQ extension methods. We can write code like this:</p>
<pre><code class="language-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()
        .SelectMany(talk =&gt; talk.GetConferences())
        .SelectMany(conf =&gt; conf.GetCities())
        .ToList();
}</code></pre>
<p>Let me do one further trick and format the same code in an unusual way:</p>
<pre><code class="language-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()           .SelectMany(x =&gt; x
        .GetConferences()    ).SelectMany(x =&gt; x
        .GetCities()         ).ToList();
}</code></pre>
<p>Now you can see the same original code on the left, combined with just a bit of technical repeatable
clutter on the right. Hold on, I&#39;ll show you where I&#39;m going.</p>
<p>Let&#39;s discuss another possible complication.</p>
<h2 id="asynchronous-calls">Asynchronous Calls</h2>
<p>What if our methods need to access some remote database or service to produce the results? This
should be shown in type signature, and C# has <code>Task&lt;T&gt;</code> for that:</p>
<pre><code class="language-csharp">class Speaker 
{
    Task&lt;Talk&gt; NextTalk() { ... }
}

class Talk 
{
    Task&lt;Conference&gt; GetConference() { ... }
}

class Conference 
{
    Task&lt;City&gt; GetCity() { ... }
}</code></pre>
<p>This change breaks our nice workflow composition again.</p>
<p>We&#39;ll get back to async-await later, but the original way to combine <code>Task</code>-based
methods was to use <code>ContinueWith</code> and <code>Unwrap</code> API:</p>
<pre><code class="language-csharp">static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()
        .ContinueWith(talk =&gt; talk.Result.GetConference())
        .Unwrap()
        .ContinueWith(conf =&gt; conf.Result.GetCity())
        .Unwrap();
}</code></pre>
<p>Hard to read, but let me apply my formatting trick again:</p>
<pre><code class="language-csharp">static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()         .ContinueWith(x =&gt; x.Result
        .GetConference()   ).Unwrap().ContinueWith(x =&gt; x.Result
        .GetCity()         ).Unwrap();
}</code></pre>
<p>You can see that, once again, it&#39;s our nice readable workflow on the left + some mechanical repeatable
junction code on the right.</p>
<h2 id="pattern">Pattern</h2>
<p>Can you see a pattern yet?</p>
<p>I&#39;ll repeat the <code>Nullable</code>-, <code>List</code>- and <code>Task</code>-based workflows again:</p>
<pre><code class="language-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker               ?
        .NextTalk()           ?
        .GetConference()      ?
        .GetCity();
}

static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()            .SelectMany(x =&gt; x
        .GetConferences()     ).SelectMany(x =&gt; x
        .GetCities()          ).ToList();
}

static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()            .ContinueWith(x =&gt; x.Result
        .GetConference()      ).Unwrap().ContinueWith(x =&gt; x.Result
        .GetCity()            ).Unwrap();
}</code></pre>
<p>In all 3 cases there was a complication which prevented us from sequencing method
calls fluently. In all 3 cases we found the gluing code to get back to fluent composition.</p>
<p>Let&#39;s try to generalize this approach. Given some generic container type 
<code>WorkflowThatReturns&lt;T&gt;</code>, we have a method to combine an instance of such workflow with
a function which accepts the result of that workflow and returns another workflow back:</p>
<pre><code class="language-csharp">class WorkflowThatReturns&lt;T&gt; 
{
    WorkflowThatReturns&lt;U&gt; AddStep(Func&lt;T, WorkflowThatReturns&lt;U&gt;&gt; step);
}</code></pre>
<p>In case this is hard to grasp, have a look at the picture of what is going on:</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//monad-bind.png" alt="Monad Bind Internals"></p>
<ol>
<li><p>An instance of type <code>T</code> sits in a generic container.</p>
</li>
<li><p>We call <code>AddStep</code> with a function, which maps <code>T</code> to <code>U</code> sitting inside yet another
container. </p>
</li>
<li><p>We get an instance of <code>U</code> but inside two containers.</p>
</li>
<li><p>Two containers are automatically unwrapped into a single container to get back to the
original shape.</p>
</li>
<li><p>Now we are ready to add another step!</p>
</li>
</ol>
<p>In the following code, <code>NextTalk</code> returns the first instance inside the container:</p>
<pre><code class="language-csharp">WorkflowThatReturns&lt;City&gt; Workflow(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()         
        .AddStep(x =&gt; x.GetConference())
        .AddStep(x =&gt; x.GetCity()); 
}</code></pre>
<p>Subsequently, <code>AddStep</code> is called two times to transfer to <code>Conference</code> and then
<code>City</code> inside the same container:</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//monad-two-binds.png" alt="Monad Bind Chaining"></p>
<h2 id="finally-monads">Finally, Monads</h2>
<p>The name of this pattern is <strong>Monad</strong>.</p>
<p>In C# terms, a Monad is a generic class with two operations: constructor and bind.</p>
<pre><code class="language-csharp">class Monad&lt;T&gt; {
    Monad(T instance);
    Monad&lt;U&gt; Bind(Func&lt;T, Monad&lt;U&gt;&gt; f);
}</code></pre>
<p>Constructor is used to put an object into container, <code>Bind</code> is used to replace one
contained object with another contained object.</p>
<p>It&#39;s important that <code>Bind</code>&#39;s argument returns <code>Monad&lt;U&gt;</code> and not just <code>U</code>. We can think
of <code>Bind</code> as a combination of <code>Map</code> and <code>Unwrap</code> as defined per following signature:</p>
<pre><code class="language-csharp">class Monad&lt;T&gt; {
    Monad(T instance);
    Monad&lt;U&gt; Map(Function&lt;T, U&gt; f);
    static Monad&lt;U&gt; Unwrap(Monad&lt;Monad&lt;U&gt;&gt; nested);
}</code></pre>
<p>Even though I spent quite some time with examples, I expect you to be slightly confused
at this point. That&#39;s ok.</p>
<p>Keep going and let&#39;s have a look at several sample implementations of Monad pattern.</p>
<p><a name="maybe" href="https://mikhail.io/2018/07/monads-explained-in-csharp-again/undefined"></a></p>
<h2 id="maybe-option-">Maybe (Option)</h2>
<p>My first motivational example was with <code>Nullable&lt;T&gt;</code> and <code>?.</code>. The full pattern
containing either 0 or 1 instance of some type is called <code>Maybe</code> (it maybe has a value,
or maybe not).</p>
<p><code>Maybe</code> is another approach to dealing with &#39;no value&#39; value, alternative to the 
concept of <code>null</code>. </p>
<p>Functional-first language F# typically doesn&#39;t allow <code>null</code> for its types. Instead, F# has 
a maybe implementation built into the language: 
it&#39;s called <code>option</code> type. </p>
<p>Here is a sample implementation in C#:</p>
<pre><code class="language-csharp">public class Maybe&lt;T&gt; where T : class
{
    private readonly T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new ArgumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe&lt;U&gt; Bind&lt;U&gt;(Func&lt;T, Maybe&lt;U&gt;&gt; func) where U : class
    {
        return value != null ? func(value) : Maybe&lt;U&gt;.None();
    }

    public static Maybe&lt;T&gt; None() =&gt; new Maybe&lt;T&gt;();
}</code></pre>
<p>When <code>null</code> is not allowed, any API contract gets more explicit: either you
return type <code>T</code> and it&#39;s always going to be filled, or you return <code>Maybe&lt;T&gt;</code>.
The client will see that <code>Maybe</code> type is used, so it will be forced to handle 
the case of absent value.</p>
<p>Given an imaginary repository contract (which does something with customers and
orders):</p>
<pre><code class="language-csharp">public interface IMaybeAwareRepository
{
    Maybe&lt;Customer&gt; GetCustomer(int id);
    Maybe&lt;Address&gt; GetAddress(int id);
    Maybe&lt;Order&gt; GetOrder(int id);
}</code></pre>
<p>The client can be written with <code>Bind</code> method composition, without branching, 
in fluent style:</p>
<pre><code class="language-csharp">Maybe&lt;Shipper&gt; shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c =&gt; c.Address)
        .Bind(a =&gt; repo.GetAddress(a.Id))
        .Bind(a =&gt; a.LastOrder)
        .Bind(lo =&gt; repo.GetOrder(lo.Id))
        .Bind(o =&gt; o.Shipper);</code></pre>
<p>As we saw above, this syntax looks very much like a LINQ query with a bunch 
of <code>SelectMany</code> statements. One of the common 
implementations of <code>Maybe</code> implements <code>IEnumerable</code> interface to enable
a more C#-idiomatic binding composition. Actually:</p>
<h2 id="enumerable-selectmany-is-a-monad-">Enumerable + SelectMany is a Monad </h2>
<p><code>IEnumerable</code> is an interface for enumerable containers.</p>
<p>Enumerable containers can be created - thus the constructor monadic operation.</p>
<p>The <code>Bind</code> operation is defined by the standard LINQ extension method, here 
is its signature:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;U&gt; SelectMany&lt;T, U&gt;(
    this IEnumerable&lt;T&gt; first, 
    Func&lt;T, IEnumerable&lt;U&gt;&gt; selector)</code></pre>
<p>Direct implementation is quite straightforward:</p>
<pre><code class="language-csharp">static class Enumerable 
{
    public static IEnumerable&lt;U&gt; SelectMany(
        this IEnumerable&lt;T&gt; values, 
        Func&lt;T, IEnumerable&lt;U&gt;&gt; func) 
    { 
        foreach (var item in values)
            foreach (var subItem in func(item))
                yield return subItem;
    }
}</code></pre>
<p>And here is an example of composition:</p>
<pre><code class="language-csharp">IEnumerable&lt;Shipper&gt; shippers =
    customers
        .SelectMany(c =&gt; c.Addresses)
        .SelectMany(a =&gt; a.Orders)
        .SelectMany(o =&gt; o.Shippers);</code></pre>
<p>The query has no idea about how the collections are stored (encapsulated in
containers). We use functions <code>T -&gt; IEnumerable&lt;U&gt;</code> to produce new enumerables
(<code>Bind</code> operation).</p>
<h2 id="task-future-">Task (Future)</h2>
<p>In C# <code>Task&lt;T&gt;</code> type is used to denote asynchronous computation which will eventually
return an instance of <code>T</code>. The other names for similar concepts in other languages
are <code>Promise</code> and <code>Future</code>.</p>
<p>While the typical usage of <code>Task</code> in C# is different from the Monad pattern we
discussed, I can still come up with a <code>Future</code> class with the familiar structure:</p>
<pre><code class="language-csharp">public class Future&lt;T&gt;
{
    private readonly Task&lt;T&gt; instance;

    public Future(T instance)
    {
        this.instance = Task.FromResult(instance);
    }

    private Future(Task&lt;T&gt; instance)
    {
        this.instance = instance;
    }

    public Future&lt;U&gt; Bind&lt;U&gt;(Func&lt;T, Future&lt;U&gt;&gt; func)
    {
        var a = this.instance.ContinueWith(t =&gt; func(t.Result).instance).Unwrap();
        return new Future&lt;U&gt;(a);
    }

    public void OnComplete(Action&lt;T&gt; action)
    {
        this.instance.ContinueWith(t =&gt; action(t.Result));
    }
}</code></pre>
<p>Effectively, it&#39;s just a wrapper around the <code>Task</code> which doesn&#39;t add too much value,
but it&#39;s a useful illustration because now we can do:</p>
<pre><code class="language-csharp">repository
    .LoadSpeaker()
    .Bind(speaker =&gt; speaker.NextTalk())
    .Bind(talk =&gt; talk.GetConference())
    .Bind(conference =&gt; conference.GetCity())
    .OnComplete(city =&gt; reservations.BookFlight(city));</code></pre>
<p>We are back to the familiar structure. Time for some more complications.</p>
<h2 id="non-sequential-workflows">Non-Sequential Workflows</h2>
<p>Up until now, all the composed workflows had very liniar, sequential
structure: the output of a previous step was always the input for the next step.
That piece of data could be discarded after the first use because it was never needed 
for later steps:</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//linear-workflow.png" alt="Linear Workflow"></p>
<p>Quite often though, this might not be the case. A workflow step might need data
from two or more previous steps combined.</p>
<p>In the example above, <code>BookFlight</code> method might actually need both <code>Speaker</code> and
<code>City</code> objects:</p>
<p><img src="https://mikhail.io/2018/07/monads-explained-in-csharp-again//non-linear-workflow.png" alt="Non Linear Workflow"></p>
<p>In this case, we would have to use closure to save <code>speaker</code> object until we get
a <code>talk</code> too:</p>
<pre><code class="language-csharp">repository
    .LoadSpeaker()
    .OnComplete(speaker =&gt;
        speaker
            .NextTalk()
            .Bind(talk =&gt; talk.GetConference())
            .Bind(conference =&gt; conference.GetCity())
            .OnComplete(city =&gt; reservations.BookFlight(speaker, city))
        );</code></pre>
<p>Obviously, this gets ugly very soon.</p>
<p>To solve this structural problem, C# language got its <code>async</code>-<code>await</code> feature,
which is now being reused in more languages including Javascript.</p>
<p>If we move back to using <code>Task</code> instead of our custom <code>Future</code>, we are able to
write</p>
<pre><code class="language-csharp">var speaker = await repository.LoadSpeaker();
var talk = await speaker.NextTalk();
var conference = await talk.GetConference();
var city = await conference.GetCity();
await reservations.BookFlight(speaker, city);</code></pre>
<p>Even though we lost the fluent syntax, at least the block has just one level,
which makes it easier to navigate.</p>
<h2 id="monads-in-functional-languages">Monads in Functional Languages</h2>
<p>So far we learned that</p>
<ul>
<li>Monad is a workflow composition pattern</li>
<li>This pattern is used in functional programming</li>
<li>Special syntax helps simplify the usage</li>
</ul>
<p>It should come at no surprise that functional languages support monads on syntactic
level.</p>
<p>F# is a functional-first language running on .NET framework. F# had its own way of
doing workflows comparable to <code>async</code>-<code>await</code> before C# got it. In F#, the above
code would look like this:</p>
<pre><code class="language-fsharp">let sendReservation () = async {
    let! speaker = repository.LoadSpeaker()
    let! talk = speaker.nextTalk()
    let! conf = talk.getConference()
    let! city = conf.getCity()
    do! bookFlight(speaker, city)
}</code></pre>
<p>Apart from syntax (<code>!</code> instead of <code>await</code>), the major difference to C# is that
<code>async</code> is just one possible monad type to be used this way. There are many
other monads in F# standard library (they are called Computation Expressions).</p>
<p>The best part is that any developer can create their own monads, and then use
all the power of language features.</p>
<p>Say, we want a hand-made <code>Maybe</code> computation expressoin in F#:</p>
<pre><code class="language-fsharp">let nextTalkCity (speaker: Speaker) = maybe {
    let! talk = speaker.nextTalk()
    let! conf = talk.getConference()
    let! city = conf.getCity(talk)
    return city
}</code></pre>
<p>To make this code runnable, we need to define Maybe computation expression
builder:</p>
<pre><code class="language-fsharp">type MaybeBuilder() =

    member this.Bind(x, f) = 
        match x with
        | None -&gt; None
        | Some a -&gt; f a

    member this.Return(x) = 
        Some x

let maybe = new MaybeBuilder()</code></pre>
<p>I won&#39;t explain the details of what happens here, but you can see that the code is
quite trivial. Note the presence of <code>Bind</code> operation (and <code>Return</code> operation being
the monad constructor).</p>
<p>The feature is widely used by third-party F# libraries. Here is an actor definition
in Akka.NET F# API:</p>
<pre><code class="language-fsharp">let loop () = actor {
    let! message = mailbox.Receive()
    match message with
    | Greet(name) -&gt; printfn &quot;Hello %s&quot; name
    | Hi -&gt; printfn &quot;Hello from F#!&quot;
    return! loop ()
}</code></pre>
<h2 id="monad-laws">Monad Laws</h2>
<p>There are a couple laws that constructor and <code>Bind</code> need to adhere to, so
that they produce a proper monad.</p>
<p>A typical monad tutorial will make a lot of emphasis on the laws, but I find them
less important to explain to a beginner. Nonetheless, here they are for the sake
of completeness.</p>
<p><strong>Left Identity law</strong> says that Monad constructor is a neutral operation: you can safely
run it before <code>Bind</code>, and it won&#39;t change the result of the function call:</p>
<pre><code class="language-csharp">// Given
T value;
Func&lt;T, Monad&lt;U&gt;&gt; f;

// Then (== means both parts are equivalent)
new Monad&lt;T&gt;(value).Bind(f) == f(value) </code></pre>
<p><strong>Right Identity law</strong> says that given a monadic value, wrapping its contained data
into another monad of same type and then <code>Bind</code>ing it, doesn&#39;t change the original value:</p>
<pre><code class="language-csharp">// Given
Monad&lt;T&gt; monadicValue;

// Then (== means both parts are equivalent)
monadicValue.Bind(x =&gt; new Monad&lt;T&gt;(x)) == monadicValue</code></pre>
<p><strong>Associativity law</strong> means that the order in which <code>Bind</code> operations
are composed does not matter:</p>
<pre><code class="language-csharp">// Given
Monad&lt;T&gt; m;
Func&lt;T, Monad&lt;U&gt;&gt; f;
Func&lt;U, Monad&lt;V&gt;&gt; g;

// Then (== means both parts are equivalent)
m.Bind(f).Bind(g) == m.Bind(a =&gt; f(a).Bind(g))</code></pre>
<p>The laws may look complicated, but in fact they are very natural 
expectations that any developer has when working with monads, so don&#39;t
spend too much mental effort on memorizing them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>You should not be afraid of the &quot;M-word&quot; just because you are a C# programmer. </p>
<p>C# does not have a notion of monads as predefined language constructs, but 
that doesn&#39;t mean we can&#39;t borrow some ideas from the functional world. Having 
said that, it&#39;s also true that C# is lacking some powerful ways to combine 
and generalize monads that are available in functional programming
languages.</p>
<p>Go learn some more Functional Programming!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Programmable Cloud: Provisioning Azure App Service with Pulumi</title>
        <link href="https://mikhail.io/2018/06/programmable-cloud-provisioning-azure-app-service-with-pulumi/"/>
        <updated>2018-06-22T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-06-22,/2018/06/programmable-cloud-provisioning-azure-app-service-with-pulumi/</id>
        <content type="html"><![CDATA[<p>Modern Cloud providers offer a wide variety of services of different types
and levels. A modern cloud application would leverage multiple services
in order to be efficient in terms of developer experience, price, operations
etc.</p>
<p>For instance, a very simple Web Application deployed to Azure PaaS services
could use</p>
<ul>
<li>App Service - to host the application</li>
<li>App Service Plan - to define the instance size, price, scaling and other
hosting parameters</li>
<li>Azure SQL Database - to store relational data</li>
<li>Application Insights - to collect telemetry and logs</li>
<li>Storage Account - to store the binaries and leverage Run-as-Zip feature</li>
</ul>
<p>Provisioning such environment becomes a task on its own:</p>
<ul>
<li>How do we create the initial setup?</li>
<li>How do we make changes?</li>
<li>What if we need multiple environments?</li>
<li>How do we apply settings?</li>
<li>How do we recycle resources which aren&#39;t needed anymore?</li>
</ul>
<p>Well, there are several options.</p>
<h2 id="manually-in-azure-portal">Manually in Azure Portal</h2>
<p>We all start doing this in Azure Portal. User Interface is great for
discovering new services and features, and it&#39;s a quick way to make a single
change.</p>
<p><img src="https://mikhail.io/2018/06/programmable-cloud-provisioning-azure-app-service-with-pulumi//azureportal.png" alt="Azure Portal"></p>
<p><em>Creating an App Service in Azure Portal</em></p>
<p>Clicking buttons manually doesn&#39;t scale though. After the initial setup is
complete, maintaining the environment over time poses significant challenges:</p>
<ul>
<li>Every change requires going back to the portal, finding the right resource
and doing the right change</li>
<li>People make mistakes, so if you have multiple environments, they are likely
to be different in subtle ways</li>
<li>Naming gets messy over time</li>
<li>There is no easily accessible history of environment changes</li>
<li>Cleaning up is hard: usually some leftovers will remain unnoticed</li>
<li>Skills are required from everybody involved in provisioning</li>
</ul>
<p>So, how do we streamline this process?</p>
<h2 id="azure-powershell-cli-and-management-sdks">Azure PowerShell, CLI and Management SDKs</h2>
<p>Azure comes with a powerful set of tools to manage resources with code.</p>
<p>You can use PowerShell, CLI scripts or custom code like C# to do with code
whatever is possible to do via portal.</p>
<pre><code class="language-csharp">var webApp = azure.WebApps.Define(appName)
    .WithRegion(Region.WestEurope)
    .WithNewResourceGroup(rgName)
    .WithNewFreeAppServicePlan()
    .Create();</code></pre>
<p><em>Fluent C# code creating an App Service</em></p>
<p>However, those commands are usually expressed in imperative style of 
CRUD operations. You can run the commands once, but it&#39;s hard to modify
existing resources from an arbitrary state to the desired end state.</p>
<h2 id="azure-resource-manager-templates">Azure Resource Manager Templates</h2>
<p>All services in Azure are managed by Azure Resource Manager (ARM). ARM 
has a special JSON-based format for templates. </p>
<p>Once a template is defined,
it&#39;s relatively straightforward to be deployed to Azure environment. So, if
resources are defined in JSON, they will be created automatically via
PowerShell or CLI commands.</p>
<p>It is also possible to deploy templates in incremental mode, when the tool
will compare existing environment with desired configuration and will deploy
the difference.</p>
<p>Templates can be parametrized, which enables multi-environment deployments.</p>
<p>There&#39;s a problem with templates though: they are JSON files. They get
very large very fast, they are hard to reuse, it&#39;s easy to make a typo.</p>
<p><img src="https://mikhail.io/2018/06/programmable-cloud-provisioning-azure-app-service-with-pulumi//armtemplate.png" alt="ARM Template"></p>
<p><em>A fragment of auto-generated ARM Template for App Service, note the 
line numbers</em></p>
<p>Terraform is another templating tool to provision cloud resources but it uses
YAML instead of JSON. I don&#39;t have much experience with it, but the problems 
seem to be very similar.</p>
<p>Can we combine the power of SDKs and the power of JSON-/YAML-based desired state
configuration tools?</p>
<h2 id="pulumi">Pulumi</h2>
<p>One potential solution has just arrived.
A startup called Pulumi <a href="http://joeduffyblog.com/2018/06/18/hello-pulumi/">just went out of private beta to open source</a>.</p>
<p><img src="https://mikhail.io/2018/06/programmable-cloud-provisioning-azure-app-service-with-pulumi//pulumi.jpg" alt="Pulumi"></p>
<p>Pulumi wants to be much more than a better version of ARM templates, aiming
to become the tool to build cloud-first distributed systems. But for today I&#39;ll 
focus on lower level of resource provisioning task.</p>
<p>With Pulumi cloud infrastructure is defined in code using full-blown general 
purpose programming languages.</p>
<p>The workflow goes like this:</p>
<ul>
<li>Define a Stack, which is a container for a group of related resources</li>
<li>Write a program in one of supported languages (I&#39;ll use TypeScript) which
references <code>pulumi</code> libraries and constructs all the resources as objects</li>
<li>Establish connection with your Azure account</li>
<li>Call <code>pulumi</code> CLI to create, update or destroy Azure resources based on
the program</li>
<li>Pulumi will first show the preview of changes, and then apply them as
requested</li>
</ul>
<h2 id="pulumi-program">Pulumi Program</h2>
<p>I&#39;m using TypeScript to define my Azure resources in Pulumi. So, the program
is a normal Node.js application with <code>index.ts</code> file, package references in 
<code>package.json</code> and one extra file <code>Pulumi.yaml</code> to define the program:</p>
<pre><code class="language-yaml">name: azure-appservice
runtime: nodejs</code></pre>
<p>Our <code>index.js</code> is as simple as a bunch of <code>import</code> statements followed by
creating TypeScript objects per desired resource. The simplest program can
look like this:</p>
<pre><code class="language-ts">import * as pulumi from &quot;@pulumi/pulumi&quot;;
import * as azure from &quot;@pulumi/azure&quot;;

const resourceGroup = new azure.core.ResourceGroup(&quot;myrg&quot;, {
    location: &quot;West Europe&quot;
});</code></pre>
<p>When executed by <code>pulumi update</code> command, this program will create a new
Resource Group in your Azure subscription.</p>
<h2 id="chaining-resources">Chaining Resources</h2>
<p>When multiple resources are created, the properties of one resource will
depend on properties of the others. E.g. I&#39;ve defined the Resource Group
above, and now I want to create an App Service Plan under this Group:</p>
<pre><code class="language-ts">const resourceGroupArgs = {
    resourceGroupName: resourceGroup.name,
    location: resourceGroup.location
};

const appServicePlan = new azure.appservice.Plan(&quot;myplan&quot;, {
    ...resourceGroupArgs,

    kind: &quot;App&quot;,

    sku: {
        tier: &quot;Basic&quot;,
        size: &quot;B1&quot;,
    },
});</code></pre>
<p>I&#39;ve assigned <code>resourceGroupName</code> and <code>location</code> of App Service Plan to
values from the Resource Group. It looks like a simple assignment of
strings but in fact it&#39;s more complicated.</p>
<p>Property <code>resourceGroup.name</code> has the type of <code>pulumi.Output&lt;string&gt;</code>.
Constructor argument <code>resourceGroupName</code> of <code>Plan</code> has the type of
<code>pulumi.Input&lt;string&gt;</code>.</p>
<p>We assigned <code>&quot;myrg&quot;</code> value to Resource Group name, but during the actual 
deployment it will change. Pulumi will append a unique identifier to the name,
so the actually provisioned group will be named e.g. <code>&quot;myrg65fb103e&quot;</code>.</p>
<p>This value will materialize inside <code>Output</code> type only at deployment time, 
and then it will get propagated to <code>Input</code> by Pulumi.</p>
<p>There is also a nice way to return the end values of <code>Output</code>&#39;s from Pulumi
program. Let&#39;s say we define an App Service:</p>
<pre><code class="language-ts">const app = new azure.appservice.AppService(&quot;mywebsite&quot;, {
    ...resourceGroupArgs,

    appServicePlanId: appServicePlan.id
});</code></pre>
<p>First, notice how we used TypeScript spread operator to reuse
properties from <code>resourceGroupArgs</code>.</p>
<p>Second, <code>Output</code>-<code>Input</code> assignment got used again to propagate App Service
Plan ID.</p>
<p>Lastly, we can now export App Service host name from our program, e.g.
for the user to be able to go to the web site immediately after deployment:</p>
<pre><code class="language-ts">exports.hostname = app.defaultSiteHostname;</code></pre>
<p><code>Output</code> can also be transformed with <code>apply</code> function. Here is the code to
format output URL:</p>
<pre><code class="language-ts">exports.endpoint = app.defaultSiteHostname.apply(n =&gt; `https://${n}`);</code></pre>
<p>Running <code>pulumi update</code> from CLI will then print the endpoint for us:</p>
<pre><code class="language-sh">---outputs:---
endpoint: &quot;https://mywebsiteb76260b5.azurewebsites.net&quot;</code></pre>
<p>Multiple outputs can be combined with <code>pulumi.all</code>, e.g. given SQL Server
and Database, we could make a connection string:</p>
<pre><code class="language-ts">const connectionString = 
    pulumi.all([sqlServer, database]).apply(([server, db]) =&gt; 
        `Server=tcp:${server}.database.windows.net;initial catalog=${db};user ID=${username};password=${pwd};Min Pool Size=0;Max Pool Size=30;Persist Security Info=true;`)</code></pre>
<h2 id="using-the-power-of-npm">Using the Power of NPM</h2>
<p>Since our program is just a TypeScript application, we are free to use any
3rd party package which exists out there in NPM.</p>
<p>For instance, we can install Azure Storage SDK. Just</p>
<pre><code class="language-sh">npm install azure-storage@2.9.0-preview</code></pre>
<p>and then we can write a function to produce SAS token for a Blob in Azure
Storage:</p>
<pre><code class="language-ts">import * as azurestorage from &quot;azure-storage&quot;;

// Given an Azure blob, create a SAS URL that can read it.
export function signedBlobReadUrl(
    blob: azure.storage.Blob | azure.storage.ZipBlob,
    account: azure.storage.Account,
    container: azure.storage.Container,
): pulumi.Output&lt;string&gt; {
    const signatureExpiration = new Date(2100, 1);

    return pulumi.all([
        account.primaryConnectionString,
        container.name,
        blob.name,
    ]).apply(([connectionString, containerName, blobName]) =&gt; {
        let blobService = new azurestorage.BlobService(connectionString);
        let signature = blobService.generateSharedAccessSignature(
            containerName,
            blobName,
            {
                AccessPolicy: {
                    Expiry: signatureExpiration,
                    Permissions: azurestorage.BlobUtilities.SharedAccessPermissions.READ,
                },
            }
        );

        return blobService.getUrl(containerName, blobName, signature);
    });
}</code></pre>
<p>I took this function from <a href="https://github.com/pulumi/examples/tree/master/azure-ts-functions">Azure Functions</a>
example, and it will probably move to Pulumi libraries at some point, but until
then you are free to leverage the package ecosystem.</p>
<h2 id="deploying-application-files">Deploying Application Files</h2>
<p>So far we provisioned Azure App Service, but we can also deploy the application
files as part of the same workflow.</p>
<p>The code below is using <a href="https://github.com/Azure/app-service-announcements/issues/84">Run from Zip</a>
feature of App Service:</p>
<ol>
<li><p>Define Storage Account and Container</p>
<pre><code class="language-ts"> const storageAccount = new azure.storage.Account(&quot;mystorage&quot;, {
     ...resourceGroupArgs,

     accountKind: &quot;StorageV2&quot;,
     accountTier: &quot;Standard&quot;,
     accountReplicationType: &quot;LRS&quot;,
 });

 const storageContainer = new azure.storage.Container(&quot;mycontainer&quot;, {
     resourceGroupName: resourceGroup.name,
     storageAccountName: storageAccount.name,
     containerAccessType: &quot;private&quot;,
 });</code></pre>
</li>
<li><p>Create a folder with application files, e.g. <code>wwwroot</code>. It may contain
some test HTML, ASP.NET application, or anything supported by App Service.</p>
</li>
<li><p>Produce a zip file from that folder in Pulumi program:</p>
<pre><code class="language-ts"> const blob = new azure.storage.ZipBlob(&quot;myzip&quot;, {
     resourceGroupName: resourceGroup.name,
     storageAccountName: storageAccount.name,
     storageContainerName: storageContainer.name,
     type: &quot;block&quot;,

     content: new pulumi.asset.FileArchive(&quot;wwwroot&quot;)
 });</code></pre>
</li>
<li><p>Produce SAS Blob URL and assign it to App Service Run-as-Zip setting:</p>
<pre><code class="language-ts"> const codeBlobUrl = signedBlobReadUrl(blob, storageAccount, storageContainer);

 const app = new azure.appservice.AppService(&quot;mywebsite&quot;, {
     ...resourceGroupArgs,

     appServicePlanId: appServicePlan.id,

     appSettings: {
         &quot;WEBSITE_RUN_FROM_ZIP&quot;: codeBlobUrl
     }
 });</code></pre>
</li>
</ol>
<p>Run the program, and your Application will start as soon as <code>pulumi update</code>
is complete.</p>
<h2 id="determinism">Determinism</h2>
<p>Pulumi programs should strive to be deterministic.
That means you should avoid using things like current date/time or random numbers.</p>
<p>The reason is incremental updates. Every time you run <code>pulumi update</code>, it
will execute the program from scratch. If your resources depend on random
values, they will not match the existing resources and thus the false
delta will be detected and deployed.</p>
<p>In the SAS generation example above we used a fixed date in the future
instead of doing today + 1 year kind of calculation.</p>
<p>Should Pulumi provide some workaround for this?</p>
<h2 id="conclusion">Conclusion</h2>
<p>My code was kindly merged to 
<a href="https://github.com/pulumi/examples/tree/master/azure-ts-appservice">Pulumi examples</a>, 
go there for the complete runnable program that provisions App Service with
Azure SQL Database and Application Insights.</p>
<p>I really see high potential in Cloud-as-Code approach suggested by Pulumi.
Today we just scratched the surface of the possibilities. We were working
with cloud services on raw level: provisioning specific services with
given parameters.</p>
<p>Pulumi&#39;s vision includes providing higher-level components to blur the line
between infrastructure and code, and to enable everybody to create such
components on their own.</p>
<p>Exciting future ahead!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Cold Starts Beyond First Request in Azure Functions</title>
        <link href="https://mikhail.io/2018/05/azure-functions-cold-starts-beyond-first-load/"/>
        <updated>2018-05-18T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-05-18,/2018/05/azure-functions-cold-starts-beyond-first-load/</id>
        <content type="html"><![CDATA[<p>In my <a href="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers/">previous article</a>
I&#39;ve explored the topic of Cold Starts in Azure Functions. Particularly, I&#39;ve measured the
cold start delays per language and runtime version.</p>
<p>I received some follow-up questions that I&#39;d like to explore in today&#39;s post:</p>
<ul>
<li>Can we avoid cold starts except the very first one by keeping the instance warm?</li>
<li>Given one warm instance, if two requests come at the same time, will one request hit 
a cold start because existing instance is busy with the other?</li>
<li>In general, does a cold start happen at scale-out when a new extra instance is provisioned?</li>
</ul>
<p>Again, we are only talking Consumption Plan here.</p>
<h2 id="theory">Theory</h2>
<p>Azure Functions are running on instances provided by Azure App Service. Each instance is
able to process several requests concurrently, which is different comparing to AWS Lambda.</p>
<p>Thus, the following <em>could</em> be true:</p>
<ul>
<li>If we issue at least 1 request every 20 minutes, the first instance should stay warm for
long time</li>
<li>Simultaneous requests don&#39;t cause cold start unless the existing instance gets too busy</li>
<li>When runtime decides to scale out and spin up a new instance, it could do so in the background,
still forwarding incoming requests to the existing warm instance(s). Once the new instance
is ready, it could be added to the pool without causing cold starts</li>
<li>If so, cold starts are mitigated beyond the very first execution</li>
</ul>
<p>Let&#39;s put this theory under test!</p>
<h2 id="keeping-always-warm">Keeping Always Warm</h2>
<p>I&#39;ve tested a Function App which consists of two Functions:</p>
<ul>
<li>HTTP Function under test</li>
<li>Timer Function which runs every 10 minutes and does nothing but logging 1 line of text</li>
</ul>
<p>I then measured the cold start statistics similar to all the tests from my previous article.</p>
<p>During 2 days I was issuing infrequent requests to the same app, most of them would normally
lead to a cold start. Interestingly, even though I was regularly firing the timer, Azure 
switched instances to serve my application 2 times during the test period:</p>
<p><img src="https://mikhail.io/2018/05/azure-functions-cold-starts-beyond-first-load//cold-starts-keep-warm.png" alt="Infrequent Requests to Azure Functions with &quot;Keep It Warm&quot; Timer"></p>
<p>I can see that most responses are fast, so timer &quot;warmer&quot; definitely helps.</p>
<p>The first request(s) to a new instance are slower than subsequent ones. Still, they are faster
than normal full cold start time, so it could be related to HTTP stack loading.</p>
<p>Anyway, keeping Functions warm seems a viable strategy.</p>
<h2 id="parallel-requests">Parallel Requests</h2>
<p>What happens when there is a warm instance, but it&#39;s already busy with processing another
request? Will the parallel request be delayed, or will it be processed by the same
warm instance?</p>
<p>I tested with a very lightweight function, which nevertheless takes some time to complete:</p>
<pre><code class="language-csharp">public static async Task&lt;HttpResponseMessage&gt; Delay500([HttpTrigger] HttpRequestMessage req)
{
    await Task.Delay(500);
    return req.CreateResponse(HttpStatusCode.OK, &quot;Done&quot;);
}</code></pre>
<p>I believe it&#39;s an OK approximation for an IO-bound function.</p>
<p>The test client then issued 2 to 10 parallel requests to this function and measured the
response time for all requests.</p>
<p>It&#39;s not the easiest chart to understand in full, but note the following:</p>
<ul>
<li><p>Each group of bars are for requests sent at the same time. Then there goes a pause about
20 seconds before the next group of requests gets sent</p>
</li>
<li><p>The bars are colored by the instance which processed that request: same instance - same
color</p>
</li>
</ul>
<p><img src="https://mikhail.io/2018/05/azure-functions-cold-starts-beyond-first-load//cold-starts-during-simultaneous-requests.png" alt="Azure Functions Response Time to Batches of Simultaneous Requests"></p>
<p>Here are some observations from this experiment:</p>
<ul>
<li><p>Out of 64 requests, there were 11 cold starts</p>
</li>
<li><p>Same instance <em>can</em> process multiple simultaneous requests, e.g. one instance processed
7 out of 10 requests in the last batch</p>
</li>
<li><p>Nonetheless, Azure is eager to spin up new instances for multiple requests. In total
12 instances were created, which is even more than max amount of requests in any single
batch</p>
</li>
<li><p>Some of those instances were actually never reused (gray-ish bars in batched x2 and x3,
brown bar in x10)</p>
</li>
<li><p>The first request to each new instance pays the full cold start price. Runtime doesn&#39;t
provision them in background while reusing existing instances for received requests</p>
</li>
<li><p>If an instance handled more than one request at a time, response time invariably suffers,
even though the function is super lightweight (<code>Task.Delay</code>)</p>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Getting back to the experiment goals, there are several things that we learned.</p>
<p>For low-traffic apps with sporadic requests it makes sense to setup a &quot;warmer&quot; timer
function firing every 10 minutes or so to prevent the only instance from being recycled.</p>
<p>However, scale-out cold starts are real and I don&#39;t see any way to prevent them from
happening.</p>
<p>When multiple requests come in at the same time, we might expect some of them to hit
a new instance and get slowed down. The exact algorithm of instance reuse is not
entirely clear.</p>
<p>Same instance is capable of processing multiple requests in parallel, so there are
possibilities for optimization in terms of routing to warm instances during the
provisioning of cold ones. </p>
<p>If such optimizations happen, I&#39;ll be glad to re-run my tests and report any noticeable
improvements.</p>
<p>Stay tuned for more serverless perf goodness!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Azure Functions: Cold Starts in Numbers</title>
        <link href="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers/"/>
        <updated>2018-04-24T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-04-24,/2018/04/azure-functions-cold-starts-in-numbers/</id>
        <content type="html"><![CDATA[<p>Auto-provisioning and auto-scalability are the killer features of Function-as-a-Service
cloud offerings, and Azure Functions in particular.</p>
<p>One drawback of such dynamic provisioning is a phenomenon called &quot;Cold Start&quot;. Basically,
applications that haven&#39;t been used for a while take longer to startup and to handle the
first request.</p>
<p>The problem is nicely described in 
<a href="https://blogs.msdn.microsoft.com/appserviceteam/2018/02/07/understanding-serverless-cold-start/">Understanding Serverless Cold Start</a>,
so I won&#39;t repeat it here. I&#39;ll just copy a picture from that article:</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//coldstart.jpg" alt="Cold Start"></p>
<p>Based on the 4 actions which happen during a cold start, we may guess that the following factors
might affect the cold start duration:</p>
<ul>
<li>Language / execution runtime</li>
<li>Azure Functions runtime version</li>
<li>Application size including dependencies</li>
</ul>
<p>I ran several sample functions and tried to analyze the impact of these factors on cold start time.</p>
<h2 id="methodology">Methodology</h2>
<p>All tests were run against HTTP Functions, because that&#39;s where cold start matters the most.</p>
<p>All the functions were just returning &quot;Hello, World&quot; taking the &quot;World&quot; value from the query string.
Some functions were also loading extra dependencies, see below.</p>
<p>I did not rely on execution time reported by Azure. Instead, I measured end-to-end duration from
client perspective. All calls were made from within the same Azure region, so network latency should 
have minimal impact:</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//test-setup.png" alt="Test Setup"></p>
<h2 id="when-does-cold-start-happen-">When Does Cold Start Happen?</h2>
<p>Obviously, cold start happens when the very first request comes in. After that request is processed,
the instance is kept alive in case subsequent requests arrive. But for how long?</p>
<p>The following chart gives the answer. It shows values of normalized request durations across
different languages and runtime versions (Y axis) depending on the time since the previous
request in minutes (X axis):</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//coldstart-threshold.png" alt="Cold Start Threshold"></p>
<p>Clearly, an idle instance lives for 20 minutes and then gets recycled. All requests after 20 minutes
threshold hit another cold start.</p>
<h2 id="how-do-languages-compare-">How Do Languages Compare?</h2>
<p>I&#39;ll start with version 1 of Functions runtime, which is the production-ready GA version as of today.</p>
<p>I&#39;ve written Hello World HTTP function in all GA languages: C#, F# and Javascript, and I added Python
for comparison. C#/F# were executed both in the form of script, and as a precompiled .NET assembly.</p>
<p>The following chart shows some intuition about the cold start duration per language. The languages
are ordered based on mean response time, from lowest to highest. 65% of request
durations are inside the vertical bar (1-sigma interval) and 95% are inside the vertical line (2-sigma):</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//coldstarts-v1.png" alt="Cold Start V1 per Language"></p>
<p>Somewhat surprisingly, precompiled .NET is exactly on par with Javascript. Javascript &quot;Hello World&quot; 
is really lightweight, so I expected it to win, but I was wrong.</p>
<p>C# Script is slower but somewhat comparable. F# Script presented a really negative surprise though: it&#39;s much
slower. It&#39;s even slower than experimental Python support where no performance optimization would
be expected at all!</p>
<h2 id="functions-runtime-v1-vs-v2">Functions Runtime: V1 vs V2</h2>
<p>Version 2 of Functions runtime is currently in preview and not suitable for production load. That
probably means they haven&#39;t done too much performance optimization, especially from cold start
standpoint.</p>
<p>Can we see this on the chart? We sure can:</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//coldstarts-v2.png" alt="Cold Start V1 vs V2"></p>
<p>V2 is massively slower. The fastest cold starts are around 6 seconds, but the slowest can come
up to 40-50 seconds.</p>
<p>Javascript is again on-par with precompiled .NET. </p>
<p>Java is noticeably slower, even though the
deployment package is just 33kB, so I assume I didn&#39;t overblow it.</p>
<h2 id="does-size-matter-">Does Size Matter?</h2>
<p>OK, enough of Hello World. A real-life function might be more heavy, mainly because it would
depend on other third-party libraries.</p>
<p>To simulate such scenario, I&#39;ve measured cold starts for a .NET function with references to 
Entity Framework, Automapper, Polly and Serilog.</p>
<p>For Javascript I did the same, but referenced Bluebird, lodash and AWS SDK.</p>
<p>Here are the results:</p>
<p><img src="https://mikhail.io/2018/04/azure-functions-cold-starts-in-numbers//coldstarts-dependencies.png" alt="Cold Start Dependencies"></p>
<p>As expected, the dependencies slow the loading down. You should keep your Functions lean,
otherwise you will pay in seconds for every cold start.</p>
<p>An important note for Javascript developers: the above numbers are for Functions deployed
after <a href="https://github.com/Azure/azure-functions-pack"><code>Funcpack</code></a> preprocessor. The package
contained the single <code>js</code> file with Webpack-ed dependency tree. Without that, the mean
cold start time of the same function is 20 seconds!</p>
<h2 id="conclusions">Conclusions</h2>
<p>Here are some lessons learned from all the experiments above:</p>
<ul>
<li>Be prepared for 1-3 seconds cold starts even for the smallest Functions</li>
<li>Stay on V1 of runtime until V2 goes GA unless you don&#39;t care about perf</li>
<li>.NET precompiled and Javascript Functions have roughly same cold start time</li>
<li>Minimize the amount of dependencies, only bring what&#39;s needed</li>
</ul>
<p>Do you see anything weird or unexpected in my results? Do you need me to dig deeper on other aspects?
Please leave a comment below or ping me on twitter, and let&#39;s sort it all out.</p>
<p>There is a follow-up post available: 
<a href="https://mikhail.io/2018/05/azure-functions-cold-starts-beyond-first-load/">Cold Starts Beyond First Request in Azure Functions</a></p>
]]></content>
    </entry>
    
    <entry>
        <title>Awesome F# Exchange 2018</title>
        <link href="https://mikhail.io/2018/04/fsharp-exchange-2018/"/>
        <updated>2018-04-07T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-04-07,/2018/04/fsharp-exchange-2018/</id>
        <content type="html"><![CDATA[<p>I&#39;m writing this post in the train to London Stensted, on my way back from F# Exchange 2018
conference.</p>
<p>F# Exchange is a yearly conference taking place in London, and 2018 edition was the first one
for me personally. I also had an honour to speak there about creating Azure Functions with
F#.</p>
<h2 id="impression">Impression</h2>
<p>F# is still relatively niche language, so the conference is not overcrowded, but that gives
it a special feeling of family gathering. There were 162 participants this year, and I have an
impression that every one of them is extremely friendly, enthusiastic and just plain awesome.</p>
<p>The conference itself had 2 tracks of 45-minute talks and 60-minute keynotes. Most talks were
of high quality, and the topics ranging from compiler internals to fun applications like 
music generation, car racing and map drawing.</p>
<p>Both Don Syme, the creator of F#, and Philip Carter, F# program manager, were there and gave
keynotes, but they were careful enough not to draw too much attention on Microsoft and let
the community speak loud.</p>
<h2 id="corridor-track">Corridor Track</h2>
<p>But the talks were just a part of the story. For me, the conference started in the evening
before the first day at the speakers drinks party, and only finished at 1 a.m. after the 
second day (the pubs in London are lovely).</p>
<p>I spoke to so many great people, I learnt a lot, and had fun too. I&#39;ve never seen so many
F# folks at the same place, and I guess there must be something about F# which attracts
the right kind of people to it.</p>
<p>And of course it&#39;s so much fun to meet face-to-face all those twitter, slack, github and 
Channel 9 persona&#39;s and to see that they are actually real people :)</p>
<h2 id="my-talk">My Talk</h2>
<p>The talk I gave was called &quot;Azure F#unctions&quot;. It was not a hard-core F# talk, but people
seemed to be genuinely interested in the topic.</p>
<p>A decent amount of attendees are already familiar with Azure Functions, and many either run 
them in production or plan to do so.</p>
<p>The reference version conflict problem is very well known and raises a lots of questions
or concerns. This even leads to workarounds like transpiling F# Functions to Javascript
with Fable. Yikes.</p>
<p>Durable Functions seem to be sparkling a lot of initial interest. I&#39;ll be definitely
spending more time to play with them, and maybe to make F# story more smooth.</p>
<p>Functions were mentioned in Philip&#39;s keynote as one of the important areas for F# 
application, which is cool. We should spend some extra effort to make the documentation
and onboarding story as smooth as possible.</p>
<h2 id="call-to-action">Call to Action</h2>
<p>Skills Matter is the company behind the conference. Carla, Nicole and others did a great
job preparing the event; everything went smooth, informal and fun.</p>
<p>The videos are already online at <a href="https://skillsmatter.com/conferences/9419-f-sharp-exchange-2018#skillscasts">Skillscasts</a> 
(requires free signup).</p>
<p><a href="https://skillsmatter.com/conferences/10869-f-sharp-exchange-2019">F# Exchange 2019</a> 
super early bird tickets are for sale now and until Monday April 9, go 
get one and join F# Exchange in London next year! </p>
<p>I&#39;m already missing you all.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Azure Durable Functions in F#</title>
        <link href="https://mikhail.io/2018/02/azure-durable-functions-in-fsharp/"/>
        <updated>2018-02-19T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-02-19,/2018/02/azure-durable-functions-in-fsharp/</id>
        <content type="html"><![CDATA[<p>Azure Functions are designed for stateless, fast-to-execute,
simple actions. Typically, they are triggered by an HTTP call or a queue message,
then they read something from the storage or database and return the result
to the caller or send it to another queue. All within several seconds at most.</p>
<p>However, there exists a preview of <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">Durable Functions</a>,
an extension that lets you write stateful functions for long-running workflows.
Here is a picture of one possible workflow from the docs:</p>
<p><img src="https://mikhail.io/2018/02/azure-durable-functions-in-fsharp//fan-out-fan-in.png" alt="Fan-out Fan-in Workflow"></p>
<p>Such workflows might take arbitrary time to complete. Instead of blocking and
waiting for all that period, Durable Functions use the combination of
Storage Queues and Tables to do all the work asynchronously.</p>
<p>The code still <em>feels</em> like one continuous thing because it&#39;s programmed
as a single orchestrator function. So, it&#39;s easier for a human to reason 
about the functionality without the complexities of low-level communication.</p>
<p>I won&#39;t describe Durable Functions any further, just go read
<a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">documentation</a>,
it&#39;s nice and clean.</p>
<h2 id="language-support">Language Support</h2>
<p>As of February 2018, Durable Functions are still in preview. That also means
that language support is limited:</p>
<blockquote>
<p>Currently C# is the only supported language for Durable Functions. This 
includes orchestrator functions and activity functions. In the future, 
we will add support for all languages that Azure Functions supports.</p>
</blockquote>
<p>I was a bit disappointed that F# is not an option. But actually, since
Durable Functions support precompiled .NET assembly model, pretty much
anything doable in C# can be done in F# too.</p>
<p>The goal of this post is to show that you can write Durable Functions in F#.
I used precompiled .NET Standard 2.0 F# Function App running on 2.0 preview
runtime.</p>
<h2 id="orchestration-functions">Orchestration Functions</h2>
<p>The stateful workflows are Azure Functions with a special <code>OrchestrationTrigger</code>.
Since they are asynchronous, C# code is always based on <code>Task</code> and <code>async</code>-<code>await</code>.
Here is a simple example of orchestrator in C#:</p>
<pre><code class="language-csharp">public static async Task&lt;List&lt;string&gt;&gt; Run([OrchestrationTrigger] DurableOrchestrationContext context)
{
    var outputs = new List&lt;string&gt;();

    outputs.Add(await context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Tokyo&quot;));
    outputs.Add(await context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Seattle&quot;));
    outputs.Add(await context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;London&quot;));

    // returns [&quot;Hello Tokyo!&quot;, &quot;Hello Seattle!&quot;, &quot;Hello London!&quot;]
    return outputs;
}</code></pre>
<p>F# has its own preferred way of doing asynchronous code based on <code>async</code>
computation expression. The direct refactoring could look something like</p>
<pre><code class="language-fsharp">let Run([&lt;OrchestrationTrigger&gt;] context: DurableOrchestrationContext) = async {
  let! hello1 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Tokyo&quot;)   |&gt; Async.AwaitTask
  let! hello2 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Seattle&quot;) |&gt; Async.AwaitTask
  let! hello3 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;London&quot;)  |&gt; Async.AwaitTask
  return [hello1; hello2; hello3]
} |&gt; Async.StartAsTask   </code></pre>
<p>That would work for a normal HTTP trigger, but it blows up for the Orchestrator
trigger because multi-threading operations are not allowed:</p>
<blockquote>
<p>Orchestrator code must never initiate any async operation except by 
using the DurableOrchestrationContext API. The Durable Task Framework 
executes orchestrator code on a single thread and cannot interact with 
any other threads that could be scheduled by other async APIs.</p>
</blockquote>
<p>To solve this issue, we need to keep working with <code>Task</code> directly. This is
not very handy with standard F# libraries. So, I pulled an extra NuGet
package <code>TaskBuilder.fs</code> which provides a <code>task</code> computation expression.</p>
<p>The above function now looks very simple:</p>
<pre><code class="language-fsharp">let Run([&lt;OrchestrationTrigger&gt;] context: DurableOrchestrationContext) = task {
  let! hello1 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Tokyo&quot;)
  let! hello2 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;Seattle&quot;)
  let! hello3 = context.CallActivityAsync&lt;string&gt;(&quot;E1_SayHello&quot;, &quot;London&quot;)
  return [hello1; hello2; hello3]
}       </code></pre>
<p>And the best part is that it works just fine.</p>
<p><code>SayHello</code> function is Activity trigger based, and no special effort is required
to implement it in F#:</p>
<pre><code class="language-fsharp">[&lt;FunctionName(&quot;E1_SayHello&quot;)&gt;]
let SayHello([&lt;ActivityTrigger&gt;] name) =
  sprintf &quot;Hello %s!&quot; name</code></pre>
<h2 id="more-examples">More Examples</h2>
<p>Durable Functions repository comes with 
<a href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/precompiled">a set of 4 samples</a>
implemented in C#. I took all of those samples and ported them over to F#.</p>
<p>You&#39;ve already seen the first <a href="https://github.com/mikhailshilkov/azure-functions-fsharp-examples/blob/master/12-durable/HelloSequence.fs"><code>Hello Sequence</code> sample</a>
above: the orchestrator calls the activity function 3 times and combines the
results. As simple as it looks, the function will actually run 3 times for each
execution, saving state before each subsequent call.</p>
<p>The second <a href="https://github.com/mikhailshilkov/azure-functions-fsharp-examples/blob/master/12-durable/BackupSiteContent.fs"><code>Backup Site Content</code> sample</a>
is using this persistence mechanism to run
a potentially slow workflow of copying all files from a given directory to
a backup location. It shows how multiple activities can be executed in
parallel:</p>
<pre><code class="language-fsharp">let tasks = Array.map (fun f -&gt; backupContext.CallActivityAsync&lt;int64&gt;(&quot;E2_CopyFileToBlob&quot;, f)) files
let! results = Task.WhenAll tasks</code></pre>
<p>The third <a href="https://github.com/mikhailshilkov/azure-functions-fsharp-examples/blob/master/12-durable/Counter.fs"><code>Counter</code> example</a>
demos a potentially infinite actor-like workflow, where state can exist and
evolve for indefinite period of time. The key API calls are based on
<code>OrchestrationContext</code>:</p>
<pre><code class="language-fsharp">let counterState = counterContext.GetInput&lt;int&gt;()
let! command = counterContext.WaitForExternalEvent&lt;string&gt;(&quot;operation&quot;)</code></pre>
<p>The final elaborate <a href="https://github.com/mikhailshilkov/azure-functions-fsharp-examples/blob/master/12-durable/PhoneVerification.fs"><code>Phone Verification</code> workflow</a>
has several twists, like output binding for activity (<code>ICollector</code> is required
instead of C#&#39;s <code>out</code> parameter), third-party integration (Twilio to send SMSs),
recursive sub-function to loop through several attempts and context-based
timers for reliable timeout implementation.</p>
<p>So, if you happen to be an F# fan, you can still give Durable Functions a try.
Be sure to leave your feedback, so that the library could get even better 
before going GA.</p>
]]></content>
    </entry>
    
    <entry>
        <title>Load Testing Azure SQL Database by Copying Traffic from Production SQL Server</title>
        <link href="https://mikhail.io/2018/02/load-testing-azure-sql-database-by-copying-traffic-from-production-sql-server/"/>
        <updated>2018-02-06T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-02-06,/2018/02/load-testing-azure-sql-database-by-copying-traffic-from-production-sql-server/</id>
        <content type="html"><![CDATA[<p>Azure SQL Database is a managed service that provides low-maintenance SQL Server instances in the cloud.
You don&#39;t have to run and update VMs, or even take backups and setup failover clusters.
Microsoft will do administration for you, you just pay an hourly fee.</p>
<p>So, let&#39;s say you decide this value proposition is a good reason to migrate
away from your existing self-hosted SQL Server database running in production and replace
it with Azure SQL Database.</p>
<p>You do the functional testing and eventually everything works like charm. The next set of questions 
is going to be related to Database performance level:</p>
<ul>
<li>Which tier / how many DTU&#39;s should I provision?</li>
<li>How much will it cost?</li>
<li>Will it be able to handle my current production load?</li>
</ul>
<h2 id="dtus">DTUs</h2>
<p>Even if you collect all the specs of the hardware behind your existing SQL Server, you can&#39;t
directly use that knowledge to choose the right Azure SQL Database size.</p>
<p>The sizes are measured in Database Transaction Units (DTUs). These are abstract units
of measure which don&#39;t necessarily mean much on their own. Within a given tier
(Standard / Premium), doubling the DTU amount will double the max throughput.</p>
<p>That doesn&#39;t really help to plan for workload migrations.</p>
<p>There are some ways to estimate the DTU requirements by measuring metrics like CPU
and IOPS on your existing server. Have a look at <a href="http://dtucalculator.azurewebsites.net/">DTU Calculator</a>:
it consists of a data collector and an online converter from metric values to DTUs.</p>
<p>While useful as a first approximation, I&#39;m reluctant to provision Azure SQL Database 
size solely based on such estimates.</p>
<p>My answer to the problem is: Measure It!</p>
<h2 id="synthetic-tests">Synthetic Tests</h2>
<p>Go get a backup of your existing production database and Export / Import it into
Azure SQL Database. Pick the size based on your gut feel, run a load test, evaluate
the results, adjust the size, repeat.</p>
<p>If you know your workload really well, you can create a synthetic test:</p>
<ul>
<li>Create a script or scenario which resembles the real production load</li>
<li>Run it for a given period of time</li>
<li>Measure the DTU&#39;s consumed</li>
</ul>
<p>Unfortunately, I&#39;m yet to see a non-trivial database where I could manually create
such script and be reasonably sure that it reflects the reality. Most of the time
the load is consumer-driven, changes over time and heavily depends on exact query
parameter values.</p>
<p>Which brings me to the need of replaying <em>the actual production workload</em> on Azure
SQL Database.</p>
<h2 id="trace-and-replay">Trace and Replay</h2>
<p>SQL Server comes with a marvelous suite of tools refined over years of its existence.
It includes the tools to capture and replay the queries, so I started with those.</p>
<p>SQL Server Profiler has a trace template called <code>TSQL_Replay</code>:</p>
<blockquote>
<p>This template records information required to replay the trace. Use this template
to perform iterative turning, such as benchmark testing.</p>
</blockquote>
<p>This sounded like what I needed, so I ran the profiler with this template to save
a short trace.</p>
<p>Afterwards, it is possible to use the same SQL Server Profiler to replay the trace against
another target database. So the process looks like this:</p>
<p><img src="https://mikhail.io/2018/02/load-testing-azure-sql-database-by-copying-traffic-from-production-sql-server//sql-trace-replay.png" alt="Replaying Traffic with SQL Server Profiler"></p>
<p>Unfortunately, this didn&#39;t go very well:</p>
<ul>
<li><p>Azure SQL Database is not supported by the tooling. The replay kind of runs, but
it throws lots of errors like reading from non-existent system tables, trying to
switch between databases and so on </p>
</li>
<li><p>Related or not to the previous item, but replay went terribly slow. It
seemed to slow down exponentially over time</p>
</li>
<li><p>The trace file itself was of huge size. Because the template tries to record pretty
much everything, tracing 5 minutes on production produced 10 GB of XML</p>
</li>
<li><p>Replay was not real-time: you first record, then you replay. This might not be a big
issue for many databases, but some of our queries have time parameter, and results would
change if I replay the trace 1 hour later</p>
</li>
</ul>
<p>Just to give you a rough idea, our production database-under-study is handling about
1000 RPC calls per second (mostly stored procedures).</p>
<h2 id="custom-trace-replay">Custom Trace &amp; Replay</h2>
<p>Since off-the-shelf solution didn&#39;t work for me, I decided to come up with my own
custom tool chain. Here is the idea:</p>
<p><img src="https://mikhail.io/2018/02/load-testing-azure-sql-database-by-copying-traffic-from-production-sql-server//sql-trace-replay-event-hubs-functions.png" alt="Replaying Traffic with SQL Server Profiler"></p>
<p>There are two custom steps that I implemented:</p>
<ol>
<li><p>Run a console app which would host a custom trace server. The trace server
receives SQL commands and sends them to Azure Event Hubs in batches</p>
</li>
<li><p>Create an Azure Function application triggered by the Event Hub. Each function
call gets one SQL command to execute and runs it against Azure SQL database that
we are trying to load-test</p>
</li>
</ol>
<p>This setup worked remarkably well for me: I got the real-time replay of SQL commands
from production SQL Server to Azure SQL Database.</p>
<p>The rest of the article describes my setup so that you could reproduce it for your
workload.</p>
<h2 id="azure-sql-database">Azure SQL Database</h2>
<p>Ideally, you want your copy of the database to be as fresh as possible, so that the 
query plans and results match.</p>
<p>Some ideas to accomplish this are given in 
<a href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-cloud-migrate">SQL Server database migration to SQL Database in the cloud</a>.</p>
<p>Premium RS tier is great for testing, because it is much cheaper than Premium
tier, while it provides the same level of performance.</p>
<h2 id="event-hubs">Event Hubs</h2>
<p>I used Azure Event Hubs as messaging middleware between Trace Server and Replay 
Function App.</p>
<p>I started with Azure Storage Queues, but the server wasn&#39;t able to send messages
fast enough, mostly due to lack of batching.</p>
<p>Event Hubs match naturally my choice of Azure Functions: Functions have a built-in
trigger with dynamic scaling out of the box.</p>
<p>So, I just created a new Event Hub via the portal, with 32 partitions allocated.</p>
<h2 id="trace-definition-file">Trace Definition File</h2>
<p>In order to run a custom Trace Server, you still need a trace definition file.
The built-in template <code>TSQL_Replay</code> mentioned above could work, but
it&#39;s subscribed to way too many events and columns.</p>
<p>Instead, I produced my own trace template with minimal selection.
To do that, open SQL Server Profiler, then navigate to <code>File -&gt; Templates -&gt; New Template</code>,
give it a name and then on <code>Events Selection</code> tab exclude everything except
exactly the commands that you want to replay.</p>
<p>We use stored procedures for pretty much everything, so my selection looked
just like this:</p>
<p><img src="https://mikhail.io/2018/02/load-testing-azure-sql-database-by-copying-traffic-from-production-sql-server//sql-profiler-template.png" alt="SQL Profiler Template"></p>
<p>For the first few runs, I advise you to restrict the trace even further. Click
<code>Column Filters</code> button, select <code>TextData</code> there and set <strong>Like</strong> filter
to a single stored procedure, e.g. matching the pattern <code>%spProductList%</code>.</p>
<p>This way you can debug your whole replay chain without immediately overloading
any part of it with huge stream of commands.</p>
<p>Once done, save the <code>tdf</code> file to disk. An example of such trace definition file
can be found in <a href="https://github.com/mikhailshilkov/sql-trace-replay/tree/master/TDF">my github</a>.</p>
<h2 id="trace-server">Trace Server</h2>
<p>My trace server is a simple C# console application.</p>
<p>Create a new console app and reference a NuGet package <code>Microsoft.SqlServer.SqlManagementObjects</code>.
Mine is of version <code>140.17218.0</code> (latest as of today).</p>
<p>Unfortunately, this NuGet package is not fully self-contained. In order to run
a profiling session, you have to install SQL Server Profiler tool on the machine
where you want to run the trace server.</p>
<p>Chances are that you already have it there, but be sure to update to the matching
version: mine works with <code>17.4 / 14.0.17213.0</code> but refused to work with older 
versions.</p>
<p>Now we can implement our trace server as a console application. The main
method looks like this:</p>
<pre><code class="language-csharp">static void Main(string[] args) // args: &lt;db server name&gt; &lt;db name&gt; &lt;trace file&gt;
{
    // 1. Run trace server
    var connectionInfo = new SqlConnectionInfo(args[0])
    {
        DatabaseName = args[1],
        UseIntegratedSecurity = true
    };
    var trace = new TraceServer();
    trace.InitializeAsReader(connectionInfo, args[2]);

    // 2. Continuously read traces and send them to event hubs
    var tokenSource = new CancellationTokenSource();
    var readerTask = Task.Factory.StartNew(() =&gt; ReadTrace(trace, tokenSource.Token), tokenSource.Token);
    var senderTask = Task.Factory.StartNew(() =&gt; SendToEventHubs(tokenSource.Token), tokenSource.Token);

    // 3. Stop the trace
    Console.WriteLine(&quot;Press any key to stop...&quot;);
    Console.ReadKey();
    tokenSource.Cancel();
    Task.WaitAll(readerTask, senderTask);
}</code></pre>
<p>The first block initializes SQL connection using command line arguments and integrated
security, and then starts the Trace Server.</p>
<p>Because of the large volume, I made trace reader and event sender to work on separate
threads. They talk to each other via a concurrent queue:</p>
<pre><code class="language-csharp">private static readonly ConcurrentQueue&lt;string&gt; eventQueue = new ConcurrentQueue&lt;string&gt;();</code></pre>
<p>Finally, when operator presses any key, the cancellation is requested and the reader and
sender get shut down.</p>
<p>Trace Reader task is a loop crunching though trace data and sending the SQL statements
(with some exclusions) to the concurrent in-memory queue:</p>
<pre><code class="language-csharp">private static void ReadTrace(TraceServer trace, CancellationToken token)
{ 
    while (trace.Read() &amp;&amp; !token.IsCancellationRequested)
    {
        var eventClass = trace[&quot;EventClass&quot;].ToString();
        if (string.Compare(eventClass, &quot;RPC:Completed&quot;) == 0)
        {
            var textData = trace[&quot;TextData&quot;].ToString();
            if (!textData.Contains(&quot;sp_reset_connection&quot;)
                &amp;&amp; !textData.Contains(&quot;sp_trace&quot;)
                &amp;&amp; !textData.Contains(&quot;sqlagent&quot;))
            {
                eventQueue.Enqueue(textData);
            }
        }
    }

    trace.Stop();
    trace.Close();
}</code></pre>
<p>Event Sender is dequeueing SQL commands from in-memory queue to collect batches of
events. As soon as a batch fills up, it gets dispatched to Event Hub:</p>
<pre><code class="language-csharp">private static void SendToEventHubs(CancellationToken token)
{
    var client = EventHubClient.CreateFromConnectionString(EventHubsConnectionString);
    var batch = client.CreateBatch();
    while (!token.IsCancellationRequested)
    {
        if (!eventQueue.TryDequeue(out string sql))
        {
            Thread.Sleep(10);
            continue;
        }

        var eventData = new EventData(Encoding.UTF8.GetBytes(sql));
        if (!batch.TryAdd(eventData) &amp;&amp; batch.Count &gt; 0)
        {
            client.SendAsync(batch.ToEnumerable())
                .ContinueWith(OnAsyncMethodFailed, token, TaskContinuationOptions.OnlyOnFaulted, TaskScheduler.Default);
            batch = client.CreateBatch();
            batch.TryAdd(eventData);
        }
    }
}</code></pre>
<p>If your trace doesn&#39;t produce so many messages, you will probably want to periodically send out the batches
even before they get full, just to keep that process closer to real time.</p>
<p>Note that sender does not await <code>SendAsync</code> call. Instead, we only subscribe to failures via <code>OnAsyncMethodFailed</code>
callback to print it to console:</p>
<pre><code class="language-csharp">private static void OnMyAsyncMethodFailed(Task task)
{
    Console.WriteLine(task.Exception?.ToString() ?? &quot;null error&quot;);
}</code></pre>
<p>And that concludes the implementation of the Trace Server. SQL commands now go to Event Hub, to be picked
up by Trace Replay.</p>
<h2 id="trace-replay-function-app">Trace Replay Function App</h2>
<p>To replay those traces against the target Azure SQL Database, I could make another console
application which would contain <code>EventProcessorHost</code> to receive and process SQL commands.</p>
<p>However, under high load a single machine might not be able to keep up with executing all
those commands in real time.</p>
<p>Instead, I decided to distribute such Replay App over multiple machines. To deploy a 
DDoS network, if you will :)</p>
<p>And I don&#39;t have to build, find, configure and synchronize all those servers myself, since we
are living in the world of serverless.</p>
<p><a href="https://azure.microsoft.com/en-us/services/functions/">Azure Functions</a> are the perfect tool for this job. Once you start the trace server,
Function App will start scaling up based on the amount of events in Event Hub, and will
expand until it catches up with the workload.</p>
<p>But as long as you don&#39;t run the trace server, it won&#39;t consume any servers and won&#39;t cost you
a dime. </p>
<p>Here is the implementation of Trace Replay Azure Function:</p>
<pre><code class="language-csharp">public static class Replay
{
    [FunctionName(&quot;Replay&quot;)]
    public static void Run(
        [EventHubTrigger(&quot;sqltrace&quot;, Connection = &quot;EventHubsConn&quot;)] string sql,
        TraceWriter log)
    {
        var commandName = sql
            .Split(null)
            .SkipWhile(r =&gt; r != &quot;exec&quot; &amp;&amp; r != &quot;sp_executesql&quot;)
            .FirstOrDefault(r =&gt; !r.Contains(&quot;exec&quot;)) ?? &quot;&lt;empty&gt;&quot;;

        var stopwatch = new Stopwatch();
        stopwatch.Start();

        try
        {
            using (var sqlConnection = new SqlConnection(AzureSqlConnectionString))
            using (var cmd = new SqlCommand())
            {
                sqlConnection.Open();

                cmd.CommandText = sql;
                cmd.CommandType = CommandType.Text;

                cmd.Connection = sqlConnection;

                int count = 0;
                using (var reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        count++;
                    }
                }

                log.Info($&quot;Processed {commandName} in {stopwatch.ElapsedMilliseconds} ms with {count} rows&quot;);
            }
        }
        catch (Exception ex)
        {
            log.Error($&quot;Error in {commandName} in {stopwatch.ElapsedMilliseconds} {ex.Message}&quot;);
            throw;
        }
    }
}</code></pre>
<p>It&#39;s super simple: the function gets a SQL statement, executes it with <code>SqlCommand</code> class and
logs the result with timing and returned row count. And that&#39;s everything required to start
bombarding my Azure SQL Database.</p>
<h2 id="evaluating-results">Evaluating Results</h2>
<p>The purpose of this whole exercise was to evaluate whether a provisioned DTU level
is enough to stand the load comparable to existing production.</p>
<p>So, after I ran the test, I could browse through the DTU usage chart in Azure portal to
get overall usage statistics.</p>
<p>I&#39;ve also spent quite some time analyzing the usage breakdown as reported by <code>sp_BlitzCache</code>
from <a href="https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit">Responder Kit</a>. 
Please note that it&#39;s not officially supported for Azure SQL Database, but it seems to work 
reasonably well.</p>
<p>Be sure to re-run your experiments multiple times, at different days and time intervals.</p>
<p>The full code sample can be found in <a href="https://github.com/mikhailshilkov/sql-trace-replay/tree/master/TDF">my github</a>.</p>
<p>I hope Azure SQL Database will perform to your expectations and within your budget. But
hope is not a good strategy, so go ahead and try it out!</p>
<p>Happy DDoS-ing!</p>
]]></content>
    </entry>
    
    <entry>
        <title>Tic-Tac-Toe with F#, Azure Functions, HATEOAS and Property-Based Testing</title>
        <link href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/"/>
        <updated>2018-01-23T00:00:00.000Z</updated>
        <id>tag:mikhail.io,2018-01-23,/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/</id>
        <content type="html"><![CDATA[<p>This post describes a toy application that I&#39;ve built with F# and Azure Functions
in about 1 day of work. It shows a simple end-to-end implementation with some 
useful techniques applied, and can be used as a reference point for anyone interested in
one of the topics mentioned in the title.</p>
<p>The requirements for my application are quite simple:</p>
<ul>
<li>Implement the game of Tic-Tac-Toe for a human player to play against the computer</li>
<li>The field is 3x3, the player to have three-in-a-row wins</li>
<li>After the game, the score is calculated based on the number of moves combined 
with the duration of the game</li>
<li>The history of players&#39; scores is persisted and presented as the leaderboard</li>
</ul>
<p>Below I go through the code step by step. Feel free to jump to the part which interests
you the most: 
<a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#DomainModelling">Domain Modelling</a>, 
<a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#AzureFunctions">Azure Functions</a>, 
<a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#HATEOAS">HATEOAS</a>,
<a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#PropertyBasedTesting">Property-Based Testing</a>.</p>
<p>The game is online, so you can play it <a href="https://tictactoefs.azurewebsites.net/home">here</a>.</p>
<p>The full source code can be found in <a href="https://github.com/mikhailshilkov/tictactoe">my github</a>.</p>
<p><a name="DomainModelling" href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/undefined"></a></p>
<h2 id="modeling-the-game-with-types">Modeling the Game with Types</h2>
<p>I start with a domain model. The model is composed of immutable F# types (records and discriminated
unions) and pure functions.</p>
<p>We have two players, so we need a type for them:</p>
<pre><code class="language-fsharp">type Player = X | O</code></pre>
<p>In addition, there is a useful function to return the other player based on the given one.
Simple pattern-matching will do:</p>
<pre><code class="language-fsharp">module Player =
  let other = function | X -&gt; O | O -&gt; X</code></pre>
<p>The domain code is the most important part of the application, so I want it to be covered
by unit tests. Of course, the above function doesn&#39;t really warrant testing, but it&#39;s a nice
and simple way to try out <a href="https://fsharpforfunandprofit.com/posts/property-based-testing/">Property-Based Testing</a>. 
That is, instead of defining specific tests, we define properties which hold for any valid input.</p>
<p>For <code>other</code> function, I came up with two properties:</p>
<ul>
<li>Other player is not equal to original player</li>
<li>Other player of other player is the player itself</li>
</ul>
<p>Here is the code with <a href="https://github.com/haf/expecto">Expecto</a> and <a href="https://github.com/fscheck/FsCheck">FsCheck</a>:</p>
<pre><code class="language-fsharp">testProperty &quot;Other player is not equal to player&quot; &lt;| fun x -&gt;
  Expect.notEqual x (Player.other x) &quot;Other should be different from original&quot;

testProperty &quot;Other player of other player is the player itself&quot; &lt;| fun x -&gt;
  Expect.equal x (Player.other (Player.other x)) &quot;Other other should be equal to original&quot;</code></pre>
<p>Let&#39;s move on to modelling the game. I decided to define a union type to be used for
horizontal and vertical positions of the cells:</p>
<pre><code class="language-fsharp">type Position = One | Two | Three</code></pre>
<p>I could use the normal integers instead, but I don&#39;t want to be worried about validating
the ranges all the time.</p>
<p>My first record type models the move, or action done by a player: it has <code>X</code> and <code>Y</code>
positions of the chosen cell, plus the player information:</p>
<pre><code class="language-fsharp">type Move = {
  X: Position
  Y: Position
  By: Player
}</code></pre>
<p>The following type <code>RunningGame</code> has just two properties, but its shape defines the
design of the whole application:</p>
<pre><code class="language-fsharp">type RunningGame = {
  MovesDone: Move list
  PossibleMoves: Move list
}</code></pre>
<p>This type models any state of the game which is not finished yet. </p>
<p><code>MovesDone</code> represents the ordered log of all moves, so we have the complete history 
of actions at any time. Event Sourcing in small.</p>
<p>Equally importantly, there is a list of all possible moves at this point of the game.
I could get away without this property: in the end, it can always be derived from
the history of done moves and 3x3 size of the field.</p>
<p>However, having the list of possible moves simplifies the design of all the decision
maker (client) code:</p>
<ul>
<li>Clients don&#39;t have to search for remaining cells based on move log</li>
<li>Validation of a move received from clients gets trivial: just check that it&#39;s in
the list of possible moves</li>
<li>Bot implementation gets easy: it just needs to pick one of the valid moves. The
most trivial bot is a one-liner: it picks a random move from the collection</li>
<li>Tests take advantage of this in a similar way, see <a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#PropertyBasedTesting">Game Tests</a> below</li>
<li>We build a nice bridge into HATEOAS-style API, where links provided in the response
correspond to possible moves, see <a href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/#HATEOAS">REST API</a> below</li>
</ul>
<p>Now, we can model a game which is already finished:</p>
<pre><code class="language-fsharp">type GameOutcome = Won of Player | Tie

type FinishedGame = {
  MovesDone: Move list
  Outcome: GameOutcome
}</code></pre>
<p>Each finished game has a list of moves and the outcome: either one player won, or there
was a tie.</p>
<p>Each state of a game can be described by the union of the previous two states:</p>
<pre><code class="language-fsharp">type GameState = 
  | Finished of FinishedGame
  | InProgress of RunningGame</code></pre>
<h2 id="modeling-game-flow">Modeling Game Flow</h2>
<p>Now, when all the types are in place, we can model the game flow. The flow is a sequence
of transitions between game states, implemented with pure functions.</p>
<p>First, each game starts at the same state, which is an empty field, and X turn. Here
is the value which represents this initial state:</p>
<pre><code class="language-fsharp">module Game =
  let initialState = 
    let positions = [One; Two; Three]
    let cells = seq { 
      for x in positions do
         for y in positions do
            yield { X = x; Y = y; By = X }
      }
    { MovesDone = []; PossibleMoves = List.ofSeq cells }</code></pre>
<p>After each move is made, we need a function to evaluate move outcome: whether current
game is finished or is still in progress. I defined a function <code>evaluate</code> for that:</p>
<pre><code class="language-fsharp">let private evaluate (history: Move list): GameOutcome option = ...</code></pre>
<p>I don&#39;t show the full body here, since it&#39;s quite boring in evaluating rows, columns
and diagonals for three-in-a-row. See the <a href="https://github.com/mikhailshilkov/tictactoe/blob/master/TicTacToe/Game.fs#L42-L56">full code</a> 
if you want to.</p>
<p>The following function is even more important: that&#39;s the main domain function called 
<code>makeMove</code>. Its type is <code>RunningGame -&gt; Move -&gt; GameState</code> which perfectly communicates
its intent: given a running game and a move, it returns the game state after the move.
Note that</p>
<ul>
<li>You can&#39;t pass a finished game as an argument, because making a move on finished game
doesn&#39;t make sense</li>
<li>The result <em>can</em> be a finished game</li>
</ul>
<p>Here is the function implementation:</p>
<pre><code class="language-fsharp">let makeMove (game: RunningGame) (move: Move): GameState =
  let movesDone = move :: game.MovesDone
  match evaluate movesDone with
  | Some result -&gt; Finished { MovesDone = movesDone; Outcome = result }
  | None -&gt;
    let possibleMoves = 
      List.except [move] game.PossibleMoves
      |&gt; List.map (fun m -&gt; { m with By = Player.other m.By })
    InProgress { MovesDone = movesDone; PossibleMoves = possibleMoves }</code></pre>
<p>It works like this:</p>
<ul>
<li>Prepend the new move to moves done</li>
<li>Evaluate the game result of these combined moves</li>
<li>If the result is known, return a <code>Finished</code> game with calculated outcome</li>
<li>If the result is not clear yet, return <code>InProgress</code> game with possible
moves same as before, but excluding the move and assigned to the other player</li>
</ul>
<p>Tic-Tic-Toe is two-player game, so I defined another function which runs
a turn of 2 moves by 2 players, given the decision making functions of both
players (so it&#39;s a higher-order function):</p>
<pre><code class="language-fsharp">let makeRound player1 player2 gameState =
  let newGameState = player1 gameState |&gt; makeMove gameState
  match newGameState with
  | Finished _ -&gt; newGameState
  | InProgress p -&gt; player2 p |&gt; makeMove p  </code></pre>
<p>Looks almost like monadic <code>bind</code> operation...</p>
<p><a name="PropertyBasedTesting" href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/undefined"></a></p>
<h2 id="property-based-testing">Property-Based Testing</h2>
<p>I&#39;ve already shown two simplistic properties for <code>other</code> function.</p>
<p>It&#39;s a bit more challenging to come up with invariant properties when it
comes to testing the game itself. After some brainstorming, I&#39;ve made the
following list:</p>
<ul>
<li>The game is never finished after 4 moves</li>
<li>The game is always finished after 9 moves</li>
<li>X and 0 have to make moves in turns</li>
<li>Player wins by filling one column</li>
<li>Player wins by filling one row</li>
<li>Player wins by filling diagonal</li>
<li>Evaluate a known tie</li>
</ul>
<p>Each property-based test should accept some input from the testing framework.
It should then evaluate the test against this input and assert the invariants.
If the property holds for any possible valid input, the test is green.</p>
<p>I decided to structure my property tests in the following way:</p>
<ul>
<li>Each test accepts a list of non-negative integers</li>
<li>Each integer is interpreted as an index of a possible move to select at turn <code>i</code>.
That means that the test receives a sequence which uniquely identifies the moves
to be made</li>
<li>We can restrict this sequence to a scenario under test, e.g. make it less
than 4 moves, or exactly 9 moves, or pick moves from a limited subset of all
possible moves</li>
<li>We apply the moves to calculate the end result</li>
<li>We assert that the result confirms the property under test</li>
</ul>
<p>Now, it&#39;s the responsibility of property based testing framework to generate
all kinds of input lists to try to break our property. If it succeeds, it will
print the exact input which causes the test to fail.</p>
<p>Here is how one such test is implemented.</p>
<p>A helper function plays a sequence of indexes as moves:</p>
<pre><code class="language-fsharp">let playSequence moves = 
  let playOne s i =
    match s with
    | InProgress p -&gt; Game.makeMove p (p.PossibleMoves.[i % p.PossibleMoves.Length])
    | _ -&gt; s
  List.fold playOne (InProgress Game.initialState) moves</code></pre>
<p>Then the property &quot;The game is always finished after 9 moves&quot; is simply:</p>
<pre><code class="language-fsharp">testProp &quot;The game is always finished after 9 moves&quot; &lt;| fun (Gen.ListOf9 xs) -&gt;
  let result = playSequence xs
  Expect.isTrue (Game.isFinished result) &quot;Game should be finished&quot;</code></pre>
<p>Note the restriction <code>Gen.ListOf9 xs</code> that we put on the input sequence. It&#39;s a
generator that I <a href="https://github.com/mikhailshilkov/tictactoe/blob/master/TicTacToe.Tests/Gen.fs#L31-L32">defined</a>, 
so that the list always contains exactly 9 elements.</p>
<p>Other property tests follow a similar pattern, you can see them 
<a href="https://github.com/mikhailshilkov/tictactoe/blob/master/TicTacToe.Tests/GameTests.fs">here</a>.</p>
<p><a name="HATEOAS" href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/undefined"></a></p>
<h2 id="rest-api">REST API</h2>
<p>Now, when I&#39;m done with Game domain model, I want to define API that our HTTP
service will expose to the clients. I define my API in REST model.</p>
<p>The main resource is <code>/game</code> resource. To start a new game, a client has to send
<code>POST</code> command:</p>
<pre><code>POST /game
Content-Type: application/json

{ &quot;name&quot;: &quot;Mikhail&quot; }</code></pre><p>And the response body is JSON which denotes a new game created:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;5d7b2261&quot;,
    &quot;busyCells&quot;: [],
    &quot;links&quot;: [
        {
            &quot;rel&quot;: &quot;x1y1&quot;,
            &quot;href&quot;: &quot;/game/5d7b2261/move/0&quot;
        },
        {
            &quot;rel&quot;: &quot;x1y2&quot;,
            &quot;href&quot;: &quot;/game/5d7b2261/move/1&quot;
        },
        // ... 7 more links follow
    ]
}</code></pre>
<p>The response contains a game ID and the list of occupied cells, empty for now,
because no moves have been made.</p>
<p>More importantly, it contains a list of links, each one of which has a <code>rel</code>
field representing a cell, and a link. The client should <code>POST</code> to this link
if it wants to make a move on the corresponding cell:</p>
<pre><code>POST /game/5d7b2261/move/1</code></pre><p>And the response is:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;5d7b2261&quot;,
    &quot;result&quot;: null,
    &quot;busyCells&quot;: [
        {
            &quot;name&quot;: &quot;x2y3&quot;,
            &quot;value&quot;: &quot;O&quot;
        },
        {
            &quot;name&quot;: &quot;x1y2&quot;,
            &quot;value&quot;: &quot;X&quot;
        }
    ],
    &quot;links&quot;: [
        {
            &quot;rel&quot;: &quot;x1y1&quot;,
            &quot;href&quot;: &quot;/game/5d7b2261/move/0&quot;
        },
        {
            &quot;rel&quot;: &quot;x1y3&quot;,
            &quot;href&quot;: &quot;/game/5d7b2261/move/1&quot;
        },
        // ... 5 more links follow
    ]
}</code></pre>
<p>It has the same structure as before, but now two cells are occupied: one <code>X</code> and one <code>O</code>. The
list of links now has only 7 links, based on the count of free cells.</p>
<p>The client keeps navigating the links until it gets non-empty <code>result</code> field:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;5d7b2261&quot;,
    &quot;result&quot;: &quot;You Win!&quot;,
    &quot;busyCells&quot;: [
        {
            &quot;name&quot;: &quot;x3y1&quot;,
            &quot;value&quot;: &quot;X&quot;
        },
        {
            &quot;name&quot;: &quot;x3y2&quot;,
            &quot;value&quot;: &quot;O&quot;
        },
        // ... more cells here
    ],
    &quot;links&quot;: [],
    &quot;score&quot;: 401
}</code></pre>
<p>This denotes the end of the game. There&#39;s no more links to navigate, so the client knows it
has to stop playing.</p>
<p>This API is designed in HATEOAS-style (Hypermedia as the Engine of Application State). The
clients only need to know the initial URL, while all the other URLs are received from the
previous responses. It resembles the way a human navigates websites.</p>
<p><a name="AzureFunctions" href="https://mikhail.io/2018/01/tictactoe-with-fsharp-azurefunctions-hateoas-and-property-based-testing/undefined"></a></p>
<h2 id="azure-functions">Azure Functions</h2>
<p>I implemented the above API with Azure Functions. I used .NET Standard based v2 runtime
with precompiled F# functions.</p>
<p>The initial <code>POST /game</code> request is handled by <code>Start</code> function:</p>
<pre><code class="language-fsharp">type GameRequest = { Name: string }

type Cell = { Name: string; Value: string }
type Link = { Rel:  string; Href:  string }

type GameDTO = {
  Id: string
  Result: string
  BusyCells: Cell list
  Links: Link list
  Score: int
}

[&lt;FunctionName(&quot;Start&quot;)&gt;]
let start([&lt;HttpTrigger(AuthorizationLevel.Anonymous, &quot;POST&quot;, Route = &quot;game&quot;)&gt;] req: GameRequest,
          [&lt;Table(&quot;TicTacToe&quot;)&gt;] store: ICollector&lt;GameEntity&gt;) =
  let gameid = Guid.NewGuid().ToString()
  let state = InProgress Game.initialState
  let serializedState = JsonConvert.SerializeObject state
  store.Add(GameEntity(PartitionKey = &quot;default&quot;, RowKey = gameid, Name = req.Name, State = serializedState))
  ObjectResult(Api.serialize gameid state 0)</code></pre>
<p>The outline of this function:</p>
<ul>
<li>It&#39;s triggered by HTTP POST request, as configured for <code>req</code> parameter</li>
<li>The request body is parsed to <code>GameRequest</code> type containing player name</li>
<li>It generates a new game ID</li>
<li>It creates initial game state of empty field</li>
<li>It serializes the state and saves it to Table Storage with <code>store</code> output binding</li>
<li>It returns HTTP body with 
<a href="https://github.com/mikhailshilkov/tictactoe/blob/master/TicTacToe.Functions/Api.fs#L30-L51">serialized</a> game response of type <code>GameDTO</code></li>
</ul>
<p>The second Function <code>Play</code> handles the moves:</p>
<pre><code class="language-fsharp">[&lt;FunctionName(&quot;Play&quot;)&gt;]
let play([&lt;HttpTrigger(AuthorizationLevel.Anonymous, &quot;POST&quot;, Route = &quot;game/{gameid}/move/{index}&quot;)&gt;] 
         req: HttpRequest, gameid: string, index: int,
         [&lt;Table(&quot;TicTacToe&quot;, &quot;default&quot;, &quot;{gameid}&quot;)&gt;] entity: GameEntity) =
  let state = JsonConvert.DeserializeObject&lt;GameState&gt; entity.State
  match state with
  | Finished _ -&gt; BadRequestResult() :&gt; IActionResult
  | InProgress p when index &lt; 0 || index &gt;= p.PossibleMoves.Length -&gt; BadRequestResult() :&gt; IActionResult
  | InProgress p -&gt; 
    let result = Game.makeRound (fun _ -&gt; p.PossibleMoves.[index]) Bot.pickMove p
    entity.State &lt;- JsonConvert.SerializeObject result
    entity.Score &lt;- Scoring.calculateScore (DateTime.UtcNow - entity.StartedAt).TotalMilliseconds result
    ObjectResult(Api.serialize gameid result entity.Score) :&gt; IActionResult</code></pre>
<p>The outline is very similar:</p>
<ul>
<li>It&#39;s triggered by a <code>POST</code> request with a URL template containing game ID and move index</li>
<li>It has an in/out Table Storage binding which reads the serialized state saved after previous
game and move requests</li>
<li>It validates the state: if the game is already finished, or if the move index is not in the valid range,
<code>Bad Request</code> HTTP status is returned</li>
<li>If the move is valid, it runs the round, including bot play</li>
<li>It also calculates the score, which is going to be non-zero only for finished games</li>
<li>The game state and the score are saved to Table Storage entity (that&#39;s the only mutation in the whole
application)</li>
</ul>
<h2 id="bot">Bot</h2>
<p>Azure Function above used a <code>Bot.pickMove</code> function which I haven&#39;t described yet.</p>
<p>This function has the type <code>RunningGame -&gt; Move</code>, exactly what is expected by <code>makeRound</code> game
function. Its goal is to pick the <code>O</code> move for any given game-in-progress.</p>
<p>Obviously, 3x3 Tic-Tac-Toe is a very simple game and it&#39;s quite easy to make a perfectly
playing bot. This wasn&#39;t the goal though: it&#39;s more fun for a human to win.</p>
<p>So, actually, the only property test that I ended up implementing is the following:</p>
<pre><code class="language-fsharp">testProp &quot;Bot is able to play O at any possible position&quot; &lt;| fun (Gen.ListOfNonNegative xs) -&gt;
  let human i p _ = p.PossibleMoves.[i % p.PossibleMoves.Length]
  let round s i =
    match s with
    | InProgress p -&gt; Game.makeRound (human i p) Bot.pickMove p
    | _ -&gt; s
  List.fold round (InProgress Game.initialState) xs |&gt; ignore     </code></pre>
<p>It makes sure that for any possible sequence of human moves, bot is actually able to make
<em>any</em> move of its own. Bot just shouldn&#39;t crash :)</p>
<p>My very first implementation of the bot was just picking a random move. Such bot is fine,
but it&#39;s too boring to play against.</p>
<p>So, my current bot implementation has 3 rules:</p>
<ul>
<li>If there is a move that immediately wins the game, do that move</li>
<li>If possible, don&#39;t pick a move which leads to immediate loss after the next human move</li>
<li>Otherwise, pick a random move</li>
</ul>
<p>I implemented the bot using the approach described in my 
<a href="https://mikhail.io/2016/07/building-a-poker-bot-functional-fold-as-decision-tree-pattern/">Functional Fold as Decision Tree Pattern</a>
post:</p>
<pre><code class="language-fsharp">let pickMove (game: RunningGame) = 
  [winNow O; notLoseNow; pickRandom]
  |&gt; Seq.ofList
  |&gt; Seq.choose (fun x -&gt; x game)
  |&gt; Seq.head</code></pre>
<p>So, there is a prioritized list of decision functions. The first one returning <code>Some</code>
decision will be promoted to final decision.</p>
<p>And here are those functions:</p>
<pre><code class="language-fsharp">let winNow player (game: RunningGame) =
  let isWin = function | Finished { Outcome = Won x } when x = player -&gt; true | _ -&gt; false
  game.PossibleMoves
  |&gt; List.tryFind (fun move -&gt; Game.makeMove game move |&gt; isWin)

let notLoseNow (game: RunningGame) =
  let canLose = function 
    | InProgress p -&gt; match winNow X p with | Some _ -&gt; true | None -&gt; false
    | _ -&gt; false
  let notLosingMoves =
    game.PossibleMoves
    |&gt; List.filter (fun move -&gt; Game.makeMove game move |&gt; canLose |&gt; not)
  if List.isEmpty notLosingMoves &amp;&amp; notLosingMoves.Length &lt; game.PossibleMoves.Length then None
  else Some (notLosingMoves.[random.Next notLosingMoves.Length])

let pickRandom (game: RunningGame) = 
  Some (game.PossibleMoves.[random.Next game.PossibleMoves.Length])</code></pre>
<p>Such rule-based setup is easy to extend, and also to test when it becomes needed.</p>
<h2 id="score-calculation">Score Calculation</h2>
<p>Last twist to the application is the scoring system. If a human player wins or gets a tie,
they are assigned a numeric score, which can be then compared to the historic leaderboard
of all players.</p>
<p>The score is calculated based on two principles: the less moves you make, and the faster
you play, the higher the score is. Move count is more important than timing.</p>
<p>These principles are nicely expressed as property tests:</p>
<pre><code class="language-fsharp">testProp &quot;The score of faster game is not lower than slower game&quot; 
  &lt;| fun (Gen.Positive duration1) (Gen.Positive duration2) game -&gt;
  let (slower, faster) = maxmin id duration1 duration2
  let scoreFaster = Scoring.calculateScore faster game
  let scoreSlower = Scoring.calculateScore slower game
  Expect.isGreaterThanOrEqual scoreFaster scoreSlower &quot;Bigger duration has lower score (or same)&quot;

testProp &quot;The score of won game in less moves is greater than game with more moves&quot; 
  &lt;| fun (Gen.Positive duration1) (Gen.Positive duration2) game1 game2 -&gt;
  let (slower, faster) = maxmin id duration1 duration2
  let (moreMoves, lessMoves) = maxmin List.length game1 game2
  let score1 = Scoring.calculateScore slower (Finished { Outcome = Won X; MovesDone = lessMoves })
  let score2 = Scoring.calculateScore faster (Finished { Outcome = Won X; MovesDone = moreMoves })
  if moreMoves.Length = lessMoves.Length then
    Expect.isGreaterThanOrEqual score1 score2 &quot;Bigger duration has lower score (or same)&quot;
  else
    Expect.isGreaterThan score1 score2 &quot;More moves have lower score&quot;</code></pre>
<p>Note that tests are parameterized for durations and game states. We don&#39;t have to come up with specific
scenarios: the framework should take care of those.</p>
<p>One of the possible implementations for scoring is:</p>
<pre><code class="language-fsharp">let calculateScore duration (state: GameState) =
  let durationScore = (100.0 * (1.0 - duration / (duration + 10000.0))) |&gt; int
  match state with
  | Finished { Outcome = Won X; MovesDone = ms } -&gt; (11 - ms.Length) * 100 + durationScore
  | Finished { Outcome = Tie } -&gt; durationScore
  | _ -&gt; 0</code></pre>
<p>Now, the leaderboard piece. You&#39;ve already seen the bits of this functionality in Azure Functions: 
they store the game state into Azure Table Storage.</p>
<p>There is another Azure Function which handles <code>GET</code> requests to <code>/leaderboard</code> resource. It
loads all the past games from Table Storage, and then passes them to leaderboard calculation
function below:</p>
<pre><code class="language-fsharp">let calculateLeaderboard top ns =
  ns
  |&gt; Seq.filter (fun entity -&gt; snd entity &gt; 0 &amp;&amp; not (String.IsNullOrEmpty (fst entity)))
  |&gt; Seq.sortByDescending snd
  |&gt; Seq.truncate top
  |&gt; Seq.mapi (fun index entity -&gt; { Index = index + 1; Name = fst entity; Score = snd entity })</code></pre>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Ok, the application is simple, but the blog post ended up being quite long. Thank you if you
made it so far.</p>
<p>I touched base on several important concepts and tools, which can be useful apart or in
combination.</p>
<p>Please leave a comment if such kind of articles is useful, and which part you found most
inspirational or boring.</p>
<p>The full source code can be found in <a href="https://github.com/mikhailshilkov/tictactoe">my github</a>.</p>
<p>Happy coding!</p>
]]></content>
    </entry>
    
</feed>