<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>

    <meta name="description" content="Software development using .NET, C#, SQL, Javascript and related technologies" />

    <title>Monads explained in C# (again) | Mikhail Shilkov</title>
    <meta name="author" content="Mikhail Shilkov">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="twitter:card" content="summary"></meta>
    <meta name="twitter:creator" content="@MikhailShilkov"></meta>

    <meta property="og:type" content="article" />
    <meta property="og:title" content="Monads explained in C# (again)" />
    <meta property="og:url" content="https://mikhail.io/2018/07/monads-explained-in-csharp-again/" />

    <meta property="og:image" content="https://mikhail.io/2018/07/monads-explained-in-csharp-again/teaser.png" />


    <meta property="og:description" content="Yet another Monad tutorial, this time for C# OOP developers" />


    <link href="/feed/" rel="alternate" title="mikhail.io" type="application/atom+xml">
    <link href="/favicon.ico?v=2" rel="shortcut icon">

    <!-- Bootstrap -->
    <link href="/styles/site.css" rel="stylesheet" media="screen">
    <link href="/vendor/prism.css" rel="stylesheet" media="screen">

    <meta name="generator" content="DocPad v6.78.6" />
    
</head>
<body>

<div class="navbar navbar-default navbar-static-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
                <span class="text-primary">Mikhail Shilkov</span><br />
                <span class="elevator-pitch">Serverless, Azure, FP, F# and more</span>
            </a>
        </div>
        <div class="collapse navbar-collapse navbar-right">
            <ul class="nav navbar-nav">
                <!--<li><a href="/">Blog</a></li>-->
                
                    <li><a href="/tags/">Topics</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/talks/">Talks</a></li>
                
                    <li><a href="/about/">About</a></li>
                
                <li class="hidden-xs">
                    <a href="/feed/" class="rss"><span class="icon icon-feed"></span></a>
                    <a href="https://www.linkedin.com/in/mikhailshilkov" class="linkedin"><span class="icon icon-linkedin"></span></a>
                    <a href="https://twitter.com/mikhailshilkov" class="twitter"><span class="icon icon-twitter"></span></a>
                    <a href="https://github.com/mikhailshilkov" class="github"><span class="icon icon-github"></span></a>
                </li>
            </ul>
            <form class="navbar-form navbar-right hidden-xs" role="search" action="https://google.com/search"
                  method="get">
                <div class="form-group">
                    <input type="search" name="q" class="form-control" placeholder="Search">
                    <input type="hidden" name="q" value="site:mikhail.io">
                </div>
            </form>
        </div>
    </div>
</div>
<div class="container">
    <article class="post">
    <div class="post-date">Jul 5th, 2018</div>
    
    <h1>Monads explained in C# (again)</h1>
    
    <div class="post-content">
        <p>I love functional programming for the simplicity that it brings.</p>
<p>But at the same time, I realize that learning functional programming is a challenging 
process. FP comes with a baggage of unfamiliar vocabulary that can be daunting for 
somebody coming from an object-oriented language like C#.</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//functional-programming-word-cloud.png" alt="Functional Programming Word Cloud"></p>
<p><em>Some of functional lingo</em></p>
<p>&quot;Monad&quot; is probably the most infamous term from the list above. Monads have reputation of being 
something very abstract and very confusing. </p>
<h2 id="the-fallacy-of-monad-tutorials">The Fallacy of Monad Tutorials</h2>
<p>Numerous attempts were made to explain monads in simple definitions; and monad tutorials have become a
genre of its own. And yet, times and times again, they fail to enlighten the readers.</p>
<p>The shortest explanation of monads looks like this:</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//monoid-endofunctors.png" alt="A Monad is just a monoid in the category of endofunctors"></p>
<p>It&#39;s both mathematically correct and totally useless to anybody learning functional programming. To
understand this statement, one has to know the terms &quot;monoid&quot;, &quot;category&quot; and &quot;endofunctors&quot; and be able
to mentally compose them into something meaningful.</p>
<p>The same problem is apparent in most monad tutorials. They assume some pre-existing knowledge in
heads of their readers, and if that assumption fails, the tutorial doesn&#39;t click.</p>
<p>Focusing too much on mechanics of monads instead of explaining why they are important is another
common problem.</p>
<p>Douglas Crockford grasped this fallacy very well:</p>
<blockquote>
<p>The monadic curse is that once someone learns what monads are and how to use them, they lose the ability to explain them to other people</p>
</blockquote>
<p>The problem here is likely the following. Every person who understands monads had their own path to
this knowledge. It hasn&#39;t come all at once, instead there was a series of steps, each giving an insight,
until the last final step made the puzzle complete.</p>
<p>But they don&#39;t remember the whole path anymore. They go online and blog about that very last step as
the key to understanding, joining the club of flawed explanations.</p>
<p>There is an actual <a href="http://tomasp.net/academic/papers/monads/monads-programming.pdf">academic paper from Tomas Petricek</a> 
that studies monad tutorials.</p>
<p>I&#39;ve read that paper and a dozen of monad tutorials online. And of course, now I came up with my own.</p>
<p>I&#39;m probably doomed to fail too, at least for some readers. Yet, I know that many people found the
<a href="https://mikhail.io/2016/01/monads-explained-in-csharp/">previous version</a> of this article useful.</p>
<p>I based my explanation on examples from C# - the object-oriented language familiar to .NET developers.</p>
<h2 id="story-of-composition">Story of Composition</h2>
<p>The base element of each functional program is Function. In typed languages each function 
is just a mapping between the type of its input parameter and output parameter.
Such type can be annotated as <code>func: TypeA -&gt; TypeB</code>.</p>
<p>C# is object-oriented language, so we use methods to declare functions. There are two ways 
to define a method comparable to <code>func</code> function above. I can use static method:</p>
<pre><code class="lang-csharp">static class Mapper 
{
    static ClassB func(ClassA a) { ... }
}
</code></pre>
<p>... or instance method:</p>
<pre><code class="lang-csharp">class ClassA 
{
    // Instance method
    ClassB func() { ... }
}
</code></pre>
<p>Static form looks closer to the function annotation, but both ways are actually equivalent
for the purpose of our discussion. I will use instance methods in my examples, however all of
them could be written as static extension methods too.</p>
<p>How do we compose more complex workflows, programs and applications out of such simple
building blocks? A lot of patterns both in OOP and FP worlds revolve around this question.
And monads are one of the answers.</p>
<p>My sample code is going to be about conferences and speakers. The method implementations 
aren&#39;t really important, just watch the types carefully. There are 4 classes (types) and 
3 methods (functions):</p>
<pre><code class="lang-csharp">class Speaker 
{
    Talk NextTalk() { ... }
}

class Talk 
{
    Conference GetConference() { ... }
}

class Conference 
{
    City GetCity() { ... }
}

class City { ... }
</code></pre>
<p>These methods are currently very easy to compose into a workflow:</p>
<pre><code class="lang-csharp">static City NextTalkCity(Speaker speaker) 
{
    Talk talk = speaker.NextTalk();
    Conference conf = talk.GetConference();
    City city = conf.GetCity();
    return city;
}
</code></pre>
<p>Because the return type of the previous step always matches the input type of the next step, we can
write it even shorter:</p>
<pre><code class="lang-csharp">static City NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()
        .GetConference()
        .GetCity();
}
</code></pre>
<p>This code looks quite readable. It&#39;s concise and it flows from top to bottom, from left to right, 
similar to how we are used to read any text. There is not much noise too.</p>
<p>That&#39;s not what real codebases look like though, because there are multiple complications
along the happy composition path. Let&#39;s look at some of them.</p>
<h2 id="nulls">NULLs</h2>
<p>Any class instance in C# can be <code>null</code>. In the example above I might get runtime errors if
one of the methods ever returns <code>null</code> back.</p>
<p>Typed functional programming always tries to be explicit about types, so I&#39;ll re-write the signatures
of my methods to annotate the return types as nullables:</p>
<pre><code class="lang-csharp">class Speaker 
{
    Nullable&lt;Talk&gt; NextTalk() { ... }
}

class Talk 
{
    Nullable&lt;Conference&gt; GetConference() { ... }
}

class Conference 
{
    Nullable&lt;City&gt; GetCity() { ... }
}

class City { ... }
</code></pre>
<p>This is actually invalid syntax in current C# version, because <code>Nullable&lt;T&gt;</code> and its short form
<code>T?</code> are not applicable to reference types. This <a href="https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/">might change in C# 8</a>
though, so bear with me.</p>
<p>Now, when composing our workflow, we need to take care of <code>null</code> results:</p>
<pre><code class="lang-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    Nullable&lt;Talk&gt; talk = speaker.NextTalk();
    if (talk == null) return null;

    Nullable&lt;Conference&gt; conf = talk.GetConference();
    if (conf == null) return null;

    Nullable&lt;City&gt; city = conf.GetCity();
    return city;
}
</code></pre>
<p>It&#39;s still the same method, but it got more noise now. Even though I used short-circuit returns
and one-liners, it still got harder to read.</p>
<p>To fight that problem, smart language designers came up with the Null Propagation Operator:</p>
<pre><code class="lang-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        ?.NextTalk()
        ?.GetConference()
        ?.GetCity();
}
</code></pre>
<p>Now we are almost back to our original workflow code: it&#39;s clean and concise, we just got
3 extra <code>?</code> symbols around.</p>
<p>Let&#39;s take another leap.</p>
<h2 id="collections">Collections</h2>
<p>Quite often a function returns a collection of items, not just a single item. To some extent,
that&#39;s a generalization of <code>null</code> case: with <code>Nullable&lt;T&gt;</code> we might get 0 or 1 results back,
while with a collection we can get <code>0</code> to any <code>n</code> results.</p>
<p>Our sample API could look like this:</p>
<pre><code class="lang-csharp">class Speaker 
{
    List&lt;Talk&gt; GetTalks() { ... }
}

class Talk 
{
    List&lt;Conference&gt; GetConferences() { ... }
}

class Conference 
{
    List&lt;City&gt; GetCities() { ... }
}
</code></pre>
<p>I used <code>List&lt;T&gt;</code> but it could be any class or plain <code>IEnumerable&lt;T&gt;</code> interface.</p>
<p>How would we combine the methods into one workflow? Traditional version would look like this:</p>
<pre><code class="lang-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    var result = new List&lt;City&gt;();

    foreach (Talk talk in speaker.GetTalks())
        foreach (Conference conf in talk.GetConferences())
            foreach (City city in conf.GetCities())
                result.Add(city);

    return result;
}
</code></pre>
<p>It reads ok-ish still. But the combination of nested loops and mutation with some conditionals sprinkled 
on them can get unreadable pretty soon. The exact workflow might be lost in the mechanics.</p>
<p>As an alternative, C# language designers invented LINQ extension methods. We can write code like this:</p>
<pre><code class="lang-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()
        .SelectMany(talk =&gt; talk.GetConferences())
        .SelectMany(conf =&gt; conf.GetCities())
        .ToList();
}
</code></pre>
<p>Let me do one further trick and format the same code in an unusual way:</p>
<pre><code class="lang-csharp">static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()           .SelectMany(x =&gt; x
        .GetConferences()    ).SelectMany(x =&gt; x
        .GetCities()         ).ToList();
}
</code></pre>
<p>Now you can see the same original code on the left, combined with just a bit of technical repeatable
clutter on the right. Hold on, I&#39;ll show you where I&#39;m going.</p>
<p>Let&#39;s discuss another possible complication.</p>
<h2 id="asynchronous-calls">Asynchronous Calls</h2>
<p>What if our methods need to access some remote database or service to produce the results? This
should be shown in type signature, and C# has <code>Task&lt;T&gt;</code> for that:</p>
<pre><code class="lang-csharp">class Speaker 
{
    Task&lt;Talk&gt; NextTalk() { ... }
}

class Talk 
{
    Task&lt;Conference&gt; GetConference() { ... }
}

class Conference 
{
    Task&lt;City&gt; GetCity() { ... }
}
</code></pre>
<p>This change breaks our nice workflow composition again.</p>
<p>We&#39;ll get back to async-await later, but the original way to combine <code>Task</code>-based
methods was to use <code>ContinueWith</code> and <code>Unwrap</code> API:</p>
<pre><code class="lang-csharp">static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()
        .ContinueWith(talk =&gt; talk.Result.GetConference())
        .Unwrap()
        .ContinueWith(conf =&gt; conf.Result.GetCity())
        .Unwrap();
}
</code></pre>
<p>Hard to read, but let me apply my formatting trick again:</p>
<pre><code class="lang-csharp">static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()         .ContinueWith(x =&gt; x.Result
        .GetConference()   ).Unwrap().ContinueWith(x =&gt; x.Result
        .GetCity()         ).Unwrap();
}
</code></pre>
<p>You can see that, once again, it&#39;s our nice readable workflow on the left + some mechanical repeatable
junction code on the right.</p>
<h2 id="pattern">Pattern</h2>
<p>Can you see a pattern yet?</p>
<p>I&#39;ll repeat the <code>Nullable</code>-, <code>List</code>- and <code>Task</code>-based workflows again:</p>
<pre><code class="lang-csharp">static Nullable&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker               ?
        .NextTalk()           ?
        .GetConference()      ?
        .GetCity();
}

static List&lt;City&gt; AllCitiesToVisit(Speaker speaker) 
{
    return 
        speaker
        .GetTalks()            .SelectMany(x =&gt; x
        .GetConferences()     ).SelectMany(x =&gt; x
        .GetCities()          ).ToList();
}

static Task&lt;City&gt; NextTalkCity(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()            .ContinueWith(x =&gt; x.Result
        .GetConference()      ).Unwrap().ContinueWith(x =&gt; x.Result
        .GetCity()            ).Unwrap();
}
</code></pre>
<p>In all 3 cases there was a complication which prevented us from sequencing method
calls fluently. In all 3 cases we found the gluing code to get back to fluent composition.</p>
<p>Let&#39;s try to generalize this approach. Given some generic container type 
<code>WorkflowThatReturns&lt;T&gt;</code>, we have a method to combine an instance of such workflow with
a function which accepts the result of that workflow and returns another workflow back:</p>
<pre><code class="lang-csharp">class WorkflowThatReturns&lt;T&gt; 
{
    WorkflowThatReturns&lt;U&gt; AddStep(Func&lt;T, WorkflowThatReturns&lt;U&gt;&gt; step);
}
</code></pre>
<p>In case this is hard to grasp, have a look at the picture of what is going on:</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//monad-bind.png" alt="Monad Bind Internals"></p>
<ol>
<li><p>An instance of type <code>T</code> sits in a generic container.</p>
</li>
<li><p>We call <code>AddStep</code> with a function, which maps <code>T</code> to <code>U</code> sitting inside yet another
container. </p>
</li>
<li><p>We get an instance of <code>U</code> but inside two containers.</p>
</li>
<li><p>Two containers are automatically unwrapped into a single container to get back to the
original shape.</p>
</li>
<li><p>Now we are ready to add another step!</p>
</li>
</ol>
<p>In the following code, <code>NextTalk</code> returns the first instance inside the container:</p>
<pre><code class="lang-csharp">WorkflowThatReturns&lt;City&gt; Workflow(Speaker speaker) 
{
    return 
        speaker
        .NextTalk()         
        .AddStep(x =&gt; x.GetConference())
        .AddStep(x =&gt; x.GetCity()); 
}
</code></pre>
<p>Subsequently, <code>AddStep</code> is called two times to transfer to <code>Conference</code> and then
<code>City</code> inside the same container:</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//monad-two-binds.png" alt="Monad Bind Chaining"></p>
<h2 id="finally-monads">Finally, Monads</h2>
<p>The name of this pattern is <strong>Monad</strong>.</p>
<p>In C# terms, a Monad is a generic class with two operations: constructor and bind.</p>
<pre><code class="lang-csharp">class Monad&lt;T&gt; {
    Monad(T instance);
    Monad&lt;U&gt; Bind(Func&lt;T, Monad&lt;U&gt;&gt; f);
}
</code></pre>
<p>Constructor is used to put an object into container, <code>Bind</code> is used to replace one
contained object with another contained object.</p>
<p>It&#39;s important that <code>Bind</code>&#39;s argument returns <code>Monad&lt;U&gt;</code> and not just <code>U</code>. We can think
of <code>Bind</code> as a combination of <code>Map</code> and <code>Unwrap</code> as defined per following signature:</p>
<pre><code class="lang-csharp">class Monad&lt;T&gt; {
    Monad(T instance);
    Monad&lt;U&gt; Map(Function&lt;T, U&gt; f);
    static Monad&lt;U&gt; Unwrap(Monad&lt;Monad&lt;U&gt;&gt; nested);
}
</code></pre>
<p>Even though I spent quite some time with examples, I expect you to be slightly confused
at this point. That&#39;s ok.</p>
<p>Keep going and let&#39;s have a look at several sample implementations of Monad pattern.</p>
<p><a name="maybe" href="/2018/07/monads-explained-in-csharp-again/undefined"></a></p>
<h2 id="maybe-option-">Maybe (Option)</h2>
<p>My first motivational example was with <code>Nullable&lt;T&gt;</code> and <code>?.</code>. The full pattern
containing either 0 or 1 instance of some type is called <code>Maybe</code> (it maybe has a value,
or maybe not).</p>
<p><code>Maybe</code> is another approach to dealing with &#39;no value&#39; value, alternative to the 
concept of <code>null</code>. </p>
<p>Functional-first language F# typically doesn&#39;t allow <code>null</code> for its types. Instead, F# has 
a maybe implementation built into the language: 
it&#39;s called <code>option</code> type. </p>
<p>Here is a sample implementation in C#:</p>
<pre><code class="lang-csharp">public class Maybe&lt;T&gt; where T : class
{
    private readonly T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new ArgumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe&lt;U&gt; Bind&lt;U&gt;(Func&lt;T, Maybe&lt;U&gt;&gt; func) where U : class
    {
        return value != null ? func(value) : Maybe&lt;U&gt;.None();
    }

    public static Maybe&lt;T&gt; None() =&gt; new Maybe&lt;T&gt;();
}
</code></pre>
<p>When <code>null</code> is not allowed, any API contract gets more explicit: either you
return type <code>T</code> and it&#39;s always going to be filled, or you return <code>Maybe&lt;T&gt;</code>.
The client will see that <code>Maybe</code> type is used, so it will be forced to handle 
the case of absent value.</p>
<p>Given an imaginary repository contract (which does something with customers and
orders):</p>
<pre><code class="lang-csharp">public interface IMaybeAwareRepository
{
    Maybe&lt;Customer&gt; GetCustomer(int id);
    Maybe&lt;Address&gt; GetAddress(int id);
    Maybe&lt;Order&gt; GetOrder(int id);
}
</code></pre>
<p>The client can be written with <code>Bind</code> method composition, without branching, 
in fluent style:</p>
<pre><code class="lang-csharp">Maybe&lt;Shipper&gt; shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c =&gt; c.Address)
        .Bind(a =&gt; repo.GetAddress(a.Id))
        .Bind(a =&gt; a.LastOrder)
        .Bind(lo =&gt; repo.GetOrder(lo.Id))
        .Bind(o =&gt; o.Shipper);
</code></pre>
<p>As we saw above, this syntax looks very much like a LINQ query with a bunch 
of <code>SelectMany</code> statements. One of the common 
implementations of <code>Maybe</code> implements <code>IEnumerable</code> interface to enable
a more C#-idiomatic binding composition. Actually:</p>
<h2 id="enumerable-selectmany-is-a-monad-">Enumerable + SelectMany is a Monad </h2>
<p><code>IEnumerable</code> is an interface for enumerable containers.</p>
<p>Enumerable containers can be created - thus the constructor monadic operation.</p>
<p>The <code>Bind</code> operation is defined by the standard LINQ extension method, here 
is its signature:</p>
<pre><code class="lang-csharp">public static IEnumerable&lt;U&gt; SelectMany&lt;T, U&gt;(
    this IEnumerable&lt;T&gt; first, 
    Func&lt;T, IEnumerable&lt;U&gt;&gt; selector)
</code></pre>
<p>Direct implementation is quite straightforward:</p>
<pre><code class="lang-csharp">static class Enumerable 
{
    public static IEnumerable&lt;U&gt; SelectMany(
        this IEnumerable&lt;T&gt; values, 
        Func&lt;T, IEnumerable&lt;U&gt;&gt; func) 
    { 
        foreach (var item in values)
            foreach (var subItem in func(item))
                yield return subItem;
    }
}
</code></pre>
<p>And here is an example of composition:</p>
<pre><code class="lang-csharp">IEnumerable&lt;Shipper&gt; shippers =
    customers
        .SelectMany(c =&gt; c.Addresses)
        .SelectMany(a =&gt; a.Orders)
        .SelectMany(o =&gt; o.Shippers);
</code></pre>
<p>The query has no idea about how the collections are stored (encapsulated in
containers). We use functions <code>T -&gt; IEnumerable&lt;U&gt;</code> to produce new enumerables
(<code>Bind</code> operation).</p>
<h2 id="task-future-">Task (Future)</h2>
<p>In C# <code>Task&lt;T&gt;</code> type is used to denote asynchronous computation which will eventually
return an instance of <code>T</code>. The other names for similar concepts in other languages
are <code>Promise</code> and <code>Future</code>.</p>
<p>While the typical usage of <code>Task</code> in C# is different from the Monad pattern we
discussed, I can still come up with a <code>Future</code> class with the familiar structure:</p>
<pre><code class="lang-csharp">public class Future&lt;T&gt;
{
    private readonly Task&lt;T&gt; instance;

    public Future(T instance)
    {
        this.instance = Task.FromResult(instance);
    }

    private Future(Task&lt;T&gt; instance)
    {
        this.instance = instance;
    }

    public Future&lt;U&gt; Bind&lt;U&gt;(Func&lt;T, Future&lt;U&gt;&gt; func)
    {
        var a = this.instance.ContinueWith(t =&gt; func(t.Result).instance).Unwrap();
        return new Future&lt;U&gt;(a);
    }

    public void OnComplete(Action&lt;T&gt; action)
    {
        this.instance.ContinueWith(t =&gt; action(t.Result));
    }
}
</code></pre>
<p>Effectively, it&#39;s just a wrapper around the <code>Task</code> which doesn&#39;t add too much value,
but it&#39;s a useful illustration because now we can do:</p>
<pre><code class="lang-csharp">repository
    .LoadSpeaker()
    .Bind(speaker =&gt; speaker.NextTalk())
    .Bind(talk =&gt; talk.GetConference())
    .Bind(conference =&gt; conference.GetCity())
    .OnComplete(city =&gt; reservations.BookFlight(city));
</code></pre>
<p>We are back to the familiar structure. Time for some more complications.</p>
<h2 id="non-sequential-workflows">Non-Sequential Workflows</h2>
<p>Up until now, all the composed workflows had very liniar, sequential
structure: the output of a previous step was always the input for the next step.
That piece of data could be discarded after the first use because it was never needed 
for later steps:</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//linear-workflow.png" alt="Linear Workflow"></p>
<p>Quite often though, this might not be the case. A workflow step might need data
from two or more previous steps combined.</p>
<p>In the example above, <code>BookFlight</code> method might actually need both <code>Speaker</code> and
<code>City</code> objects:</p>
<p><img src="/2018/07/monads-explained-in-csharp-again//non-linear-workflow.png" alt="Non Linear Workflow"></p>
<p>In this case, we would have to use closure to save <code>speaker</code> object until we get
a <code>talk</code> too:</p>
<pre><code class="lang-csharp">repository
    .LoadSpeaker()
    .OnComplete(speaker =&gt;
        speaker
            .NextTalk()
            .Bind(talk =&gt; talk.GetConference())
            .Bind(conference =&gt; conference.GetCity())
            .OnComplete(city =&gt; reservations.BookFlight(speaker, city))
        );
</code></pre>
<p>Obviously, this gets ugly very soon.</p>
<p>To solve this structural problem, C# language got its <code>async</code>-<code>await</code> feature,
which is now being reused in more languages including Javascript.</p>
<p>If we move back to using <code>Task</code> instead of our custom <code>Future</code>, we are able to
write</p>
<pre><code class="lang-csharp">var speaker = await repository.LoadSpeaker();
var talk = await speaker.NextTalk();
var conference = await talk.GetConference();
var city = await conference.GetCity();
await reservations.BookFlight(speaker, city);
</code></pre>
<p>Even though we lost the fluent syntax, at least the block has just one level,
which makes it easier to navigate.</p>
<h2 id="monads-in-functional-languages">Monads in Functional Languages</h2>
<p>So far we learned that</p>
<ul>
<li>Monad is a workflow composition pattern</li>
<li>This pattern is used in functional programming</li>
<li>Special syntax helps simplify the usage</li>
</ul>
<p>It should come at no surprise that functional languages support monads on syntactic
level.</p>
<p>F# is a functional-first language running on .NET framework. F# had its own way of
doing workflows comparable to <code>async</code>-<code>await</code> before C# got it. In F#, the above
code would look like this:</p>
<pre><code class="lang-fsharp">let sendReservation () = async {
    let! speaker = repository.LoadSpeaker()
    let! talk = speaker.nextTalk()
    let! conf = talk.getConference()
    let! city = conf.getCity()
    do! bookFlight(speaker, city)
}
</code></pre>
<p>Apart from syntax (<code>!</code> instead of <code>await</code>), the major difference to C# is that
<code>async</code> is just one possible monad type to be used this way. There are many
other monads in F# standard library (they are called Computation Expressions).</p>
<p>The best part is that any developer can create their own monads, and then use
all the power of language features.</p>
<p>Say, we want a hand-made <code>Maybe</code> computation expressoin in F#:</p>
<pre><code class="lang-fsharp">let nextTalkCity (speaker: Speaker) = maybe {
    let! talk = speaker.nextTalk()
    let! conf = talk.getConference()
    let! city = conf.getCity(talk)
    return city
}
</code></pre>
<p>To make this code runnable, we need to define Maybe computation expression
builder:</p>
<pre><code class="lang-fsharp">type MaybeBuilder() =

    member this.Bind(x, f) = 
        match x with
        | None -&gt; None
        | Some a -&gt; f a

    member this.Return(x) = 
        Some x

let maybe = new MaybeBuilder()
</code></pre>
<p>I won&#39;t explain the details of what happens here, but you can see that the code is
quite trivial. Note the presence of <code>Bind</code> operation (and <code>Return</code> operation being
the monad constructor).</p>
<p>The feature is widely used by third-party F# libraries. Here is an actor definition
in Akka.NET F# API:</p>
<pre><code class="lang-fsharp">let loop () = actor {
    let! message = mailbox.Receive()
    match message with
    | Greet(name) -&gt; printfn &quot;Hello %s&quot; name
    | Hi -&gt; printfn &quot;Hello from F#!&quot;
    return! loop ()
}
</code></pre>
<h2 id="monad-laws">Monad Laws</h2>
<p>There are a couple laws that constructor and <code>Bind</code> need to adhere to, so
that they produce a proper monad.</p>
<p>A typical monad tutorial will make a lot of emphasis on the laws, but I find them
less important to explain to a beginner. Nonetheless, here they are for the sake
of completeness.</p>
<p><strong>Left Identity law</strong> says that that Monad constructor is a neutral operation: you can safely
run it before <code>Bind</code>, and it won&#39;t change the result of the function call:</p>
<pre><code class="lang-csharp">// Given
T value;
Func&lt;T, Monad&lt;U&gt;&gt; f;

// Then (== means both parts are equivalent)
new Monad&lt;T&gt;(value).Bind(f) == f(value)
</code></pre>
<p><strong>Right Identity law</strong> says that given a monadic value, wrapping its contained data
into another monad of same type and then <code>Bind</code>ing it, doesn&#39;t change the original value:</p>
<pre><code class="lang-csharp">// Given
Monad&lt;T&gt; monadicValue;

// Then (== means both parts are equivalent)
monadicValue.Bind(x =&gt; new Monad&lt;T&gt;(x)) == monadicValue
</code></pre>
<p><strong>Associativity law</strong> means that the order in which <code>Bind</code> operations
are composed does not matter:</p>
<pre><code class="lang-csharp">// Given
Monad&lt;T&gt; m;
Func&lt;T, Monad&lt;U&gt;&gt; f;
Func&lt;U, Monad&lt;V&gt;&gt; g;

// Then (== means both parts are equivalent)
m.Bind(f).Bind(g) == m.Bind(a =&gt; f(a).Bind(g))
</code></pre>
<p>The laws may look complicated, but in fact they are very natural 
expectations that any developer has when working with monads, so don&#39;t
spend too much mental effort on memorizing them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>You should not be afraid of the &quot;M-word&quot; just because you are a C# programmer. </p>
<p>C# does not have a notion of monads as predefined language constructs, but 
that doesn&#39;t mean we can&#39;t borrow some ideas from the functional world. Having 
said that, it&#39;s also true that C# is lacking some powerful ways to combine 
and generalize monads that are available in functional programming
languages.</p>
<p>Go learn some more Functional Programming!</p>

    </div>

    
    <p>
      Like this post? Please share it!<br />
      <table>
        <tr>
          <td>
            <a href="https://twitter.com/share" class="twitter-share-button" data-via="MikhailShilkov">Tweet</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
          </td>
          <td>
            <a href="http://news.ycombinator.com/submit" class="hn-share-button" style="height: 28px">Vote on HN</a>
            <script src="//hnbutton.appspot.com/static/hn.min.js" async defer></script>
          </td>
          <td style="vertical-align: top; padding-top: 3px">
            <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent(window.location); return false"> <img src="//www.redditstatic.com/spreddit7.gif" alt="submit to reddit" border="0" width="75" /> </a>
          </td>
        </tr>
      </table>
    </p>

    See a mistake? <a href="https://github.com/mikhailshilkov/mikhailio-docpad/edit/master/src/documents/2018/07/monads-explained-in-csharp-again//index.html.md">Edit this post!</a><br />
    

    
    <div class="post-tags">
        Posted In: <a href='/tags/functional-programming/'>Functional Programming</a>, <a href='/tags/monads/'>Monads</a>, <a href='/tags/maybe/'>Maybe</a>, <a href='/tags/linq/'>LINQ</a>, <a href='/tags/c#/'>C#</a>, <a href='/tags/f#/'>F#</a>
    </div>
    
</article>
    <div id="me">
    <p itemscope itemtype="http://data-vocabulary.org/Person">
        <img src="/images/Headshot-Square.jpg" alt="Mikhail Shilkov" itemprop="photo" />
        I'm <b><span itemprop="name">Mikhail Shilkov</span></b>, a <span itemprop="title">software developer</span>. I enjoy F#, C#, Javascript and SQL development, reasoning about distributed systems, data processing pipelines, cloud and web apps. I blog about my experience on this website.
    </p>
    <p>
        <a href="https://www.linkedin.com/in/mikhailshilkov/">LinkedIn</a> &#8226;
        <a href="https://twitter.com/mikhailshilkov">@mikhailshilkov</a> &#8226;
        <a href="https://github.com/mikhailshilkov">GitHub</a> &#8226;
        <a href="https://stackoverflow.com/users/1171619/mikhail">Stack Overflow</a>
    </p>
</div>

    <div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments.</a></noscript></div>
<script type="text/javascript">
    var disqus_shortname = 'mikhailio';
    var disqus_url = 'https://mikhail.io/2018/07/monads-explained-in-csharp-again/';
    var disqus_identifier = disqus_url;
    var disqus_title = 'Monads explained in C# (again)';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

</div>
<div class="container">
    <div class="navbar navbar-footer">
        <p class="navbar-center navbar-text">Content copyright &copy; 2018 Mikhail Shilkov</p>
    </div>
</div>



<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
<script src="/vendor/prism.js"></script>
<script src="/site.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59218480-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>