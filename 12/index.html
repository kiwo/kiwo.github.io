<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>

    <meta name="description" content="Software development using .NET, C#, SQL, Javascript and related technologies" />

    <title>Mikhail Shilkov</title>
    <meta name="author" content="Mikhail Shilkov">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="twitter:card" content="summary_large_image"></meta>
    <meta name="twitter:creator" content="@MikhailShilkov"></meta>
    <meta name="twitter:title" content="Mikhail Shilkov"></meta>

    <meta property="og:type" content="article" />
    <meta property="og:title" content="Mikhail Shilkov" />
    <meta property="og:url" content="https://mikhail.io/12/index.html" />




    <link href="/feed/" rel="alternate" title="mikhail.io" type="application/atom+xml">
    <link href="/favicon.ico?v=2" rel="shortcut icon">

    <!-- Bootstrap -->
    <link href="/vendor/prism.css" rel="stylesheet" media="screen">
    <link href="/styles/site.css" rel="stylesheet" media="screen">

    <meta name="generator" content="DocPad v6.80.6" />
    
</head>
<body>

<div class="navbar navbar-default navbar-static-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
                <span class="text-primary">Mikhail Shilkov</span><br />
                <span class="elevator-pitch">Serverless, Azure, FP, F# and more</span>
            </a>
        </div>
        <div class="collapse navbar-collapse navbar-right">
            <ul class="nav navbar-nav">
                <!--<li><a href="/">Blog</a></li>-->
                
                    <li><a href="/tags/">Topics</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/talks/">Talks</a></li>
                
                    <li><a href="/about/">About</a></li>
                
                <li class="hidden-xs">
                    <a href="/feed/" class="rss"><span class="icon icon-feed"></span></a>
                    <a href="https://www.linkedin.com/in/mikhailshilkov" class="linkedin"><span class="icon icon-linkedin"></span></a>
                    <a href="https://twitter.com/mikhailshilkov" class="twitter"><span class="icon icon-twitter"></span></a>
                    <a href="https://github.com/mikhailshilkov" class="github"><span class="icon icon-github"></span></a>
                </li>
            </ul>
            <form class="navbar-form navbar-right hidden-xs" role="search" action="https://google.com/search"
                  method="get">
                <div class="form-group">
                    <input type="search" name="q" class="form-control" placeholder="Search">
                    <input type="hidden" name="q" value="site:mikhail.io">
                </div>
            </form>
        </div>
    </div>
</div>
<div class="container">
    
    <article class="post">
    <div class="post-date">Feb 1st, 2016</div>
    
    <h1><a href='/2016/02/building-a-poker-bot-card-recognition/'>Building a Poker Bot: Card Recognition</a></h1>
    

    

    <div class="post-content">
        <p><em>This is the first part of <strong>Building a Poker Bot</strong> series where I describe my experience developing bot software 
for online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable.</em></p>
<h2 id="screen-recognition">Screen recognition</h2>
<p>For a human, the very first step to the ability to play poker is to understand the cards, what a hand is and 
what the value of your hand is. E.g. in Texas Holdem each player gets 2 hole cards which form a hand. At 
the showdown the player with the best hand wins.</p>
<p>Poker bots are no different, they also need to be taught the notion of cards and hands. A bot should &quot;watch&quot; 
the table and see which cards he is dealt with. There are several ways to achieve that but I go for a technique
called screen recognition, i.e. the bot makes a screenshot of a table and then reads the pixels to understand
what&#39;s going on. Very similar to what people do.</p>
<p>Image recognition in general is a tough task. Human beings are very good at interpreting vague images and
recognizing familiar objects. It&#39;s much more difficult for computers. General image recognition (think showing
a photo to your computer and asking whether there is an animal there) is very tough; corporations like Google
and Microsoft are spending numerous man-years and employ techniques like machine learning and neural networks.</p>
<p>Fortunately, poker table recognition is much easier. The images to be recognized are machine-generated, so
the same things are rendered more or less the same way all the time. It makes sense to keep the poker table
size fixed to some predefined value which makes recognition task fairly easy.</p>
<h2 id="card-recognition-steps">Card recognition steps</h2>
<p>There are 13 card faces (from Deuce to Ace) and 4 suits. All of them are just fixed-size images which we need to be able to
match with. So we start with a screenshot of a poker table:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//table.png" alt="Poker table screenshot"></p>
<p>The table size is fixed, so are the left and the top pixel positions of hole cards. So, our first step is to extract
the small images of cards out of the big screenshot:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//cards.png" alt="Extracted card images"></p>
<p>Now, we can take the recognition of card faces and suits separately. In our sample layout, suits are color coded.
This is very friendly to humans and super simple for the bot. We pick the suit based on the color (ignoring 
the white pixels):</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//suits.png" alt="Recognized suits"></p>
<p>This leaves us with the task of choosing between 13 card faces. The color information is not important
here, we can make the image grey-scale. Moreover, we can reduce the color information to the single bit per 
pixel - call it white or black:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//blackandwhite.png" alt="Black and white pixels"></p>
<p>Now this mask is very simple, and we can compare it with 13 predefined masks for 13 cards pixel by pixel.
The one with the biggest amount of matches wins.</p>
<h2 id="suit-recognition">Suit recognition</h2>
<p>Let&#39;s put some code at the table. We start with suit recognition. <code>getSuit</code> function has type 
<code>Color -&gt; string option</code> and converts the color of a pixel into the suit name, if possible. Hearts (&quot;h&quot;)
are red, Diamonds (&quot;d&quot;) are blue, Clubs (&quot;c&quot;) are green and Spades (&quot;s&quot;) are black:</p>
<pre><code class="language-fsharp">let getSuit (c : Color) =
  match c with
  | _ when c.B &lt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &gt; 127uy -&gt; Some &quot;h&quot;
  | _ when c.B &gt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;d&quot;
  | _ when c.B &lt; 127uy &amp;&amp; c.G &gt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;c&quot;
  | _ when c.B &lt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;s&quot;
  | _ -&gt; None</code></pre>
<p>This function is used by <code>getCardSuit</code> function of type <code>(int -&gt; int -&gt; Color) -&gt; int -&gt; int -&gt; string</code>.
Its first argument is a function which returns the color of a pixel based on <code>(x, y)</code>
relative coordinates (starting with 0). The next two arguments are width and height of the cards. Result is
the same suit name that we described above. The function loops through all the pixels, gets a suit per
pixel and then returns the suit which is the most popular among them. Alternatively, we could just return
the first suit found, but my implementation looks more resilient:</p>
<pre><code class="language-fsharp">let getCardSuit getPixel width height =    
  seq { for x in 0 .. width - 1 do
          for y in 0 .. height - 1 do
            yield getSuit (getPixel x y) }
  |&gt; Seq.choose id
  |&gt; Seq.countBy id
  |&gt; Seq.maxBy (fun (v, c) -&gt; c)
  |&gt; fst</code></pre>
<h2 id="producing-the-black-white-pattern">Producing the black &amp; white pattern</h2>
<p><code>getCardPattern</code> accepts the same parameters as <code>getSuits</code> but returns <code>seq&lt;BW&gt;</code> instead. This is
a sequence of black or white pixels with a helper union type:</p>
<pre><code class="language-fsharp">type BW = B | W</code></pre>
<p>The function body enumerates the pixels and return black or white result as a flat sequence:</p>
<pre><code class="language-fsharp">let getCardPattern getPixel width height =
  let isWhite (c : Color) =
    if c.B &gt; 127uy &amp;&amp; c.G &gt; 127uy &amp;&amp; c.R &gt; 127uy then W
    else B

  seq { for x in 0 .. width - 1 do
          for y in 0 .. height - 1 do
            yield isWhite (getPixel x y) } </code></pre>
<h2 id="card-face-recognition">Card face recognition</h2>
<p>Having a black and white pattern, we can compare it with the predefined patterns and pick the
most similar one. A pattern is defined with a helper type</p>
<pre><code class="language-fsharp">type CardPattern = {
  Card: string
  Pattern: BW array
}</code></pre>
<p><code>Pattern</code> is a sequence which is equivalent to the sequence we got on the previous step. 
<code>Card</code> is a string of hand face value 2, 3, 4 .. A. <code>getCardFace</code> has the type 
<code>CardPattern[] -&gt; seq&lt;BW&gt; -&gt; string</code>, it accepts an array of known patterns and a pattern
of the card to be recognized. It compares patterns pixel by pixel and returns the card
which has the biggest amount of matches:</p>
<pre><code class="language-fsharp">let getCardFace patterns bws =
  let matchCount h p =
    Seq.zip h p
    |&gt; Seq.map (fun (v1, v2) -&gt; if v1 = v2 then 1 else 0)
    |&gt; Seq.sum
    |&gt; decimal
  let maxPattern = patterns |&gt; Array.maxBy (fun p -&gt; matchCount bws p.Pattern)
  maxPattern.Card</code></pre>
<h2 id="getting-the-known-patterns">Getting the known patterns</h2>
<p>So how do we create an array of known patterns? It&#39;s tedious to do manually, so
we use a bit of code generation.
Basically we just take several screenshots of poker tables and feed them to the following 
helper function:</p>
<pre><code class="language-fsharp">let parsePattern getPixel width height =
  getCardPattern getPixel width height
  |&gt; Seq.map (fun x -&gt; if x = B then &quot;B&quot; else &quot;W&quot;) 
  |&gt; String.concat &quot;;&quot;</code></pre>
<p>The function creates a string which can be copy-pasted into F# array of <code>BW</code>.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Here is the facade function that will be called from the outside:</p>
<pre><code class="language-fsharp">let recognizeCard getPixel width height = 
  let value = 
    getCardPattern getPixel width height 
    |&gt; getCardValue patterns
  let suit = getCardSuit getPixel width height
  value + suit</code></pre>
<p>The calling code looks like this:</p>
<pre><code class="language-fsharp">let image = new Bitmap(&quot;...&quot;);

let getPixel offsetX offsetY x y = 
  image.GetPixel(offsetX + x, offsetY + y)

let hand = (recognizeCard (getPixel leftX top) width height) + (recognizeCard (getPixel rightX top) width height)</code></pre>
<p><code>leftX</code>, <code>rightX</code>, <code>top</code>, <code>width</code> and <code>height</code> are well-known parameters of cards locations within a screenshot, 
which are hard coded for a given table size.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The full code for card recognition can be found in my <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/HandRecognition.fs">github repo</a>. It&#39;s just 75 lines of code which is
much less that one could imagine for a task of image recognition. Similar code could be used to recognize other
fixed objects at poker table: dealer button location, action buttons, checkboxes etc. In the next part of this
series I will show how to recognize non-fixed parts: text and numbers.</p>
<p><em>Proceed to <a href="https://mikhail.io/2016/02/building-a-poker-bot-string-number-recognition/">Part 2 of Building a Poker Bot: String and Number Recognition</a>.</em></p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/poker-bot/'>Poker Bot</a>, <a href='/tags/f#/'>F#</a>, <a href='/tags/image-recognition/'>Image Recognition</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Jan 25th, 2016</div>
    
    <h1><a href='/2016/01/monads-explained-in-csharp/'>Monads explained in C#</a></h1>
    

    

    <div class="post-content">
        <p><em>The newer and much longer version of this article is now available:</em>
<a href="https://mikhail.io/2018/07/monads-explained-in-csharp-again/">Monads explained in C# (again)</a></p>
<p>It looks like there is a mandatory post that every blogger who learns functional programming should write:
what a Monad is. Monads have the reputation of being something very abstract and very confusing for every
developer who is not a hipster Haskell programmer. They say that once you understand what a monad is, you 
loose the ability to explain it in simple language. Doug Crockford was the first one to lay this rule down, but
it becomes kind of obvious once you read 3 or 5 explanations on the web. Here is my attempt, probably doomed
to fail :)</p>
<h2 id="monads-are-container-types">Monads are container types</h2>
<p>Monads represent a class of types which behave in the common way.</p>
<p>Monads are containers which encapsulate some kind of functionality. On top of
that, they provide a way to combine two containers into one. And that&#39;s about it. </p>
<p>The goals of monads are similar to generic goals of any encapsulation in 
software development practices: hide the implementation details from the client, 
but provide a proper way to use the hidden functionality. </p>
<p>It&#39;s not because we 
want to be able to change the implementation, it&#39;s because we want to make the 
client as simple as possible and to enforce the best way of code structure. 
Quite often monads provide the way to avoid imperative code in favor of 
functional style.</p>
<p>Monads are flexible, so in C# we could try to represent a monadic type as 
a generic class:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
}</code></pre>
<h2 id="monad-instances-can-be-created">Monad instances can be created</h2>
<p>Quite an obvious statement, isn&#39;t it. Having a class <code>Monad&lt;T&gt;</code>, there should 
be a way to create an object of this class out of an instance of type <code>T</code>. 
In functional world this operation is known as <code>Return</code> function. In C# it 
can be as simple as a constructor:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
    public Monad(T instance)
    {
    }
}</code></pre>
<p>But usually it makes sense to define an extension method to enable fluent 
syntax of monad creation:</p>
<pre><code class="language-csharp">public static class MonadExtensions
{
    public static Monad&lt;T&gt; Return&lt;T&gt;(this T instance) =&gt; new Monad&lt;T&gt;(instance);
}</code></pre>
<h2 id="monads-can-be-chained-to-create-new-monads">Monads can be chained to create new monads</h2>
<p>This is the property which makes monads so useful, but also a bit confusing. 
In functional world this operation is expressed with the <code>Bind</code> function 
(or <code>&gt;&gt;=</code> operator). Here is the signature of <code>Bind</code> method in C#:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
    public Monad&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Monad&lt;TO&gt;&gt; func)
    {
    }
}</code></pre>
<p>As you can see, the <code>func</code> argument is a complicated thing. It accepts an 
argument of type <code>T</code> (not a monad) and returns an instance of <code>Monad&lt;TO&gt;</code> 
where <code>TO</code> is another type. Now, our first instance of <code>Monad&lt;T&gt;</code> knows 
how to bind itself to this function to produce another instance of monad 
of the new type. The full power of monads comes when we compose several of 
them in one chain:</p>
<pre><code class="language-csharp">initialValue
    .Return()
    .Bind(v1 =&gt; produceV2OutOfV1(v1))
    .Bind(v2 =&gt; produceV3OutOfV2(v2))
    .Bind(v3 =&gt; produceV4OutOfV3(v3))
    //...</code></pre>
<p>Let&#39;s have a look at some examples.</p>
<p><a name="maybe" href="/2016/01/monads-explained-in-csharp/undefined"></a></p>
<h2 id="example-maybe-option-type">Example: Maybe (Option) type</h2>
<p><code>Maybe</code> is the 101 monad which is used everywhere. <code>Maybe</code> is another approach 
to dealing with &#39;no value&#39; value, alternative to the concept of <code>null</code>. 
Basically your object should never be null, but it can either have <code>Some</code> 
value or be <code>None</code>. F# has a maybe implementation built into the language: 
it&#39;s called <code>option</code> type. Here is a sample implementation in C#:</p>
<pre><code class="language-csharp">public class Maybe&lt;T&gt; where T : class
{
    private readonly T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new ArgumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Maybe&lt;TO&gt;&gt; func) where TO : class
    {
        return value != null ? func(value) : Maybe&lt;TO&gt;.None();
    }

    public static Maybe&lt;T&gt; None() =&gt; new Maybe&lt;T&gt;();
}</code></pre>
<pre><code class="language-csharp">public static class MaybeExtensions
{
    public static Maybe&lt;T&gt; Return&lt;T&gt;(this T value) where T : class
    {
        return value != null ? new Maybe&lt;T&gt;(value) : Maybe&lt;T&gt;.None();
    }
}</code></pre>
<p>Return function is implemented with a combination of a public constructor 
which accepts <code>Some</code> value (notice that <code>null</code> is not allowed) and a static 
<code>None</code> method returning an object of &#39;no value&#39;. <code>Return</code> extension method
combines both of them in one call. </p>
<p><code>Bind</code> function is implemented explicitly. </p>
<p>Let&#39;s have a look at a use case. Imagine we have a traditional repository 
which loads data from an external storage (no monads yet):</p>
<pre><code class="language-csharp">public interface ITraditionalRepository
{
    Customer GetCustomer(int id);
    Address GetAddress(int id);
    Order GetOrder(int id);
}</code></pre>
<p>Now, we write a client class which loads data one by one and tries to find
a shipper:</p>
<pre><code class="language-csharp">Shipper shipperOfLastOrderOnCurrentAddress = null;
var customer = repo.GetCustomer(customerId);
if (customer?.Address != null)
{
    var address = repo.GetAddress(customer.Address.Id);
    if (address?.LastOrder != null)
    {
        var order = repo.GetOrder(address.LastOrder.Id);
        shipperOfLastOrderOnCurrentAddress = order?.Shipper;
    }
}
return shipperOfLastOrderOnCurrentAddress;</code></pre>
<p>Note, that the code assumes that repository returns <code>null</code> if some entity
is not found, although nothing in the type system shows that. Then, there
is a number of <code>null</code> checks (facilitated with elvis operator). The code gets
a bit cluttered and less linear.</p>
<p>Here is an alternative repository which returns <code>Maybe</code> type:</p>
<pre><code class="language-csharp">public interface IMonadicRepository
{
    Maybe&lt;Customer&gt; GetCustomer(int id);
    Maybe&lt;Address&gt; GetAddress(int id);
    Maybe&lt;Order&gt; GetOrder(int id);
}</code></pre>
<p>The contract is more explicit: you see that <code>Maybe</code> type is used, so you
will be forced to handle the case of absent value.</p>
<p>And here is how the above example can be rewritten with <code>Bind</code> method 
composition:</p>
<pre><code class="language-csharp">Maybe&lt;Shipper&gt; shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c =&gt; c.Address)
        .Bind(a =&gt; repo.GetAddress(a.Id))
        .Bind(a =&gt; a.LastOrder)
        .Bind(lo =&gt; repo.GetOrder(lo.Id))
        .Bind(o =&gt; o.Shipper);</code></pre>
<p>There&#39;s no branching anymore, the code is fluent and linear.</p>
<p>If you think that the syntax looks very much like a LINQ query with a bunch 
of <code>Select</code> statements, you are not the only one ;) One of the common 
implementations of <code>Maybe</code> implements <code>IEnumerable</code> interface which allows 
a more C#-idiomatic binding composition. Actually:</p>
<h2 id="ienumerable-selectmany-is-a-monad-">IEnumerable + SelectMany is a monad </h2>
<p><code>IEnumerable</code> is an interface for enumerable containers.</p>
<p>Enumerable containers can be created - thus the <code>Return</code> monadic operation.</p>
<p>The <code>Bind</code> operation is defined by the standard LINQ extension method, here 
is its signature:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;B&gt; SelectMany&lt;A, B&gt;(
    this IEnumerable&lt;A&gt; first, 
    Func&lt;A, IEnumerable&lt;B&gt;&gt; selector)</code></pre>
<p>And here is an example of composition:</p>
<pre><code class="language-csharp">IEnumerable&lt;Shipper&gt; someWeirdListOfShippers =
    customers
        .SelectMany(c =&gt; c.Addresses)
        .SelectMany(a =&gt; a.Orders)
        .SelectMany(o =&gt; o.Shippers);</code></pre>
<p>The query has no idea about how the collections are stored (encapsulated in
containers). We use functions <code>A -&gt; IEnumerable&lt;B&gt;</code> to produce new enumerables
(<code>Bind</code> operation).</p>
<h2 id="monad-laws">Monad laws</h2>
<p>There are a couple of laws that <code>Return</code> and <code>Bind</code> need to adhere to, so
that they produce a proper monad.</p>
<p><strong>Identity law</strong> says that that <code>Return</code> is a neutral operation: you can safely
run it before <code>Bind</code>, and it won&#39;t change the result of the function call:</p>
<pre><code class="language-csharp">// Given
T value;
Func&lt;T, M&lt;U&gt;&gt; f;

// == means both parts are equivalent
value.Return().Bind(f) == f(value) </code></pre>
<p><strong>Associativity law</strong> means that the order in which <code>Bind</code> operations
are composed does not matter:</p>
<pre><code class="language-csharp">// Given
M&lt;T&gt; m;
Func&lt;T, M&lt;U&gt;&gt; f;
Func&lt;U, M&lt;V&gt;&gt; g;

// == means both parts are equivalent
m.Bind(f).Bind(g) == m.Bind(a =&gt; f(a).Bind(g))</code></pre>
<p>The laws may look complicated, but in fact they are very natural 
expectations that any developer has when working with monads, so don&#39;t
spend too much mental effort on memorizing them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>You should not be afraid of the &quot;M-word&quot; just because you are a C# programmer. 
C# does not have a notion of monads as predefined language constructs, but 
it doesn&#39;t mean we can&#39;t borrow some ideas from the functional world. Having 
said that, it&#39;s also true that C# is lacking some powerful ways to combine 
and generalize monads which are possible in Haskell and other functional 
languages.</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/functional-programming/'>Functional Programming</a>, <a href='/tags/monads/'>Monads</a>, <a href='/tags/maybe/'>Maybe</a>, <a href='/tags/linq/'>LINQ</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Jan 13th, 2016</div>
    
    <h1><a href='/2016/01/fire-and-forget-in-service-fabric-actors/'>Fire-and-forget in Service Fabric actors</a></h1>
    

    

    <div class="post-content">
        <p>At the <a href="http://www.meetup.com/Webscale-Architecture-NL/events/225979118/">recent Webscale Architecture meetup</a> 
we discussed two implementations of the Actor model in the .NET ecosystem: 
<a href="http://akka.net">Akka.NET</a> and <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-introduction/">Azure Service Fabric Actors</a>. 
One important discussion was
around <strong>Ask</strong> vs <strong>Tell</strong> call model. With <strong>Tell</strong> model, the Sender just sends the
message to the Recepient without waiting for a result to come back. <strong>Ask</strong> model
means the Sender will at some point get a response back from the Receiver, potencially
blocking its own execution.</p>
<p>The default model of Akka.NET is <strong>Tell</strong>:</p>
<blockquote>
<p><strong>Tell: Fire-forget</strong></p>
</blockquote>
<blockquote>
<p>This is the preferred way of sending messages. No blocking waiting for 
a message. This gives the best concurrency and scalability characteristics.</p>
</blockquote>
<p>On the contrary, the default model for Service Fabric Actors is RPC-like
<strong>Ask</strong> model. Let&#39;s have a close look at this model, and then see how we can
implement <strong>Tell</strong> (or <strong>Fire-and-Forget</strong>) model.</p>
<p>Actor definition starts with an interface:</p>
<pre><code>public interface IHardWorkingActor : IActor
{
    Task DoWork(string payload);
}</code></pre><p>As you can see, the method does not return any useful data, which means
the client code isn&#39;t really interested in waiting for the operation to
complete. Here&#39;s how we implement this interface in the Actor class:</p>
<pre><code>public class HardWorkingActor : Actor, IHardWorkingActor
{
    public async Task DoWork(string payload)
    {
        ActorEventSource.Current.ActorMessage(this, &quot;Doing Work&quot;);
        await Task.Delay(500);
    }
}</code></pre><p>This test implementation simulates the hard work by means of an artificial 500 ms delay.</p>
<p>Now, let&#39;s look at the client code. Let&#39;s say, the client receives the payloads
from a queue or a web front-end and needs to go as fast as possible. It gets a payload,
creates an actor proxy to dispatch the payload to, then it just wants 
to continue with the next payload. Here is the &quot;Ask&quot; implementation based on 
the Service Fabric samples:</p>
<pre><code>int i = 0;
var timer = new Stopwatch();
timer.Start();
while (true)
{
    var proxy = ActorProxy.Create&lt;IHardWorkingActor&gt;(ActorId.NewId(), &quot;fabric:/Application1&quot;);
    await proxy.DoWork($&quot;Work ${i++}&quot;);
    Console.WriteLine($@&quot;Sent work to Actor {proxy.GetActorId()}, 
                         rate is {i / timer.Elapsed.TotalSeconds}/sec&quot;);
}</code></pre><p>Note an <code>await</code> operator related to every call. That means that the client will
block until the actor work is complete. When we run the client, no surprise that
we get the rate of about 2 messages per second:</p>
<pre><code>Sent work to Actor 1647857287613311317, rate is 1,98643230380293/sec</code></pre><p>That&#39;s not very exciting. What we want instead is to tell the actor to do the
work and immediately proceed to the next one. Here&#39;s how the client call should
look like:</p>
<pre><code>proxy.DoWork($&quot;Work ${i++}&quot;).FireAndForget();</code></pre><p>Instead of <code>await</code>-ing, we make a <code>Task</code>, pass it to some (not yet existing)
extension method and proceed immediately. It appears that the implementation 
of such extension method is trivial:</p>
<pre><code>public static class TaskHelper
{       
    public static void FireAndForget(this Task task)
    {
        Task.Run(async() =&gt; await task).ConfigureAwait(false);
    }
} </code></pre><p>The result looks quite different from what we had before:</p>
<pre><code>Sent work to Actor -8450334792912439527, rate is 408,484162592517/sec</code></pre><p>400 messages per second, which is some 200x difference... </p>
<p>The conclusions are simple:</p>
<ul>
<li><p>Service Fabric is a powerful platform and programming paradigm which doesn&#39;t
limit your choice of communication patterns</p>
</li>
<li><p>Design the communication models carefully based on your use case, don&#39;t
take the defaults for granted</p>
</li>
</ul>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/actor-model/'>Actor Model</a>, <a href='/tags/azure/'>Azure</a>, <a href='/tags/akka-net/'>Akka.NET</a>, <a href='/tags/service-fabric/'>Service Fabric</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Jan 6th, 2016</div>
    
    <h1><a href='/2016/01/validation-with-either-data-type-in-csharp/'>Validation with Either data type in C#</a></h1>
    

    

    <div class="post-content">
        <p>In this article we will employ a functional monadic concept <strong>Either</strong> to make validation
code more expressive and easier to maintain.</p>
<h2 id="problem">Problem</h2>
<p>Let&#39;s say we get a request from some client code and we need to check if this
request is actually valid. If it&#39;s not valid, we want to make a detailed description
of the problems that we identified. If it is valid, we want to produce a response
about the successful acceptance of the request. Let&#39;s define the classes:</p>
<pre><code class="language-csharp">public class Request { ... }
public class Response { ... }
public class ValidationError { ... }</code></pre>
<p>Now, we need a function which would accept a <code>Request</code> and would return <code>Response</code>
or <code>ValidationError</code>. Let&#39;s look at some possible solutions.</p>
<h2 id="throw-an-exception">Throw an exception</h2>
<p>Validation <em>error</em> sounds like it could be an exception:</p>
<pre><code class="language-csharp">public Response Validate(Request r)
{
   if (!Valid(r))
       throw new ValidationException(new ValidationError(...));

   return new Response(r);
}</code></pre>
<p>This approach is really bad though. You have to declare a special exception
class to hold the validation error. But even worse, exception handling is not
explicit - you don&#39;t see the exception type when you look at method signature.
Client processing code is going to be messed up because of exception handling.
Never use exceptions for your business logic flow.</p>
<h2 id="output-parameter">Output parameter</h2>
<p>We could make an output parameter of <code>ValidationError</code> type:</p>
<pre><code class="language-csharp">public Response Validate(Request r, out ValidationError error)
{
    if (Valid(r))
    { 
        error = new ValidationError(...);
        return null;
    }

    error = null;
    return new Response(r);
}</code></pre>
<p>Now the interface is more explicit: client won&#39;t be able to completely ignore
the fact that an error is possible. But output parameters are not really
easy to use in C#, especially in fluent-style client code. Moreover, we are
using nulls as a way to represent missing object, which is a smell by itself,
because nulls are not explicit. Never use nulls in your business logic.</p>
<h2 id="return-the-combined-result">Return the combined result</h2>
<p>We could declare a container class which would keep both <code>Response</code> and 
<code>ValidationError</code>, and then return it from the method.</p>
<pre><code class="language-csharp">public class Both&lt;TData, TError&gt;
{
    public TData Data { get; set; }
    public TErrro Error { get; set; }
}
...
public Both&lt;Response, ValidationError&gt; Validate(Request r)
{
    return Valid(r) 
        ? new Both&lt;Response, ValidationError&gt; { Data = new Response(r) }
        : new Both&lt;Response, ValidationError&gt; { Error = new ValidationError(...) };
}</code></pre>
<p>Looks much nicer, we are getting there. Now it&#39;s a pure function with input
and output parameters, but we still use null for result state representation.
Let&#39;s see how we can solve it with <strong>Either</strong> data structure.</p>
<h2 id="introducing-either">Introducing Either</h2>
<p>Instead of returning <code>Both</code> with nullable properties, let&#39;s return <code>Either</code> 
with just one of them. When constructing an object, you can specify either
a &#39;left&#39; or a &#39;right&#39; argument, but not both.</p>
<pre><code class="language-csharp">public class Either&lt;TL, TR&gt;
{
    private readonly TL left;
    private readonly TR right;
    private readonly bool isLeft;

    public Either(TL left)
    {
        this.left = left;
        this.isLeft = true;
    }

    public Either(TR right)
    {
        this.right = right;
        this.isLeft = false;
    }
}</code></pre>
<p>Now, the main difference is in how the client uses it. There are no properties
to accept <code>Left</code> and <code>Right</code> parts. Instead we define the following method:</p>
<pre><code class="language-csharp">public T Match&lt;T&gt;(Func&lt;TL, T&gt; leftFunc, Func&lt;TR, T&gt; rightFunc)
    =&gt; this.isLeft ? leftFunc(this.left) : rightFunc(this.right);</code></pre>
<p>That&#39;s the concept of pattern matching implemented in C# world. If a left value 
is specified, <code>Match</code> will return the result of the left function, otherwise the result
of the right function.</p>
<p>Another improvement would be to create explicit operators for easy conversions
from left and right types:</p>
<pre><code class="language-csharp">public static implicit operator Either&lt;TL, TR&gt;(TL left) =&gt; new Either&lt;TL, TR&gt;(left);

public static implicit operator Either&lt;TL, TR&gt;(TR right) =&gt; new Either&lt;TL, TR&gt;(right);</code></pre>
<p>Let&#39;s have a look at a complete example.</p>
<h2 id="why-it-s-great">Why it&#39;s great</h2>
<p>Here is the service code written with <code>Either</code>:</p>
<pre><code class="language-csharp">public Either&lt;Response, ValidationError&gt; Validate(Request r)
{
    return Valid(r) 
        ? Data = new Response(r)
        : new ValidationError(...);
}</code></pre>
<p>Clean and nice! Now a simplistic client:</p>
<pre><code class="language-csharp">var validated = service.Validate(request);
Console.WriteLine(
    validated.Match(
        result =&gt; $&quot;Success: {result}&quot;,
        error =&gt; $&quot;Error: {error}&quot;)
    );</code></pre>
<p>Simple, readable , no conditionals, no null checks, no way to silently ignore the fact that
validation may fail.</p>
<h2 id="show-me-the-code">Show me the code</h2>
<p>You can find the definition of <code>Either</code> class in my <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/Either%7BTL%2CTR%7D.cs">github repo</a>.</p>
<p><strong>Update.</strong> Here is a link to an awesome talk on this topic: 
<a href="https://vimeo.com/113707214">Railway oriented programming: Error handling in functional languages by Scott Wlaschin</a></p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/functional-programming/'>Functional Programming</a>, <a href='/tags/clean-code/'>Clean Code</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Dec 22nd, 2015</div>
    
    <h1><a href='/2015/12/weaving-your-domain-classes-with-fody/'>Weaving your domain classes with Fody</a></h1>
    

    

    <div class="post-content">
        <p>When I model the business domain with C#, the resulting data structures tend to contain a lot of boilerplate code. It&#39;s repeated from class to class and it gets more difficult to see the essence of the model behind the repetitive cruft. Here is a simplistic example, which illustrates the problem. Let&#39;s say we are modelling Trips, and for each <code>Trip</code> we need to keep track of <code>Origin</code>, <code>Destination</code> and <code>Vehicle</code> which executes the <code>Trip</code>, nothing else. Here is a code to create an sample trip:</p>
<pre><code class="language-csharp">var trip = new Trip(
    origin: new Location(&quot;Paris&quot;, geoParis), 
    destination: new Location(&quot;Amsterdam&quot;, geoAmsterdam),
    vehicle: new Vehicle(&quot;TBL-12-H&quot;, Type.HeavyTruck)</code></pre>
<p>Let&#39;s include these requirements as parts of our trip model:</p>
<ul>
<li>It has a constructor which accepts three arguments (see above)</li>
<li>It has 3 read-only properties which are assigned from constructor parameters</li>
<li>It should not allow null values to be assigned to these properties via constructor</li>
<li>It should be a Value object, that is two objects with same properties should be equal</li>
</ul>
<h2 id="initial-version">Initial version</h2>
<p>First, let&#39;s implement these requirement in a usual way:</p>
<pre><code class="language-csharp">public class Trip : IEquatable&lt;Trip&gt;
{
    public Trip(Location origin, Location destination, Vehicle vehicle)
    {
        if (origin == null) throw new ArgumentNullException(nameof(origin));
        if (destination == null) throw new ArgumentNullException(nameof(destination));
        if (vehicle == null) throw new ArgumentNullException(nameof(vehicle));

        this.Origin = origin;
        this.Destination = destination;
        this.Vehicle = vehicle;
    }

    public Location Origin { get; }
    public Location Destination { get; }
    public Vehicle Vehicle { get; }

    public bool Equals(Trip other)
    {
        return Equals(this.Origin, other.Origin) 
            &amp;&amp; Equals(this.Destination, other.Destination) 
            &amp;&amp; Equals(this.Vehicle, other.Vehicle);
    }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj))
        {
            return false;
        }
        if (ReferenceEquals(this, obj))
        {
            return true;
        }
        if (obj.GetType() != this.GetType())
        {
            return false;
        }
        return Equals((Trip)obj);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            var hashCode = this.Origin.GetHashCode();
            hashCode = (hashCode * 397) ^ this.Destination.GetHashCode();
            hashCode = (hashCode * 397) ^ this.Vehicle.GetHashCode();
            return hashCode;
        }
    }

    public static bool operator ==(Trip tripA, Trip tripB)
    {
        return object.Equals(tripA, tripB);
    }

    public static bool operator !=(Trip tripA, Trip tripB)
    {
        return !object.Equals(tripA, tripB);
    }
}</code></pre>
<p>That&#39;s a lot of code! It&#39;s very repetitive but it&#39;s also tricky: you can implement it incorrectly in some slight way that wouldn&#39;t be easy to catch until it silently fails one day. So imagine how many tests you need to validate it.</p>
<p>I implemented this code with help of Resharper, which makes it so much easier, but the code is still a heavy luggage to carry on. This class is hard to read and hard to change - every time you add a property you should not forget to update all the corresponding methods. </p>
<p>Are there other options?</p>
<h2 id="introducing-fody">Introducing Fody</h2>
<p><a href="https://github.com/Fody/Fody">Fody</a> is an extensible tool for weaving .NET assemblies. It means that you can use it to improve your code automatically at the time of compilation. Fody itself doesn&#39;t do much to the code, but it has a collection of plugins to actually change it. For this example I will use two of them: </p>
<ul>
<li><a href="https://github.com/Fody/NullGuard"><strong>NullGuard</strong></a> - guards all the input parameters, output parameters and return values of all types in a current assembly not to be null. If null value is passed or returned, the weaved code with throw an exception.</li>
<li><a href="https://github.com/Fody/Equals"><strong>Equals</strong></a> - you can mark a class with <code>[Equals]</code> attribute and Fody will implement <code>Equals()</code> and <code>GetHashCode()</code> methods and <code>==</code> operator for you by comparing all public properties of the annotated class.</li>
</ul>
<p>To install them just execute </p>
<pre><code class="language-ps">PM&gt; Install-Package NullGuard.Fody
PM&gt; Install-Package Equals.Fody</code></pre>
<p>The root of your project will now contain the following configuration file:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Weavers&gt;
  &lt;NullGuard IncludeDebugAssert=&quot;false&quot; /&gt;
  &lt;Equals /&gt;
&lt;/Weavers&gt;</code></pre>
<p>(I&#39;ve added <code>IncludeDebugAssert</code> attribute manually to disable assert statements in debug mode)</p>
<p>Let&#39;s adjust our class to make use of the plugins:</p>
<pre><code class="language-csharp">[Equals]
public class Trip
{
    public Trip(Location origin, Location destination, Vehicle vehicle)
    {
        this.Origin = origin;
        this.Destination = destination;
        this.Vehicle = vehicle;
    }

    public Location Origin { get; }
    public Location Destination { get; }
    public Vehicle Vehicle { get; }
}</code></pre>
<p>And that&#39;s it! We still get the same functionality but the code is just trivial. Let&#39;s see how it works:</p>
<ul>
<li><code>Equals</code> attribute means that we want Fody plugin to implement all the equality-related boilerplate code for this class, including operators and <code>IEquatable&lt;T&gt;</code> implementation. So this plugin is in <em>opt-in</em> mode.</li>
<li>I used no attributes from <code>NullGuard</code> plugin. This plugin works in <em>opt-out</em> mode, i.e. it changes all the classes by default, and if you don&#39;t want it for some piece of code - you can always opt out. This default makes a lot of sense to me: I don&#39;t want any nulls in my code unless I really need them due to some external contracts.</li>
</ul>
<p>Let&#39;s open the resulting assembly in <a href="http://ilspy.net/">ILSpy</a> to see what it compiles to. Here is the constructor:</p>
<pre><code class="language-csharp">public Trip(Location origin, Location destination, Vehicle vehicle)
{
    bool flag = origin == null;
    if (flag)
    {
        throw new ArgumentNullException(&quot;origin&quot;);
    }
    bool flag2 = destination == null;
    if (flag2)
    {
        throw new ArgumentNullException(&quot;destination&quot;);
    }
    bool flag3 = vehicle == null;
    if (flag3)
    {
        throw new ArgumentNullException(&quot;vehicle&quot;);
    }
    this.&lt;Origin&gt;k__BackingField = origin;
    this.&lt;Destination&gt;k__BackingField = destination;
    this.&lt;Vehicle&gt;k__BackingField = vehicle;
}</code></pre>
<p>It&#39;s bit more verbose but essentially equivalent to what I did manually before. By default null guard will be very strict, so you will see that even auto-property&#39;s return values are checked:</p>
<pre><code class="language-csharp">public Location Origin
{
    [CompilerGenerated]
    get
    {
        Location expr_06 = this.&lt;Origin&gt;k__BackingField;
        if (expr_06 == null)
        {
            throw new InvalidOperationException(&quot;[NullGuard] Return value of property &#39;ETA.Domain.Location ETA.Domain.Trip::Origin()&#39; is null.&quot;);
        }
        return expr_06;
    }
}</code></pre>
<p>It doesn&#39;t make much sense to me, so I configured Fody on assembly level to check only arguments and return values:</p>
<pre><code class="language-csharp">[assembly: NullGuard(ValidationFlags.Arguments | ValidationFlags.ReturnValues)]</code></pre>
<p>Here is a set of operations related to equality (I&#39;ll skip the body in sake of brevity):</p>
<pre><code class="language-csharp">public class Trip : IEquatable&lt;Trip&gt;
{
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    private static bool EqualsInternal(Trip left, Trip right) { ... }
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    public override bool Equals(Trip other) { ... }
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    public override bool Equals(object obj) { ... }
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    public override int GetHashCode() { ... }
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    public static bool operator ==(Trip left, Trip right) { ... }
    [GeneratedCode(&quot;Equals.Fody&quot;, &quot;1.4.6.0&quot;), DebuggerNonUserCode]
    public static bool operator !=(Trip left, Trip right) { ... }
}</code></pre>
<p>There is a catch (at least at the time of writing): the auto-generated <code>==</code> and <code>!=</code> operators won&#39;t work properly if you use them inside the same assembly where the type is defined. That&#39;s because the C# compiler will only use these operators properly if they are defined at compile time, and they only get defined after the compilation (weaving takes place after IL is produced). See <a href="https://github.com/Fody/Equals/issues/10">the issue on GitHub</a> for details.</p>
<h2 id="bonus-a-proper-solution">Bonus - a proper solution</h2>
<p>Here is how you actually should define similar types:</p>
<pre><code class="language-fsharp">type Trip = 
  { Origin : Location
    Destination : Location
    Vehicle : Vehicle }</code></pre>
<p>No nulls are possible here and equality works out of the box. There&#39;s just one major detail: it&#39;s F#...</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/fody/'>Fody</a>, <a href='/tags/ddd/'>DDD</a>, <a href='/tags/code-generation/'>Code Generation</a>
    </div>
    
</article>


<div class="page-nav">
    
    <a class="page-nav-newer" href="/11/index.html">&lt;&lt; Previous page</a>
    
    
    <a class="page-nav-older" href="/13/index.html">Next page &gt;&gt;</span></a>
    
</div>

<div id="me">
    <p itemscope itemtype="http://data-vocabulary.org/Person">
        <img src="/images/Headshot-Square.jpg" alt="Mikhail Shilkov" itemprop="photo" />
        I'm <b><span itemprop="name">Mikhail Shilkov</span></b>, a <span itemprop="title">software developer and architect</span>,
        a Microsoft Azure MVP, Russian expat living in the Netherlands. I am passionate about cloud technologies, 
        functional programming and the intersection of the two.
    </p>
    <p>
        <a href="https://www.linkedin.com/in/mikhailshilkov/">LinkedIn</a> &#8226;
        <a href="https://twitter.com/mikhailshilkov">@mikhailshilkov</a> &#8226;
        <a href="https://github.com/mikhailshilkov">GitHub</a> &#8226;
        <a href="https://stackoverflow.com/users/1171619/mikhail">Stack Overflow</a>
    </p>
</div>
</div>
<div class="container">
    <div class="navbar navbar-footer">
        <p class="navbar-center navbar-text">Content copyright &copy; 2018 Mikhail Shilkov</p>
    </div>
</div>



<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
<script src="/vendor/prism.js"></script>
<script src="/site.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59218480-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>