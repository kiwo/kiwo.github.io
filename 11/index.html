<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>

    <meta name="description" content="Software development using .NET, C#, SQL, Javascript and related technologies" />

    <title>Mikhail Shilkov</title>
    <meta name="author" content="Mikhail Shilkov">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="twitter:card" content="summary_large_image"></meta>
    <meta name="twitter:creator" content="@MikhailShilkov"></meta>
    <meta name="twitter:title" content="Mikhail Shilkov"></meta>

    <meta property="og:type" content="article" />
    <meta property="og:title" content="Mikhail Shilkov" />
    <meta property="og:url" content="https://mikhail.io/11/index.html" />




    <link href="/feed/" rel="alternate" title="mikhail.io" type="application/atom+xml">
    <link href="/favicon.ico?v=2" rel="shortcut icon">

    <!-- Bootstrap -->
    <link href="/styles/site.css" rel="stylesheet" media="screen">
    <link href="/vendor/prism.css" rel="stylesheet" media="screen">

    <meta name="generator" content="DocPad v6.80.6" />
    
</head>
<body>

<div class="navbar navbar-default navbar-static-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
                <span class="text-primary">Mikhail Shilkov</span><br />
                <span class="elevator-pitch">Serverless, Azure, FP, F# and more</span>
            </a>
        </div>
        <div class="collapse navbar-collapse navbar-right">
            <ul class="nav navbar-nav">
                <!--<li><a href="/">Blog</a></li>-->
                
                    <li><a href="/tags/">Topics</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/talks/">Talks</a></li>
                
                    <li><a href="/about/">About</a></li>
                
                <li class="hidden-xs">
                    <a href="/feed/" class="rss"><span class="icon icon-feed"></span></a>
                    <a href="https://www.linkedin.com/in/mikhailshilkov" class="linkedin"><span class="icon icon-linkedin"></span></a>
                    <a href="https://twitter.com/mikhailshilkov" class="twitter"><span class="icon icon-twitter"></span></a>
                    <a href="https://github.com/mikhailshilkov" class="github"><span class="icon icon-github"></span></a>
                </li>
            </ul>
            <form class="navbar-form navbar-right hidden-xs" role="search" action="https://google.com/search"
                  method="get">
                <div class="form-group">
                    <input type="search" name="q" class="form-control" placeholder="Search">
                    <input type="hidden" name="q" value="site:mikhail.io">
                </div>
            </form>
        </div>
    </div>
</div>
<div class="container">
    
    <article class="post">
    <div class="post-date">Feb 23rd, 2016</div>
    
    <h1><a href='/2016/02/unit-testing-dapper-repositories/'>Unit testing Dapper repositories</a></h1>
    

    

    <div class="post-content">
        <p><a href="https://github.com/StackExchange/dapper-dot-net">Dapper</a> is a micro-ORM library which is 
very simple and super fast. In our projects we use Dapper for the tasks where something like
EntityFramework or NHibernate would be an overkill.</p>
<p>Quite often the data access code is difficult to be unit tested. Objects like
database connections, commands, transactions and contexts are hard to mock, and
thus the data access code is not easily isolated. Dapper relies heavily on SQL
statements inside C# code, which gives an extra complication. Some people would
argue that unit tests are not warranted for data access layer, and integration
tests should be used instead. Let&#39;s have a look at another possibility.</p>
<h2 id="an-example-of-a-repository">An Example of a Repository</h2>
<p>Let&#39;s say we have a simple class and we want to populate instances of this class
from the database:</p>
<pre><code class="language-csharp">public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
}</code></pre>
<p>To be able to use Dapper for data access, we need an instance of <code>IDbConnection</code>.
As we want to be able to mock the connection for unit tests, we need to create
a factory interface to abstract it away:</p>
<pre><code class="language-csharp">public interface IDatabaseConnectionFactory
{
    IDbConnection GetConnection();
}</code></pre>
<p>Now the repository would get a connection from this factory and execute 
Dapper queries on it:</p>
<pre><code class="language-csharp">public class ProductRepository
{
    private readonly IDatabaseConnectionFactory connectionFactory;

    public ProductRepository(IDatabaseConnectionFactory connectionFactory)
    {
        this.connectionFactory = connectionFactory;
    }

    public Task&lt;IEnumerable&lt;Product&gt;&gt; GetAll()
    {
        return this.connectionFactory.GetConnection().QueryAsync&lt;Product&gt;(
            &quot;select * from Product&quot;);
    }
}</code></pre>
<h2 id="testing-without-a-real-database">Testing Without a real Database</h2>
<p>Here is my approach to testing the repository:</p>
<ol>
<li>Use an in-memory <a href="https://www.sqlite.org/">SQLite3</a> database.</li>
<li>Create a table there and put some data in.</li>
<li>Run the repository against this database.</li>
<li>Compare the result to the expected values.</li>
</ol>
<p>Here is a helper class which uses another micro-ORM library <a href="http://ormlite.com/">OrmLite</a> to talk
to SQLite database:</p>
<pre><code class="language-csharp">public class InMemoryDatabase
{
    private readonly OrmLiteConnectionFactory dbFactory = 
        new OrmLiteConnectionFactory(&quot;:memory:&quot;, SqliteOrmLiteDialectProvider.Instance);

    public IDbConnection OpenConnection() =&gt; this.dbFactory.OpenDbConnection();

    public void Insert&lt;T&gt;(IEnumerable&lt;T&gt; items)
    {
        using (var db = this.OpenConnection())
        {
            db.CreateTableIfNotExists&lt;T&gt;();
            foreach (var item in items)
            {
                db.Insert(item);
            }
        }
    }
}</code></pre>
<p>And here is the test for our <code>ProductRepository</code> class:</p>
<pre><code class="language-csharp">[Test]
public async Task QueryTest()
{
    // Arrange
    var products = new List&lt;Product&gt;
    {
        new Product { ... },
        new Product { ... }
    };
    var db = new InMemoryDatabase();
    db.Insert(products);
    connectionFactoryMock.Setup(c =&gt; c.GetConnection()).Returns(db.OpenConnection());

    // Act
    var result = await new ProductRepository(connectionFactoryMock.Object).GetAll();

    // Assert
    result.ShouldBeEquivalentTo(products);
}</code></pre>
<h2 id="is-it-a-unit-test-">Is It a Unit Test?</h2>
<p>Well, not completely. This approach does not mock the database, but instead puts
an in-memory database in place of the normal one. The problem is that we don&#39;t 
control all the details how it works, so it might not be as flexible as we need.
For instance, SQLite type system is quite simplistic, so while <code>INT</code> and <code>BIGINT</code>
are different column types in SQL Server, they are the same <code>INTEGER</code> type in
SQLite. This can lead to false positive or false negative tests in edge cases.</p>
<p>Nevertheless, the concept is simple and requires very little amount of code,
so it&#39;s useful to have it in the toolbox anyway. The resulting tests are fast,
have no external dependencies and are always consistent between multiple runs.
That makes them better than real integration tests for the simple scenarios 
during TDD development.</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/unit-testing/'>Unit Testing</a>, <a href='/tags/dapper/'>Dapper</a>, <a href='/tags/orm/'>ORM</a>, <a href='/tags/tdd/'>TDD</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Feb 10th, 2016</div>
    
    <h1><a href='/2016/02/building-a-poker-bot-string-recognition/'>Building a Poker Bot: String and Number Recognition</a></h1>
    

    

    <div class="post-content">
        <p><em>This is the second part of *</em>Building a Poker Bot** series where I describe my experience developing bot software 
to play in online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable. Here is the first part:
<a href="https://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">Building a Poker Bot: Card Recognition</a>
*</p>
<h2 id="why-string-recognition">Why string recognition</h2>
<p>Reading cards and other fixed images was the first step. The bot should also
be able to read different text-based information from the screen, e.g.</p>
<ul>
<li>Current blind levels</li>
<li>Current pot size</li>
<li>The size of bets made by each player</li>
<li>Player names</li>
<li>Stack sizes</li>
<li>Chat messages (for advanced scenarios)</li>
</ul>
<p>We need this vital information to make proper decisions, so let&#39;s look at
how to parse the textual data.</p>
<h2 id="new-challenges">New challenges</h2>
<p>String recognition has some specific difficulties when compared to fixed
images like cards:</p>
<ul>
<li>The size of a string is not predefined. Obviously, the longer the string, the
more space it takes on the screen</li>
<li>The position of a string is not fixed either. Some strings are aligned to
the center, others may diverge based on other variable parts like stakes or blinds</li>
<li>Different strings might be rendered in different font size</li>
</ul>
<p>Here is what needs to be done to overcome these complications:</p>
<ul>
<li>Pick the layout which makes your life easier </li>
<li>Adjust fonts and positions if possible </li>
<li>Make sure that all important strings are always visible and not overlapping to other information</li>
<li>For each string define a region where it belongs to in 100% cases. The background
of this region should be more or less evenly filled with a color in contrast to the font color.</li>
</ul>
<h2 id="string-recognition-steps">String recognition steps</h2>
<p>We start with a screenshot of a poker table again:</p>
<p><img src="/2016/02/building-a-poker-bot-string-recognition//table.png" alt="Poker table screenshot"></p>
<p>We know our fixed regions where our labels are located, so we take those
regions for processing:</p>
<p><img src="/2016/02/building-a-poker-bot-string-recognition//regions.png" alt="Regions of string recognition"></p>
<p>For each region we trim away the blank margins around the text (i.e. left,
top, right and bottom padding):</p>
<p><img src="/2016/02/building-a-poker-bot-string-recognition//nomargin.png" alt="Margins being removed"></p>
<p>We find dark lines between bright symbols and we consider them as gaps
between characters:</p>
<p><img src="/2016/02/building-a-poker-bot-string-recognition//splitchars.png" alt="Split to characters"></p>
<p>The final step is to compare each symbol to the known patterns and find the best
match (in case of my layout the match for symbols is always 100% perfect). Let&#39;s 
look how these steps are implemented.</p>
<h2 id="removing-padding-around-the-text">Removing padding around the text</h2>
<p>Because the padding is removed from all 4 sides of the region, I decided to use
<code>Array2D</code> data type to be able to iterate in different order. The whole algorithm operates
with black or white points defined as a helper type:</p>
<pre><code class="language-fsharp">type BW = B | W</code></pre>
<p>So the <code>removePadding</code> function has type of <code>BW[,] -&gt; BW[,]</code> and looks
like this:</p>
<pre><code class="language-fsharp">let removePadding pixels =
  let allBlack s = Seq.exists ((=) W) s
  let maxWidth = Array2D.length1 pixels - 1
  let maxHeight = Array2D.length2 pixels - 1
  let firstX = [0..maxWidth] 
    |&gt; Seq.tryFindIndex (fun y -&gt; allBlack pixels.[y, 0..maxHeight])
  let lastX = [0..maxWidth] 
    |&gt; Seq.tryFindIndexBack (fun y -&gt; allBlack pixels.[y, 0..maxHeight])
  let firstY = [0..maxHeight] 
    |&gt; Seq.tryFindIndex (fun x -&gt; allBlack pixels.[0..maxWidth, x])
  let lastY = [0..maxHeight] 
    |&gt; Seq.tryFindIndexBack (fun x -&gt; allBlack pixels.[0..maxWidth, x])

  match (firstX, lastX, firstY, lastY) with
  | (Some fx, Some lx, Some fy, Some ly) -&gt; pixels.[fx..lx, fy..ly]
  | _ -&gt; Array2D.init 0 0 (fun _ _ -&gt; B)</code></pre>
<p>The first part finds the amount of fully-black columns and rows in the array.
Then, if white points are found, the second part returns a sub array based on
the indices, otherwise empty array is returned.</p>
<h2 id="split-the-text-into-characters">Split the text into characters</h2>
<p>First, we convert our 2D array into the list of lists, where each item in the
top-level list represents a single column of pixels:</p>
<pre><code class="language-fsharp">let pixelColumns =
  [0..Array2D.length1 pixels - 1] 
  |&gt; Seq.map (fun x -&gt; pixels.[x, 0..Array2D.length2 pixels - 1] |&gt; List.ofArray)</code></pre>
<p>Then we can fold this list of columns into the symbols, where each symbol itself
is the list of columns:</p>
<pre><code class="language-fsharp">let splitIntoSymbols (e : BW list) (state: BW list list list) = 
  match state with
  | cur::rest -&gt;
      if isSeparator e then
        match cur with
        | _::_ -&gt; []::state // add new list
        | _ -&gt; state        // skip if we already have empty item
      else (e::cur)::rest   // add e to current list
  | _ -&gt; [[e]]

Seq.foldBack splitIntoSymbols pixelColumns []</code></pre>
<p>The type of <code>state</code> is a bit of brain teaser, I guess it could be improved
by introducing some intermediate type with descriptive name, but I decided
to leave that part for now. Read it as list of symbols, which are lists of
columns, which are lists of pixels.</p>
<h2 id="match-the-symbols-vs-the-known-patterns">Match the symbols vs the known patterns</h2>
<p>This part was already described in <a href="https://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">my first article</a>.
Basically we compare the list of black or white points to the patterns of
the known symbols:</p>
<pre><code class="language-fsharp">let getChar patterns bws =
  let samePatterns h p =
    Seq.zip h p
    |&gt; Seq.forall (fun (v1, v2) -&gt; v1 = v2)
  let matchingPattern = 
    patterns 
      |&gt; Array.filter (fun p -&gt; List.length p.Pattern = List.length bws)
      |&gt; Array.filter (fun p -&gt; samePatterns bws p.Pattern)
      |&gt; Array.tryHead
  defaultArg (Option.map (fun p -&gt; p.Char) matchingPattern) &#39;?&#39;</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The <code>recognizeString</code> function accepts lower-order functions to match 
symbols and get pixels together with width and height of the region:</p>
<pre><code class="language-fsharp">recognizeString: (BW list list -&gt; char) -&gt; (int -&gt; int -&gt; color) -&gt; int -&gt; int -&gt; string</code></pre>
<p>It builds an array of pixels, removes padding and folds with recognition.</p>
<pre><code class="language-fsharp">let recognizeString matchSymbol getPixel width height =

  let pixels = 
    Array2D.init width height (fun x y -&gt; isWhite (getPixel x y))
    |&gt; removePadding

  let pixelColumns =
    [0..Array2D.length1 pixels - 1] 
    |&gt; Seq.map (fun x -&gt; pixels.[x, 0..Array2D.length2 pixels - 1] |&gt; List.ofArray)      

  Seq.foldBack splitIntoSymbols pixelColumns []
  |&gt; List.map matchSymbol
  |&gt; Array.ofSeq
  |&gt; String.Concat</code></pre>
<p>Then we use it with a specific recognition patterns, e.g. known digits in case
of numbers recognition:</p>
<pre><code class="language-fsharp">let recognizeNumber x =
  recognizeString (getChar numberPatterns) x</code></pre>
<p>A way to produce these patterns is discussed in <a href="https://mikhail.io/2016/02/building-a-poker-bot-card-recognition/">the previous part</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>String recognition takes a bit more steps to execute comparing to the recognition
of fixed objects. Nevertheless it&#39;s pretty straightforward to implement once
we split it into small and well-understood conversion steps. The full code 
for card recognition can be found in <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/StringRecognition.fs">my github repo</a>.</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/poker-bot/'>Poker Bot</a>, <a href='/tags/f#/'>F#</a>, <a href='/tags/image-recognition/'>Image Recognition</a>, <a href='/tags/ocr/'>OCR</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Feb 8th, 2016</div>
    
    <h1><a href='/2016/02/akka-net-style-actors-in-service-fabric/'>Akka.NET-style actors in Service Fabric</a></h1>
    

    

    <div class="post-content">
        <p>Akka.NET and Service Fabric are the two actor frameworks that emerged in .NET world in the last year.
The two implementations of actor models are quite different. These differences are multi-faceted but
today I want to focus on API to define an actor and to communicate to it.</p>
<h2 id="service-fabric-actors">Service Fabric Actors</h2>
<p>Every actor in Service Fabric has a public interface which describes its behaviour. For this article
I&#39;m going to use a toy example based on weather reports. Our actor will be able to get whether reports
and then return the maximum temperature for a given period. An instance of actor will be created
for each city (geo partitioning). Here is our interface in Service Fabric:</p>
<pre><code class="language-csharp">public interface IWeatherActor : IActor
{
    Task AddWeatherReport(WeatherReport report);

    Task&lt;int?&gt; GetMaxTemperature(Period period);
}</code></pre>
<p>We have two operations: a command and a query. They are both async (return <code>Task</code>). The data classes
are required to be mutable DTOs based on <code>DataContract</code>:</p>
<pre><code class="language-csharp">[DataContract]
public class WeatherReport
{
    [DataMember]
    public DateTime Moment { get; set; }
    [DataMember]
    public int Temperature { get; set; }
    [DataMember]
    public int Humidity { get; set; }
}

[DataContract]
public class Period
{
    [DataMember]
    public DateTime From { get; set; }
    [DataMember]
    public DateTime Until { get; set; }
}</code></pre>
<p>And here is the implementation of the weather actor:</p>
<pre><code class="language-csharp">internal class WeatherActor : StatefulActor&lt;List&lt;WeatherReport&gt;&gt;, IWeatherActor
{
    public Task AddWeatherReport(WeatherReport report)
    {
        this.State = this.State ?? new List&lt;WeatherReport&gt;();
        this.State.Add(report);
        return Task.FromResult(0);
    }

    public Task&lt;int?&gt; GetMaxTemperature(Period period)
    {
        return Task.FromResult(
            (this.State ?? Enumerable.Empty&lt;WeatherReport&gt;())
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (int?)r.Temperature));
    }
}</code></pre>
<p>Service Fabric provides reliable storage out of the box, so we are using it to
store our reports. There&#39;s no code required to instantiate an actor. Here is the
code to use it:</p>
<pre><code class="language-csharp">// Submit a new report
IWeatherActor actor = ActorProxy.Create&lt;IWeatherActor&gt;(new ActorId(&quot;Amsterdam&quot;));
actor.AddWeatherReport(
    new WeatherReport { Moment = DateTime.Now, Temperature = 22, Humidity = 55 });

// Make a query somewhere else
IWeatherActor actor = ActorProxy.Create&lt;IWeatherActor&gt;(new ActorId(&quot;Amsterdam&quot;));
var result = actor.GetMaxTemperature(new Period { From = monthAgo, Until = now });</code></pre>
<h2 id="akka-net-actors">Akka.NET Actors</h2>
<p>Actors in Akka.NET are message-based. The messages are immutable POCOs, which 
is a great design decision. Here are the messages for our scenario:</p>
<pre><code class="language-csharp">public class WeatherReport
{
    public WeatherReport(DateTime moment, int temperature, int humidity)
    {
        this.Moment = moment;
        this.Temperature = temperature;
        this.Humidity = humidity;
    }

    public DateTime Moment { get; }
    public int Temperature { get; }
    public int Humidity { get; }
}

public class Period
{
    public Period(DateTime from, DateTime until)
    {
        this.From = from;
        this.Until = until;
    }

    public DateTime From { get; }
    public DateTime Until { get; }
}
</code></pre>
<p>There&#39;s no need to define any interfaces. The basic actor implementation derives from
<code>ReceiveActor</code> and calls <code>Receive</code> generic method to setup a callback which is called
when a message of specified type is received:</p>
<pre><code class="language-csharp">public class WeatherActor : ReceiveActor
{
    private List&lt;WeatherReport&gt; state = new List&lt;WeatherReport&gt;();

    public WeatherActor()
    {
        Receive&lt;WeatherReport&gt;(this.AddWeatherReport);
        Receive&lt;Period&gt;(this.GetMaxTemperature);
    }

    public void AddWeatherReport(WeatherReport report)
    {
        this.state.Add(report);
    }

    public void GetMaxTemperature(Period period)
    {
        var response = this.state
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (int?)r.Temperature);
        Sender.Tell(response, Self);
    }
}</code></pre>
<p>Note a couple more differences in this implementation comparing to Fabric style:</p>
<ul>
<li><p>State is stored in a normal class field and is not persistent or replicated
by default. This can be solved by Akka.NET Persistence, which would save all
messages (and potentially snapshots) to the external database. Still, it won&#39;t
be the same level of convenience as in-built Service Fabric statefullness.</p>
</li>
<li><p><code>GetMaxTemperature</code> method does not return anything, because nobody would look
at the returned value. Instead, it sends yet another message to the sender actor.
So, <code>Request-Response</code> workflow is supported but is a bit less convenient and
explicit.</p>
</li>
</ul>
<p>Let&#39;s have a look at the client code. <code>ActorSelection</code> is the closest notion to
Fabric&#39;s <code>ActorProxy</code>: it does not create an actor, but just gets an endpoint
based on the name. Note that Akka.NET actor needs to be explicitly created by
another actor, but lifetime management is a separate discussion, so we&#39;ll skip 
it for now. Here is the report sender:</p>
<pre><code class="language-csharp">// Submit a new report
var msg = new WeatherReport { Moment = DateTime.Now, Temperature = 22, Humidity = 55 };
Context.ActorSelection(&quot;/user/weather/Amsterdam&quot;).Tell(msg);</code></pre>
<p>Asking <code>ActorSelection</code> is not directly possible, we would need to setup an
inbox and receive callback messages. We&#39;ll pretend that we have an <code>ActorRef</code>
for the sake of simplicity:</p>
<pre><code class="language-csharp">// Make a query somewhere else
ActoRef actor = ... ; // we have it
var result = await actor.Ask(new Period { From = monthAgo, Until = now });</code></pre>
<h2 id="the-best-of-two-worlds">The Best of Two Worlds</h2>
<p>Now my goals is to come up with an implementation of Service Fabric actors with
the properties that combine the good parts of both frameworks (without explicitly
using Akka.NET), i.e.</p>
<ul>
<li>Use the full power of Service Fabric actors, including lifetime management,
cluster management and reliable state</li>
<li>Use the simplicity of Request-Response pattern implementation of Service Fabric</li>
<li>Support immutable POCO messages instead of <code>DataContract</code> DTOs</li>
<li>Use <code>ReceiveActor</code>-like API for message processing</li>
</ul>
<p>Here is the third implementation of our Weather Actor (the definitions of messages
from Akka.NET example are intact):</p>
<pre><code class="language-csharp">[ActorService(Name = &quot;WeatherActor&quot;)]
public class WeatherActor : StetefulReceiveActor&lt;List&lt;WeatherReport&gt;&gt;
{
    public WeatherActor()
    {
        Receive&lt;WeatherReport&gt;(this.AddWeatherReport);
        Receive&lt;Period, int&gt;(this.GetMaxTemperature);
    }

    public Task&lt;List&lt;WeatherReport&gt;&gt; AddWeatherReport(
        List&lt;WeatherReport&gt; state, WeatherReport report)
    {
        state = state ?? new List&lt;WeatherReport&gt;();
        state.Add(report);
        return Task.FromResult(state);
    }

    public Task&lt;int?&gt; GetMaxTemperature(List&lt;WeatherReport&gt; state, Period period)
    {
        return Task.FromResult(
            (state ?? Enumerable.Empty&lt;WeatherReport&gt;())
            .Where(r =&gt; r.Moment &gt; period.From &amp;&amp; r. Moment &lt;= period.Until)
            .Max(r =&gt; (int?)r.Temperature));
    }
}</code></pre>
<p>The base <code>ReceiveActor</code> class is not defined yet, we&#39;ll do it in the next section. Here is
how it&#39;s being used:</p>
<ul>
<li>The base class is generic and it accepts the type of the state (similar to normal Fabric actors)</li>
<li>Constructor registers two <code>Receive</code> handlers: message handler and request handler. Note
that the later one accepts two type parameters: request type and response type</li>
<li>Both handlers get the current state as the first argument instead of pulling it from the property of
the base class</li>
<li>The both return <code>Task</code>&#39;ed data. Message handler is allowed to change the state, while
request handler does  not change the state but just returns the response back</li>
<li><code>ServiceName</code> attribute is required because there are (may be) multiple classes implementing
the same interface</li>
</ul>
<p>The client code uses our own <code>MessageActorProxy</code> class to create non-generic proxies which
are capable to <code>Tell</code> (send a message one way) and <code>Ask</code> (do request and wait for response):</p>
<pre><code class="language-csharp">// Submit a new report
var actor = MessageActorProxy.Create(new ActorId(&quot;Amsterdam&quot;), &quot;WeatherActor&quot;);
actor.Tell(new WeatherReport { Moment = DateTime.Now, Temperature = 22, Humidity = 55 });

// Make a query somewhere else
var actor = MessageActorProxy.Create(new ActorId(&quot;Amsterdam&quot;), &quot;WeatherActor&quot;);
var result = actor.Ask(new Period { From = monthAgo, Until = now });</code></pre>
<h2 id="implementation-of-receiveactor">Implementation of ReceiveActor</h2>
<p>Let&#39;s start with the interface definition:</p>
<pre><code class="language-csharp">public interface IReceiveActor : IActor
{
    Task Tell(string typeName, byte[] message);

    [Readonly]
    Task&lt;byte[]&gt; Ask(string typeName, byte[] message);
}</code></pre>
<p>The two methods for <code>Tell</code> and <code>Ask</code> accept serializes data together with fully qualified
type name. This will allow passing any kind of objects which can be handled by a serializer
of choice (I used Newtonsoft JSON serializer).</p>
<p>Actor implementation derives from <code>StatefulActor</code> and uses another type/bytes pair to store
the serialized state:</p>
<pre><code class="language-csharp">    public abstract class StatefulReceiveActor : StatefulActor&lt;StateContainer&gt;, 
                                                 IReceiveActor
    {
        // ...
    }

    [DataContract]
    public class StateContainer
    {
        [DataMember]
        public string TypeName { get; set; }

        [DataMember]
        public byte[] Data { get; set; }
    }</code></pre>
<p>The simplistic implementation of <code>Receive</code> generic methods uses two dictionaries
to store the handlers:</p>
<pre><code class="language-csharp">private Dictionary&lt;Type, Func&lt;object, object, Task&lt;object&gt;&gt;&gt; handlers;
private Dictionary&lt;Type, Func&lt;object, object, Task&lt;object&gt;&gt;&gt; askers;

public ReceiveActor()
{
    this.handlers = new Dictionary&lt;Type, Func&lt;object, object, Task&lt;object&gt;&gt;&gt;();
    this.askers = new Dictionary&lt;Type, Func&lt;object, object, Task&lt;object&gt;&gt;&gt;();
}

protected void Receive&lt;T&gt;(Func&lt;object, T, Task&lt;object&gt;&gt; handler)
    =&gt; this.handlers.Add(typeof(T), async (s, m) =&gt; await handler(s, (T)m));

protected void Receive&lt;TI, TO&gt;(Func&lt;object, TI, Task&lt;TO&gt;&gt; asker)
    =&gt; this.askers.Add(typeof(TI), async (s, m) =&gt; await asker(s, (TI)m));
</code></pre>
<p>The <code>Tell</code> method deserializes the message and state, then picks a handler based on
the message type, executes it and serializes the produced state back:</p>
<pre><code class="language-csharp">public async Task Tell(string typeName, byte[] message)
{
    var type = Type.GetType(typeName);
    var typedMessage = this.serializer.Deserialize(message, type);

    var typedState = this.State != null
        ? this.serializer.Deserialize(this.State.Data, Type.GetType(this.State.TypeName))
        : null;
    var handler = this.handlers.FirstOrDefault(t =&gt; t.Key.IsAssignableFrom(type)).Value;
    if (handler != null)
    {
        var newState = await handler(typedState, typedMessage);
        this.State =
            newState != null
            ? new StateContainer 
              { 
                  Data = this.serializer.Serialize(newState), 
                  TypeName = newState.GetType().AssemblyQualifiedName 
              }
            : null;
    }
}</code></pre>
<p>The implementation of <code>Ask</code> is almost identical, so I&#39;ll skip it. <code>MessageActorProxy</code> 
encapsulates the serialization around passing data to normal <code>ActorProxy</code> class:</p>
<pre><code class="language-csharp">public class MessageActorProxy
{
    private readonly IStatefulMessageActor proxy;
    private readonly ISerializer serializer = new JsonByteSerializer();

    private MessageActorProxy(ActorId actorId, string serviceName)
    {
        this.proxy = ActorProxy.Create&lt;IReceiveActor&gt;(actorId, serviceName: serviceName);
    }

    public async Task Tell(object message)
    {
        var serialized = this.serializer.Serialize(message);
        await this.proxy.Send(message.GetType().AssemblyQualifiedName, serialized);
    }

    public async Task&lt;T&gt; Ask&lt;T&gt;(object message)
    {
        var serialized = this.serializer.Serialize(message);
        var fullName = message.GetType().AssemblyQualifiedName;
        var response = await this.proxy.Ask(fullName, serialized);
        return (T)this.serializer.Deserialize(response, typeof(T));
    }

    public static MessageActorProxy Create(ActorId actorId, string serviceType)
    {
        return new MessageActorProxy(actorId, serviceType);
    }
}</code></pre>
<p>Let&#39;s briefly wrap it up.</p>
<h2 id="conclusion">Conclusion</h2>
<p>At this stage Azure Service Fabric lacks support of some actor model best practices
like message-based API and immutable POCO classes. At the same time, it provides
super powerful setup regarding cluster resource management, state replication, fault
tolerance and reliable communication. We can borrow some approaches that are used in Akka.NET
framework to improve the developer experience who wants to leverage the power
of Service Fabric.</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/service-fabric/'>Service Fabric</a>, <a href='/tags/akka-net/'>Akka.NET</a>, <a href='/tags/actor-model/'>Actor Model</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Feb 1st, 2016</div>
    
    <h1><a href='/2016/02/building-a-poker-bot-card-recognition/'>Building a Poker Bot: Card Recognition</a></h1>
    

    

    <div class="post-content">
        <p><em>This is the first part of <strong>Building a Poker Bot</strong> series where I describe my experience developing bot software 
for online poker rooms. I&#39;m building the bot with .NET framework and F# language which makes the task relatively 
easy and very enjoyable.</em></p>
<h2 id="screen-recognition">Screen recognition</h2>
<p>For a human, the very first step to the ability to play poker is to understand the cards, what a hand is and 
what the value of your hand is. E.g. in Texas Holdem each player gets 2 hole cards which form a hand. At 
the showdown the player with the best hand wins.</p>
<p>Poker bots are no different, they also need to be taught the notion of cards and hands. A bot should &quot;watch&quot; 
the table and see which cards he is dealt with. There are several ways to achieve that but I go for a technique
called screen recognition, i.e. the bot makes a screenshot of a table and then reads the pixels to understand
what&#39;s going on. Very similar to what people do.</p>
<p>Image recognition in general is a tough task. Human beings are very good at interpreting vague images and
recognizing familiar objects. It&#39;s much more difficult for computers. General image recognition (think showing
a photo to your computer and asking whether there is an animal there) is very tough; corporations like Google
and Microsoft are spending numerous man-years and employ techniques like machine learning and neural networks.</p>
<p>Fortunately, poker table recognition is much easier. The images to be recognized are machine-generated, so
the same things are rendered more or less the same way all the time. It makes sense to keep the poker table
size fixed to some predefined value which makes recognition task fairly easy.</p>
<h2 id="card-recognition-steps">Card recognition steps</h2>
<p>There are 13 card faces (from Deuce to Ace) and 4 suits. All of them are just fixed-size images which we need to be able to
match with. So we start with a screenshot of a poker table:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//table.png" alt="Poker table screenshot"></p>
<p>The table size is fixed, so are the left and the top pixel positions of hole cards. So, our first step is to extract
the small images of cards out of the big screenshot:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//cards.png" alt="Extracted card images"></p>
<p>Now, we can take the recognition of card faces and suits separately. In our sample layout, suits are color coded.
This is very friendly to humans and super simple for the bot. We pick the suit based on the color (ignoring 
the white pixels):</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//suits.png" alt="Recognized suits"></p>
<p>This leaves us with the task of choosing between 13 card faces. The color information is not important
here, we can make the image grey-scale. Moreover, we can reduce the color information to the single bit per 
pixel - call it white or black:</p>
<p><img src="/2016/02/building-a-poker-bot-card-recognition//blackandwhite.png" alt="Black and white pixels"></p>
<p>Now this mask is very simple, and we can compare it with 13 predefined masks for 13 cards pixel by pixel.
The one with the biggest amount of matches wins.</p>
<h2 id="suit-recognition">Suit recognition</h2>
<p>Let&#39;s put some code at the table. We start with suit recognition. <code>getSuit</code> function has type 
<code>Color -&gt; string option</code> and converts the color of a pixel into the suit name, if possible. Hearts (&quot;h&quot;)
are red, Diamonds (&quot;d&quot;) are blue, Clubs (&quot;c&quot;) are green and Spades (&quot;s&quot;) are black:</p>
<pre><code class="language-fsharp">let getSuit (c : Color) =
  match c with
  | _ when c.B &lt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &gt; 127uy -&gt; Some &quot;h&quot;
  | _ when c.B &gt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;d&quot;
  | _ when c.B &lt; 127uy &amp;&amp; c.G &gt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;c&quot;
  | _ when c.B &lt; 127uy &amp;&amp; c.G &lt; 127uy &amp;&amp; c.R &lt; 127uy -&gt; Some &quot;s&quot;
  | _ -&gt; None</code></pre>
<p>This function is used by <code>getCardSuit</code> function of type <code>(int -&gt; int -&gt; Color) -&gt; int -&gt; int -&gt; string</code>.
Its first argument is a function which returns the color of a pixel based on <code>(x, y)</code>
relative coordinates (starting with 0). The next two arguments are width and height of the cards. Result is
the same suit name that we described above. The function loops through all the pixels, gets a suit per
pixel and then returns the suit which is the most popular among them. Alternatively, we could just return
the first suit found, but my implementation looks more resilient:</p>
<pre><code class="language-fsharp">let getCardSuit getPixel width height =    
  seq { for x in 0 .. width - 1 do
          for y in 0 .. height - 1 do
            yield getSuit (getPixel x y) }
  |&gt; Seq.choose id
  |&gt; Seq.countBy id
  |&gt; Seq.maxBy (fun (v, c) -&gt; c)
  |&gt; fst</code></pre>
<h2 id="producing-the-black-white-pattern">Producing the black &amp; white pattern</h2>
<p><code>getCardPattern</code> accepts the same parameters as <code>getSuits</code> but returns <code>seq&lt;BW&gt;</code> instead. This is
a sequence of black or white pixels with a helper union type:</p>
<pre><code class="language-fsharp">type BW = B | W</code></pre>
<p>The function body enumerates the pixels and return black or white result as a flat sequence:</p>
<pre><code class="language-fsharp">let getCardPattern getPixel width height =
  let isWhite (c : Color) =
    if c.B &gt; 127uy &amp;&amp; c.G &gt; 127uy &amp;&amp; c.R &gt; 127uy then W
    else B

  seq { for x in 0 .. width - 1 do
          for y in 0 .. height - 1 do
            yield isWhite (getPixel x y) } </code></pre>
<h2 id="card-face-recognition">Card face recognition</h2>
<p>Having a black and white pattern, we can compare it with the predefined patterns and pick the
most similar one. A pattern is defined with a helper type</p>
<pre><code class="language-fsharp">type CardPattern = {
  Card: string
  Pattern: BW array
}</code></pre>
<p><code>Pattern</code> is a sequence which is equivalent to the sequence we got on the previous step. 
<code>Card</code> is a string of hand face value 2, 3, 4 .. A. <code>getCardFace</code> has the type 
<code>CardPattern[] -&gt; seq&lt;BW&gt; -&gt; string</code>, it accepts an array of known patterns and a pattern
of the card to be recognized. It compares patterns pixel by pixel and returns the card
which has the biggest amount of matches:</p>
<pre><code class="language-fsharp">let getCardFace patterns bws =
  let matchCount h p =
    Seq.zip h p
    |&gt; Seq.map (fun (v1, v2) -&gt; if v1 = v2 then 1 else 0)
    |&gt; Seq.sum
    |&gt; decimal
  let maxPattern = patterns |&gt; Array.maxBy (fun p -&gt; matchCount bws p.Pattern)
  maxPattern.Card</code></pre>
<h2 id="getting-the-known-patterns">Getting the known patterns</h2>
<p>So how do we create an array of known patterns? It&#39;s tedious to do manually, so
we use a bit of code generation.
Basically we just take several screenshots of poker tables and feed them to the following 
helper function:</p>
<pre><code class="language-fsharp">let parsePattern getPixel width height =
  getCardPattern getPixel width height
  |&gt; Seq.map (fun x -&gt; if x = B then &quot;B&quot; else &quot;W&quot;) 
  |&gt; String.concat &quot;;&quot;</code></pre>
<p>The function creates a string which can be copy-pasted into F# array of <code>BW</code>.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Here is the facade function that will be called from the outside:</p>
<pre><code class="language-fsharp">let recognizeCard getPixel width height = 
  let value = 
    getCardPattern getPixel width height 
    |&gt; getCardValue patterns
  let suit = getCardSuit getPixel width height
  value + suit</code></pre>
<p>The calling code looks like this:</p>
<pre><code class="language-fsharp">let image = new Bitmap(&quot;...&quot;);

let getPixel offsetX offsetY x y = 
  image.GetPixel(offsetX + x, offsetY + y)

let hand = (recognizeCard (getPixel leftX top) width height) + (recognizeCard (getPixel rightX top) width height)</code></pre>
<p><code>leftX</code>, <code>rightX</code>, <code>top</code>, <code>width</code> and <code>height</code> are well-known parameters of cards locations within a screenshot, 
which are hard coded for a given table size.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The full code for card recognition can be found in my <a href="https://github.com/mikhailshilkov/mikhailio-samples/blob/master/HandRecognition.fs">github repo</a>. It&#39;s just 75 lines of code which is
much less that one could imagine for a task of image recognition. Similar code could be used to recognize other
fixed objects at poker table: dealer button location, action buttons, checkboxes etc. In the next part of this
series I will show how to recognize non-fixed parts: text and numbers.</p>
<p><em>Proceed to <a href="https://mikhail.io/2016/02/building-a-poker-bot-string-number-recognition/">Part 2 of Building a Poker Bot: String and Number Recognition</a>.</em></p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/poker-bot/'>Poker Bot</a>, <a href='/tags/f#/'>F#</a>, <a href='/tags/image-recognition/'>Image Recognition</a>
    </div>
    
</article>

    <article class="post">
    <div class="post-date">Jan 25th, 2016</div>
    
    <h1><a href='/2016/01/monads-explained-in-csharp/'>Monads explained in C#</a></h1>
    

    

    <div class="post-content">
        <p><em>The newer and much longer version of this article is now available:</em>
<a href="https://mikhail.io/2018/07/monads-explained-in-csharp-again/">Monads explained in C# (again)</a></p>
<p>It looks like there is a mandatory post that every blogger who learns functional programming should write:
what a Monad is. Monads have the reputation of being something very abstract and very confusing for every
developer who is not a hipster Haskell programmer. They say that once you understand what a monad is, you 
loose the ability to explain it in simple language. Doug Crockford was the first one to lay this rule down, but
it becomes kind of obvious once you read 3 or 5 explanations on the web. Here is my attempt, probably doomed
to fail :)</p>
<h2 id="monads-are-container-types">Monads are container types</h2>
<p>Monads represent a class of types which behave in the common way.</p>
<p>Monads are containers which encapsulate some kind of functionality. On top of
that, they provide a way to combine two containers into one. And that&#39;s about it. </p>
<p>The goals of monads are similar to generic goals of any encapsulation in 
software development practices: hide the implementation details from the client, 
but provide a proper way to use the hidden functionality. </p>
<p>It&#39;s not because we 
want to be able to change the implementation, it&#39;s because we want to make the 
client as simple as possible and to enforce the best way of code structure. 
Quite often monads provide the way to avoid imperative code in favor of 
functional style.</p>
<p>Monads are flexible, so in C# we could try to represent a monadic type as 
a generic class:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
}</code></pre>
<h2 id="monad-instances-can-be-created">Monad instances can be created</h2>
<p>Quite an obvious statement, isn&#39;t it. Having a class <code>Monad&lt;T&gt;</code>, there should 
be a way to create an object of this class out of an instance of type <code>T</code>. 
In functional world this operation is known as <code>Return</code> function. In C# it 
can be as simple as a constructor:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
    public Monad(T instance)
    {
    }
}</code></pre>
<p>But usually it makes sense to define an extension method to enable fluent 
syntax of monad creation:</p>
<pre><code class="language-csharp">public static class MonadExtensions
{
    public static Monad&lt;T&gt; Return&lt;T&gt;(this T instance) =&gt; new Monad&lt;T&gt;(instance);
}</code></pre>
<h2 id="monads-can-be-chained-to-create-new-monads">Monads can be chained to create new monads</h2>
<p>This is the property which makes monads so useful, but also a bit confusing. 
In functional world this operation is expressed with the <code>Bind</code> function 
(or <code>&gt;&gt;=</code> operator). Here is the signature of <code>Bind</code> method in C#:</p>
<pre><code class="language-csharp">public class Monad&lt;T&gt;
{
    public Monad&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Monad&lt;TO&gt;&gt; func)
    {
    }
}</code></pre>
<p>As you can see, the <code>func</code> argument is a complicated thing. It accepts an 
argument of type <code>T</code> (not a monad) and returns an instance of <code>Monad&lt;TO&gt;</code> 
where <code>TO</code> is another type. Now, our first instance of <code>Monad&lt;T&gt;</code> knows 
how to bind itself to this function to produce another instance of monad 
of the new type. The full power of monads comes when we compose several of 
them in one chain:</p>
<pre><code class="language-csharp">initialValue
    .Return()
    .Bind(v1 =&gt; produceV2OutOfV1(v1))
    .Bind(v2 =&gt; produceV3OutOfV2(v2))
    .Bind(v3 =&gt; produceV4OutOfV3(v3))
    //...</code></pre>
<p>Let&#39;s have a look at some examples.</p>
<p><a name="maybe" href="/2016/01/monads-explained-in-csharp/undefined"></a></p>
<h2 id="example-maybe-option-type">Example: Maybe (Option) type</h2>
<p><code>Maybe</code> is the 101 monad which is used everywhere. <code>Maybe</code> is another approach 
to dealing with &#39;no value&#39; value, alternative to the concept of <code>null</code>. 
Basically your object should never be null, but it can either have <code>Some</code> 
value or be <code>None</code>. F# has a maybe implementation built into the language: 
it&#39;s called <code>option</code> type. Here is a sample implementation in C#:</p>
<pre><code class="language-csharp">public class Maybe&lt;T&gt; where T : class
{
    private readonly T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new ArgumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe&lt;TO&gt; Bind&lt;TO&gt;(Func&lt;T, Maybe&lt;TO&gt;&gt; func) where TO : class
    {
        return value != null ? func(value) : Maybe&lt;TO&gt;.None();
    }

    public static Maybe&lt;T&gt; None() =&gt; new Maybe&lt;T&gt;();
}</code></pre>
<pre><code class="language-csharp">public static class MaybeExtensions
{
    public static Maybe&lt;T&gt; Return&lt;T&gt;(this T value) where T : class
    {
        return value != null ? new Maybe&lt;T&gt;(value) : Maybe&lt;T&gt;.None();
    }
}</code></pre>
<p>Return function is implemented with a combination of a public constructor 
which accepts <code>Some</code> value (notice that <code>null</code> is not allowed) and a static 
<code>None</code> method returning an object of &#39;no value&#39;. <code>Return</code> extension method
combines both of them in one call. </p>
<p><code>Bind</code> function is implemented explicitly. </p>
<p>Let&#39;s have a look at a use case. Imagine we have a traditional repository 
which loads data from an external storage (no monads yet):</p>
<pre><code class="language-csharp">public interface ITraditionalRepository
{
    Customer GetCustomer(int id);
    Address GetAddress(int id);
    Order GetOrder(int id);
}</code></pre>
<p>Now, we write a client class which loads data one by one and tries to find
a shipper:</p>
<pre><code class="language-csharp">Shipper shipperOfLastOrderOnCurrentAddress = null;
var customer = repo.GetCustomer(customerId);
if (customer?.Address != null)
{
    var address = repo.GetAddress(customer.Address.Id);
    if (address?.LastOrder != null)
    {
        var order = repo.GetOrder(address.LastOrder.Id);
        shipperOfLastOrderOnCurrentAddress = order?.Shipper;
    }
}
return shipperOfLastOrderOnCurrentAddress;</code></pre>
<p>Note, that the code assumes that repository returns <code>null</code> if some entity
is not found, although nothing in the type system shows that. Then, there
is a number of <code>null</code> checks (facilitated with elvis operator). The code gets
a bit cluttered and less linear.</p>
<p>Here is an alternative repository which returns <code>Maybe</code> type:</p>
<pre><code class="language-csharp">public interface IMonadicRepository
{
    Maybe&lt;Customer&gt; GetCustomer(int id);
    Maybe&lt;Address&gt; GetAddress(int id);
    Maybe&lt;Order&gt; GetOrder(int id);
}</code></pre>
<p>The contract is more explicit: you see that <code>Maybe</code> type is used, so you
will be forced to handle the case of absent value.</p>
<p>And here is how the above example can be rewritten with <code>Bind</code> method 
composition:</p>
<pre><code class="language-csharp">Maybe&lt;Shipper&gt; shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c =&gt; c.Address)
        .Bind(a =&gt; repo.GetAddress(a.Id))
        .Bind(a =&gt; a.LastOrder)
        .Bind(lo =&gt; repo.GetOrder(lo.Id))
        .Bind(o =&gt; o.Shipper);</code></pre>
<p>There&#39;s no branching anymore, the code is fluent and linear.</p>
<p>If you think that the syntax looks very much like a LINQ query with a bunch 
of <code>Select</code> statements, you are not the only one ;) One of the common 
implementations of <code>Maybe</code> implements <code>IEnumerable</code> interface which allows 
a more C#-idiomatic binding composition. Actually:</p>
<h2 id="ienumerable-selectmany-is-a-monad-">IEnumerable + SelectMany is a monad </h2>
<p><code>IEnumerable</code> is an interface for enumerable containers.</p>
<p>Enumerable containers can be created - thus the <code>Return</code> monadic operation.</p>
<p>The <code>Bind</code> operation is defined by the standard LINQ extension method, here 
is its signature:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;B&gt; SelectMany&lt;A, B&gt;(
    this IEnumerable&lt;A&gt; first, 
    Func&lt;A, IEnumerable&lt;B&gt;&gt; selector)</code></pre>
<p>And here is an example of composition:</p>
<pre><code class="language-csharp">IEnumerable&lt;Shipper&gt; someWeirdListOfShippers =
    customers
        .SelectMany(c =&gt; c.Addresses)
        .SelectMany(a =&gt; a.Orders)
        .SelectMany(o =&gt; o.Shippers);</code></pre>
<p>The query has no idea about how the collections are stored (encapsulated in
containers). We use functions <code>A -&gt; IEnumerable&lt;B&gt;</code> to produce new enumerables
(<code>Bind</code> operation).</p>
<h2 id="monad-laws">Monad laws</h2>
<p>There are a couple of laws that <code>Return</code> and <code>Bind</code> need to adhere to, so
that they produce a proper monad.</p>
<p><strong>Identity law</strong> says that that <code>Return</code> is a neutral operation: you can safely
run it before <code>Bind</code>, and it won&#39;t change the result of the function call:</p>
<pre><code class="language-csharp">// Given
T value;
Func&lt;T, M&lt;U&gt;&gt; f;

// == means both parts are equivalent
value.Return().Bind(f) == f(value) </code></pre>
<p><strong>Associativity law</strong> means that the order in which <code>Bind</code> operations
are composed does not matter:</p>
<pre><code class="language-csharp">// Given
M&lt;T&gt; m;
Func&lt;T, M&lt;U&gt;&gt; f;
Func&lt;U, M&lt;V&gt;&gt; g;

// == means both parts are equivalent
m.Bind(f).Bind(g) == m.Bind(a =&gt; f(a).Bind(g))</code></pre>
<p>The laws may look complicated, but in fact they are very natural 
expectations that any developer has when working with monads, so don&#39;t
spend too much mental effort on memorizing them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>You should not be afraid of the &quot;M-word&quot; just because you are a C# programmer. 
C# does not have a notion of monads as predefined language constructs, but 
it doesn&#39;t mean we can&#39;t borrow some ideas from the functional world. Having 
said that, it&#39;s also true that C# is lacking some powerful ways to combine 
and generalize monads which are possible in Haskell and other functional 
languages.</p>

    </div>

    

    
    <div class="post-tags">
        Posted In: <a href='/tags/functional-programming/'>Functional Programming</a>, <a href='/tags/monads/'>Monads</a>, <a href='/tags/maybe/'>Maybe</a>, <a href='/tags/linq/'>LINQ</a>
    </div>
    
</article>


<div class="page-nav">
    
    <a class="page-nav-newer" href="/10/index.html">&lt;&lt; Previous page</a>
    
    
    <a class="page-nav-older" href="/12/index.html">Next page &gt;&gt;</span></a>
    
</div>

<div id="me">
    <p itemscope itemtype="http://data-vocabulary.org/Person">
        <img src="/images/Headshot-Square.jpg" alt="Mikhail Shilkov" itemprop="photo" />
        I'm <b><span itemprop="name">Mikhail Shilkov</span></b>, a <span itemprop="title">software developer</span>. I enjoy F#, C#, Javascript and SQL development, reasoning about distributed systems, data processing pipelines, cloud and web apps. I blog about my experience on this website.
    </p>
    <p>
        <a href="https://www.linkedin.com/in/mikhailshilkov/">LinkedIn</a> &#8226;
        <a href="https://twitter.com/mikhailshilkov">@mikhailshilkov</a> &#8226;
        <a href="https://github.com/mikhailshilkov">GitHub</a> &#8226;
        <a href="https://stackoverflow.com/users/1171619/mikhail">Stack Overflow</a>
    </p>
</div>
</div>
<div class="container">
    <div class="navbar navbar-footer">
        <p class="navbar-center navbar-text">Content copyright &copy; 2018 Mikhail Shilkov</p>
    </div>
</div>



<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
<script src="/vendor/prism.js"></script>
<script src="/site.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59218480-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>